// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: synced_notification_render.proto

#ifndef PROTOBUF_synced_5fnotification_5frender_2eproto__INCLUDED
#define PROTOBUF_synced_5fnotification_5frender_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include "sync/base/sync_export.h"

namespace sync_pb {

// Internal implementation detail -- do not call these.
void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

class SyncedNotificationRenderInfo;
class CollapsedInfo;
class ExpandedInfo;
class SimpleCollapsedLayout;
class SimpleExpandedLayout;
class Media;
class Target;
class SyncedNotificationDestination;
class SyncedNotificationAction;
class SyncedNotificationImage;
class SyncedNotificationProfileImage;

// ===================================================================

class SYNC_EXPORT SyncedNotificationRenderInfo : public ::google::protobuf::MessageLite {
 public:
  SyncedNotificationRenderInfo();
  virtual ~SyncedNotificationRenderInfo();

  SyncedNotificationRenderInfo(const SyncedNotificationRenderInfo& from);

  inline SyncedNotificationRenderInfo& operator=(const SyncedNotificationRenderInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncedNotificationRenderInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncedNotificationRenderInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncedNotificationRenderInfo* other);

  // implements Message ----------------------------------------------

  SyncedNotificationRenderInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncedNotificationRenderInfo& from);
  void MergeFrom(const SyncedNotificationRenderInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sync_pb.CollapsedInfo collapsed_info = 1;
  inline bool has_collapsed_info() const;
  inline void clear_collapsed_info();
  static const int kCollapsedInfoFieldNumber = 1;
  inline const ::sync_pb::CollapsedInfo& collapsed_info() const;
  inline ::sync_pb::CollapsedInfo* mutable_collapsed_info();
  inline ::sync_pb::CollapsedInfo* release_collapsed_info();
  inline void set_allocated_collapsed_info(::sync_pb::CollapsedInfo* collapsed_info);

  // optional .sync_pb.ExpandedInfo expanded_info = 2;
  inline bool has_expanded_info() const;
  inline void clear_expanded_info();
  static const int kExpandedInfoFieldNumber = 2;
  inline const ::sync_pb::ExpandedInfo& expanded_info() const;
  inline ::sync_pb::ExpandedInfo* mutable_expanded_info();
  inline ::sync_pb::ExpandedInfo* release_expanded_info();
  inline void set_allocated_expanded_info(::sync_pb::ExpandedInfo* expanded_info);

  // @@protoc_insertion_point(class_scope:sync_pb.SyncedNotificationRenderInfo)
 private:
  inline void set_has_collapsed_info();
  inline void clear_has_collapsed_info();
  inline void set_has_expanded_info();
  inline void clear_has_expanded_info();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::CollapsedInfo* collapsed_info_;
  ::sync_pb::ExpandedInfo* expanded_info_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static SyncedNotificationRenderInfo* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT CollapsedInfo : public ::google::protobuf::MessageLite {
 public:
  CollapsedInfo();
  virtual ~CollapsedInfo();

  CollapsedInfo(const CollapsedInfo& from);

  inline CollapsedInfo& operator=(const CollapsedInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CollapsedInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CollapsedInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CollapsedInfo* other);

  // implements Message ----------------------------------------------

  CollapsedInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CollapsedInfo& from);
  void MergeFrom(const CollapsedInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sync_pb.SimpleCollapsedLayout simple_collapsed_layout = 1;
  inline bool has_simple_collapsed_layout() const;
  inline void clear_simple_collapsed_layout();
  static const int kSimpleCollapsedLayoutFieldNumber = 1;
  inline const ::sync_pb::SimpleCollapsedLayout& simple_collapsed_layout() const;
  inline ::sync_pb::SimpleCollapsedLayout* mutable_simple_collapsed_layout();
  inline ::sync_pb::SimpleCollapsedLayout* release_simple_collapsed_layout();
  inline void set_allocated_simple_collapsed_layout(::sync_pb::SimpleCollapsedLayout* simple_collapsed_layout);

  // optional uint64 creation_timestamp_usec = 2;
  inline bool has_creation_timestamp_usec() const;
  inline void clear_creation_timestamp_usec();
  static const int kCreationTimestampUsecFieldNumber = 2;
  inline ::google::protobuf::uint64 creation_timestamp_usec() const;
  inline void set_creation_timestamp_usec(::google::protobuf::uint64 value);

  // optional .sync_pb.SyncedNotificationDestination default_destination = 3;
  inline bool has_default_destination() const;
  inline void clear_default_destination();
  static const int kDefaultDestinationFieldNumber = 3;
  inline const ::sync_pb::SyncedNotificationDestination& default_destination() const;
  inline ::sync_pb::SyncedNotificationDestination* mutable_default_destination();
  inline ::sync_pb::SyncedNotificationDestination* release_default_destination();
  inline void set_allocated_default_destination(::sync_pb::SyncedNotificationDestination* default_destination);

  // repeated .sync_pb.Target target = 4;
  inline int target_size() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 4;
  inline const ::sync_pb::Target& target(int index) const;
  inline ::sync_pb::Target* mutable_target(int index);
  inline ::sync_pb::Target* add_target();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >&
      target() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >*
      mutable_target();

  // repeated string meta_tag = 5;
  inline int meta_tag_size() const;
  inline void clear_meta_tag();
  static const int kMetaTagFieldNumber = 5;
  inline const ::std::string& meta_tag(int index) const;
  inline ::std::string* mutable_meta_tag(int index);
  inline void set_meta_tag(int index, const ::std::string& value);
  inline void set_meta_tag(int index, const char* value);
  inline void set_meta_tag(int index, const char* value, size_t size);
  inline ::std::string* add_meta_tag();
  inline void add_meta_tag(const ::std::string& value);
  inline void add_meta_tag(const char* value);
  inline void add_meta_tag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& meta_tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_meta_tag();

  // @@protoc_insertion_point(class_scope:sync_pb.CollapsedInfo)
 private:
  inline void set_has_simple_collapsed_layout();
  inline void clear_has_simple_collapsed_layout();
  inline void set_has_creation_timestamp_usec();
  inline void clear_has_creation_timestamp_usec();
  inline void set_has_default_destination();
  inline void clear_has_default_destination();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::SimpleCollapsedLayout* simple_collapsed_layout_;
  ::google::protobuf::uint64 creation_timestamp_usec_;
  ::sync_pb::SyncedNotificationDestination* default_destination_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::Target > target_;
  ::google::protobuf::RepeatedPtrField< ::std::string> meta_tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static CollapsedInfo* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ExpandedInfo : public ::google::protobuf::MessageLite {
 public:
  ExpandedInfo();
  virtual ~ExpandedInfo();

  ExpandedInfo(const ExpandedInfo& from);

  inline ExpandedInfo& operator=(const ExpandedInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ExpandedInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExpandedInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExpandedInfo* other);

  // implements Message ----------------------------------------------

  ExpandedInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExpandedInfo& from);
  void MergeFrom(const ExpandedInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sync_pb.SimpleExpandedLayout simple_expanded_layout = 1;
  inline bool has_simple_expanded_layout() const;
  inline void clear_simple_expanded_layout();
  static const int kSimpleExpandedLayoutFieldNumber = 1;
  inline const ::sync_pb::SimpleExpandedLayout& simple_expanded_layout() const;
  inline ::sync_pb::SimpleExpandedLayout* mutable_simple_expanded_layout();
  inline ::sync_pb::SimpleExpandedLayout* release_simple_expanded_layout();
  inline void set_allocated_simple_expanded_layout(::sync_pb::SimpleExpandedLayout* simple_expanded_layout);

  // repeated .sync_pb.CollapsedInfo collapsed_info = 2;
  inline int collapsed_info_size() const;
  inline void clear_collapsed_info();
  static const int kCollapsedInfoFieldNumber = 2;
  inline const ::sync_pb::CollapsedInfo& collapsed_info(int index) const;
  inline ::sync_pb::CollapsedInfo* mutable_collapsed_info(int index);
  inline ::sync_pb::CollapsedInfo* add_collapsed_info();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::CollapsedInfo >&
      collapsed_info() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::CollapsedInfo >*
      mutable_collapsed_info();

  // repeated .sync_pb.Target target = 3;
  inline int target_size() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::sync_pb::Target& target(int index) const;
  inline ::sync_pb::Target* mutable_target(int index);
  inline ::sync_pb::Target* add_target();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >&
      target() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >*
      mutable_target();

  // repeated string meta_tag = 4;
  inline int meta_tag_size() const;
  inline void clear_meta_tag();
  static const int kMetaTagFieldNumber = 4;
  inline const ::std::string& meta_tag(int index) const;
  inline ::std::string* mutable_meta_tag(int index);
  inline void set_meta_tag(int index, const ::std::string& value);
  inline void set_meta_tag(int index, const char* value);
  inline void set_meta_tag(int index, const char* value, size_t size);
  inline ::std::string* add_meta_tag();
  inline void add_meta_tag(const ::std::string& value);
  inline void add_meta_tag(const char* value);
  inline void add_meta_tag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& meta_tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_meta_tag();

  // @@protoc_insertion_point(class_scope:sync_pb.ExpandedInfo)
 private:
  inline void set_has_simple_expanded_layout();
  inline void clear_has_simple_expanded_layout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::SimpleExpandedLayout* simple_expanded_layout_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::CollapsedInfo > collapsed_info_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::Target > target_;
  ::google::protobuf::RepeatedPtrField< ::std::string> meta_tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static ExpandedInfo* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SimpleCollapsedLayout : public ::google::protobuf::MessageLite {
 public:
  SimpleCollapsedLayout();
  virtual ~SimpleCollapsedLayout();

  SimpleCollapsedLayout(const SimpleCollapsedLayout& from);

  inline SimpleCollapsedLayout& operator=(const SimpleCollapsedLayout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SimpleCollapsedLayout& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SimpleCollapsedLayout* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SimpleCollapsedLayout* other);

  // implements Message ----------------------------------------------

  SimpleCollapsedLayout* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SimpleCollapsedLayout& from);
  void MergeFrom(const SimpleCollapsedLayout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sync_pb.SyncedNotificationImage app_icon = 1;
  inline bool has_app_icon() const;
  inline void clear_app_icon();
  static const int kAppIconFieldNumber = 1;
  inline const ::sync_pb::SyncedNotificationImage& app_icon() const;
  inline ::sync_pb::SyncedNotificationImage* mutable_app_icon();
  inline ::sync_pb::SyncedNotificationImage* release_app_icon();
  inline void set_allocated_app_icon(::sync_pb::SyncedNotificationImage* app_icon);

  // repeated .sync_pb.SyncedNotificationProfileImage profile_image = 2;
  inline int profile_image_size() const;
  inline void clear_profile_image();
  static const int kProfileImageFieldNumber = 2;
  inline const ::sync_pb::SyncedNotificationProfileImage& profile_image(int index) const;
  inline ::sync_pb::SyncedNotificationProfileImage* mutable_profile_image(int index);
  inline ::sync_pb::SyncedNotificationProfileImage* add_profile_image();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncedNotificationProfileImage >&
      profile_image() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncedNotificationProfileImage >*
      mutable_profile_image();

  // optional string heading = 3;
  inline bool has_heading() const;
  inline void clear_heading();
  static const int kHeadingFieldNumber = 3;
  inline const ::std::string& heading() const;
  inline void set_heading(const ::std::string& value);
  inline void set_heading(const char* value);
  inline void set_heading(const char* value, size_t size);
  inline ::std::string* mutable_heading();
  inline ::std::string* release_heading();
  inline void set_allocated_heading(::std::string* heading);

  // optional string description = 4;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 4;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // repeated .sync_pb.Media media = 5;
  inline int media_size() const;
  inline void clear_media();
  static const int kMediaFieldNumber = 5;
  inline const ::sync_pb::Media& media(int index) const;
  inline ::sync_pb::Media* mutable_media(int index);
  inline ::sync_pb::Media* add_media();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Media >&
      media() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Media >*
      mutable_media();

  // optional string annotation = 6;
  inline bool has_annotation() const;
  inline void clear_annotation();
  static const int kAnnotationFieldNumber = 6;
  inline const ::std::string& annotation() const;
  inline void set_annotation(const ::std::string& value);
  inline void set_annotation(const char* value);
  inline void set_annotation(const char* value, size_t size);
  inline ::std::string* mutable_annotation();
  inline ::std::string* release_annotation();
  inline void set_allocated_annotation(::std::string* annotation);

  // @@protoc_insertion_point(class_scope:sync_pb.SimpleCollapsedLayout)
 private:
  inline void set_has_app_icon();
  inline void clear_has_app_icon();
  inline void set_has_heading();
  inline void clear_has_heading();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_annotation();
  inline void clear_has_annotation();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::SyncedNotificationImage* app_icon_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncedNotificationProfileImage > profile_image_;
  ::std::string* heading_;
  ::std::string* description_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::Media > media_;
  ::std::string* annotation_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static SimpleCollapsedLayout* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SimpleExpandedLayout : public ::google::protobuf::MessageLite {
 public:
  SimpleExpandedLayout();
  virtual ~SimpleExpandedLayout();

  SimpleExpandedLayout(const SimpleExpandedLayout& from);

  inline SimpleExpandedLayout& operator=(const SimpleExpandedLayout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SimpleExpandedLayout& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SimpleExpandedLayout* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SimpleExpandedLayout* other);

  // implements Message ----------------------------------------------

  SimpleExpandedLayout* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SimpleExpandedLayout& from);
  void MergeFrom(const SimpleExpandedLayout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // repeated .sync_pb.Media media = 3;
  inline int media_size() const;
  inline void clear_media();
  static const int kMediaFieldNumber = 3;
  inline const ::sync_pb::Media& media(int index) const;
  inline ::sync_pb::Media* mutable_media(int index);
  inline ::sync_pb::Media* add_media();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Media >&
      media() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Media >*
      mutable_media();

  // optional .sync_pb.SyncedNotificationProfileImage profile_image = 4;
  inline bool has_profile_image() const;
  inline void clear_profile_image();
  static const int kProfileImageFieldNumber = 4;
  inline const ::sync_pb::SyncedNotificationProfileImage& profile_image() const;
  inline ::sync_pb::SyncedNotificationProfileImage* mutable_profile_image();
  inline ::sync_pb::SyncedNotificationProfileImage* release_profile_image();
  inline void set_allocated_profile_image(::sync_pb::SyncedNotificationProfileImage* profile_image);

  // repeated .sync_pb.Target target = 5;
  inline int target_size() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 5;
  inline const ::sync_pb::Target& target(int index) const;
  inline ::sync_pb::Target* mutable_target(int index);
  inline ::sync_pb::Target* add_target();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >&
      target() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >*
      mutable_target();

  // @@protoc_insertion_point(class_scope:sync_pb.SimpleExpandedLayout)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_profile_image();
  inline void clear_has_profile_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* title_;
  ::std::string* text_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::Media > media_;
  ::sync_pb::SyncedNotificationProfileImage* profile_image_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::Target > target_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static SimpleExpandedLayout* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT Media : public ::google::protobuf::MessageLite {
 public:
  Media();
  virtual ~Media();

  Media(const Media& from);

  inline Media& operator=(const Media& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Media& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Media* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Media* other);

  // implements Message ----------------------------------------------

  Media* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Media& from);
  void MergeFrom(const Media& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sync_pb.SyncedNotificationImage image = 1;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 1;
  inline const ::sync_pb::SyncedNotificationImage& image() const;
  inline ::sync_pb::SyncedNotificationImage* mutable_image();
  inline ::sync_pb::SyncedNotificationImage* release_image();
  inline void set_allocated_image(::sync_pb::SyncedNotificationImage* image);

  // @@protoc_insertion_point(class_scope:sync_pb.Media)
 private:
  inline void set_has_image();
  inline void clear_has_image();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::SyncedNotificationImage* image_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static Media* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT Target : public ::google::protobuf::MessageLite {
 public:
  Target();
  virtual ~Target();

  Target(const Target& from);

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Target& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Target* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Target* other);

  // implements Message ----------------------------------------------

  Target* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Target& from);
  void MergeFrom(const Target& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sync_pb.SyncedNotificationDestination destination = 1;
  inline bool has_destination() const;
  inline void clear_destination();
  static const int kDestinationFieldNumber = 1;
  inline const ::sync_pb::SyncedNotificationDestination& destination() const;
  inline ::sync_pb::SyncedNotificationDestination* mutable_destination();
  inline ::sync_pb::SyncedNotificationDestination* release_destination();
  inline void set_allocated_destination(::sync_pb::SyncedNotificationDestination* destination);

  // optional .sync_pb.SyncedNotificationAction action = 2;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 2;
  inline const ::sync_pb::SyncedNotificationAction& action() const;
  inline ::sync_pb::SyncedNotificationAction* mutable_action();
  inline ::sync_pb::SyncedNotificationAction* release_action();
  inline void set_allocated_action(::sync_pb::SyncedNotificationAction* action);

  // optional string target_key = 3;
  inline bool has_target_key() const;
  inline void clear_target_key();
  static const int kTargetKeyFieldNumber = 3;
  inline const ::std::string& target_key() const;
  inline void set_target_key(const ::std::string& value);
  inline void set_target_key(const char* value);
  inline void set_target_key(const char* value, size_t size);
  inline ::std::string* mutable_target_key();
  inline ::std::string* release_target_key();
  inline void set_allocated_target_key(::std::string* target_key);

  // @@protoc_insertion_point(class_scope:sync_pb.Target)
 private:
  inline void set_has_destination();
  inline void clear_has_destination();
  inline void set_has_action();
  inline void clear_has_action();
  inline void set_has_target_key();
  inline void clear_has_target_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::SyncedNotificationDestination* destination_;
  ::sync_pb::SyncedNotificationAction* action_;
  ::std::string* target_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static Target* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SyncedNotificationDestination : public ::google::protobuf::MessageLite {
 public:
  SyncedNotificationDestination();
  virtual ~SyncedNotificationDestination();

  SyncedNotificationDestination(const SyncedNotificationDestination& from);

  inline SyncedNotificationDestination& operator=(const SyncedNotificationDestination& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncedNotificationDestination& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncedNotificationDestination* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncedNotificationDestination* other);

  // implements Message ----------------------------------------------

  SyncedNotificationDestination* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncedNotificationDestination& from);
  void MergeFrom(const SyncedNotificationDestination& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .sync_pb.SyncedNotificationImage icon = 2;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 2;
  inline const ::sync_pb::SyncedNotificationImage& icon() const;
  inline ::sync_pb::SyncedNotificationImage* mutable_icon();
  inline ::sync_pb::SyncedNotificationImage* release_icon();
  inline void set_allocated_icon(::sync_pb::SyncedNotificationImage* icon);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string accessibility_label = 4;
  inline bool has_accessibility_label() const;
  inline void clear_accessibility_label();
  static const int kAccessibilityLabelFieldNumber = 4;
  inline const ::std::string& accessibility_label() const;
  inline void set_accessibility_label(const ::std::string& value);
  inline void set_accessibility_label(const char* value);
  inline void set_accessibility_label(const char* value, size_t size);
  inline ::std::string* mutable_accessibility_label();
  inline ::std::string* release_accessibility_label();
  inline void set_allocated_accessibility_label(::std::string* accessibility_label);

  // @@protoc_insertion_point(class_scope:sync_pb.SyncedNotificationDestination)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_accessibility_label();
  inline void clear_has_accessibility_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::sync_pb::SyncedNotificationImage* icon_;
  ::std::string* url_;
  ::std::string* accessibility_label_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static SyncedNotificationDestination* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SyncedNotificationAction : public ::google::protobuf::MessageLite {
 public:
  SyncedNotificationAction();
  virtual ~SyncedNotificationAction();

  SyncedNotificationAction(const SyncedNotificationAction& from);

  inline SyncedNotificationAction& operator=(const SyncedNotificationAction& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncedNotificationAction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncedNotificationAction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncedNotificationAction* other);

  // implements Message ----------------------------------------------

  SyncedNotificationAction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncedNotificationAction& from);
  void MergeFrom(const SyncedNotificationAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .sync_pb.SyncedNotificationImage icon = 2;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 2;
  inline const ::sync_pb::SyncedNotificationImage& icon() const;
  inline ::sync_pb::SyncedNotificationImage* mutable_icon();
  inline ::sync_pb::SyncedNotificationImage* release_icon();
  inline void set_allocated_icon(::sync_pb::SyncedNotificationImage* icon);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string request_data = 4;
  inline bool has_request_data() const;
  inline void clear_request_data();
  static const int kRequestDataFieldNumber = 4;
  inline const ::std::string& request_data() const;
  inline void set_request_data(const ::std::string& value);
  inline void set_request_data(const char* value);
  inline void set_request_data(const char* value, size_t size);
  inline ::std::string* mutable_request_data();
  inline ::std::string* release_request_data();
  inline void set_allocated_request_data(::std::string* request_data);

  // optional string accessibility_label = 5;
  inline bool has_accessibility_label() const;
  inline void clear_accessibility_label();
  static const int kAccessibilityLabelFieldNumber = 5;
  inline const ::std::string& accessibility_label() const;
  inline void set_accessibility_label(const ::std::string& value);
  inline void set_accessibility_label(const char* value);
  inline void set_accessibility_label(const char* value, size_t size);
  inline ::std::string* mutable_accessibility_label();
  inline ::std::string* release_accessibility_label();
  inline void set_allocated_accessibility_label(::std::string* accessibility_label);

  // repeated string meta_tag = 6;
  inline int meta_tag_size() const;
  inline void clear_meta_tag();
  static const int kMetaTagFieldNumber = 6;
  inline const ::std::string& meta_tag(int index) const;
  inline ::std::string* mutable_meta_tag(int index);
  inline void set_meta_tag(int index, const ::std::string& value);
  inline void set_meta_tag(int index, const char* value);
  inline void set_meta_tag(int index, const char* value, size_t size);
  inline ::std::string* add_meta_tag();
  inline void add_meta_tag(const ::std::string& value);
  inline void add_meta_tag(const char* value);
  inline void add_meta_tag(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& meta_tag() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_meta_tag();

  // @@protoc_insertion_point(class_scope:sync_pb.SyncedNotificationAction)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_request_data();
  inline void clear_has_request_data();
  inline void set_has_accessibility_label();
  inline void clear_has_accessibility_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::sync_pb::SyncedNotificationImage* icon_;
  ::std::string* url_;
  ::std::string* request_data_;
  ::std::string* accessibility_label_;
  ::google::protobuf::RepeatedPtrField< ::std::string> meta_tag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static SyncedNotificationAction* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SyncedNotificationImage : public ::google::protobuf::MessageLite {
 public:
  SyncedNotificationImage();
  virtual ~SyncedNotificationImage();

  SyncedNotificationImage(const SyncedNotificationImage& from);

  inline SyncedNotificationImage& operator=(const SyncedNotificationImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncedNotificationImage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncedNotificationImage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncedNotificationImage* other);

  // implements Message ----------------------------------------------

  SyncedNotificationImage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncedNotificationImage& from);
  void MergeFrom(const SyncedNotificationImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string alt_text = 2;
  inline bool has_alt_text() const;
  inline void clear_alt_text();
  static const int kAltTextFieldNumber = 2;
  inline const ::std::string& alt_text() const;
  inline void set_alt_text(const ::std::string& value);
  inline void set_alt_text(const char* value);
  inline void set_alt_text(const char* value, size_t size);
  inline ::std::string* mutable_alt_text();
  inline ::std::string* release_alt_text();
  inline void set_allocated_alt_text(::std::string* alt_text);

  // optional int32 preferred_width = 3;
  inline bool has_preferred_width() const;
  inline void clear_preferred_width();
  static const int kPreferredWidthFieldNumber = 3;
  inline ::google::protobuf::int32 preferred_width() const;
  inline void set_preferred_width(::google::protobuf::int32 value);

  // optional int32 preferred_height = 4;
  inline bool has_preferred_height() const;
  inline void clear_preferred_height();
  static const int kPreferredHeightFieldNumber = 4;
  inline ::google::protobuf::int32 preferred_height() const;
  inline void set_preferred_height(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sync_pb.SyncedNotificationImage)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_alt_text();
  inline void clear_has_alt_text();
  inline void set_has_preferred_width();
  inline void clear_has_preferred_width();
  inline void set_has_preferred_height();
  inline void clear_has_preferred_height();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;
  ::std::string* alt_text_;
  ::google::protobuf::int32 preferred_width_;
  ::google::protobuf::int32 preferred_height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static SyncedNotificationImage* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SyncedNotificationProfileImage : public ::google::protobuf::MessageLite {
 public:
  SyncedNotificationProfileImage();
  virtual ~SyncedNotificationProfileImage();

  SyncedNotificationProfileImage(const SyncedNotificationProfileImage& from);

  inline SyncedNotificationProfileImage& operator=(const SyncedNotificationProfileImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncedNotificationProfileImage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncedNotificationProfileImage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncedNotificationProfileImage* other);

  // implements Message ----------------------------------------------

  SyncedNotificationProfileImage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncedNotificationProfileImage& from);
  void MergeFrom(const SyncedNotificationProfileImage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string image_url = 1;
  inline bool has_image_url() const;
  inline void clear_image_url();
  static const int kImageUrlFieldNumber = 1;
  inline const ::std::string& image_url() const;
  inline void set_image_url(const ::std::string& value);
  inline void set_image_url(const char* value);
  inline void set_image_url(const char* value, size_t size);
  inline ::std::string* mutable_image_url();
  inline ::std::string* release_image_url();
  inline void set_allocated_image_url(::std::string* image_url);

  // optional string oid = 2;
  inline bool has_oid() const;
  inline void clear_oid();
  static const int kOidFieldNumber = 2;
  inline const ::std::string& oid() const;
  inline void set_oid(const ::std::string& value);
  inline void set_oid(const char* value);
  inline void set_oid(const char* value, size_t size);
  inline ::std::string* mutable_oid();
  inline ::std::string* release_oid();
  inline void set_allocated_oid(::std::string* oid);

  // optional string display_name = 3;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 3;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  inline void set_allocated_display_name(::std::string* display_name);

  // @@protoc_insertion_point(class_scope:sync_pb.SyncedNotificationProfileImage)
 private:
  inline void set_has_image_url();
  inline void clear_has_image_url();
  inline void set_has_oid();
  inline void clear_has_oid();
  inline void set_has_display_name();
  inline void clear_has_display_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* image_url_;
  ::std::string* oid_;
  ::std::string* display_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5frender_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5frender_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5frender_2eproto();

  void InitAsDefaultInstance();
  static SyncedNotificationProfileImage* default_instance_;
};
// ===================================================================


// ===================================================================

// SyncedNotificationRenderInfo

// optional .sync_pb.CollapsedInfo collapsed_info = 1;
inline bool SyncedNotificationRenderInfo::has_collapsed_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncedNotificationRenderInfo::set_has_collapsed_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncedNotificationRenderInfo::clear_has_collapsed_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncedNotificationRenderInfo::clear_collapsed_info() {
  if (collapsed_info_ != NULL) collapsed_info_->::sync_pb::CollapsedInfo::Clear();
  clear_has_collapsed_info();
}
inline const ::sync_pb::CollapsedInfo& SyncedNotificationRenderInfo::collapsed_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return collapsed_info_ != NULL ? *collapsed_info_ : *default_instance().collapsed_info_;
#else
  return collapsed_info_ != NULL ? *collapsed_info_ : *default_instance_->collapsed_info_;
#endif
}
inline ::sync_pb::CollapsedInfo* SyncedNotificationRenderInfo::mutable_collapsed_info() {
  set_has_collapsed_info();
  if (collapsed_info_ == NULL) collapsed_info_ = new ::sync_pb::CollapsedInfo;
  return collapsed_info_;
}
inline ::sync_pb::CollapsedInfo* SyncedNotificationRenderInfo::release_collapsed_info() {
  clear_has_collapsed_info();
  ::sync_pb::CollapsedInfo* temp = collapsed_info_;
  collapsed_info_ = NULL;
  return temp;
}
inline void SyncedNotificationRenderInfo::set_allocated_collapsed_info(::sync_pb::CollapsedInfo* collapsed_info) {
  delete collapsed_info_;
  collapsed_info_ = collapsed_info;
  if (collapsed_info) {
    set_has_collapsed_info();
  } else {
    clear_has_collapsed_info();
  }
}

// optional .sync_pb.ExpandedInfo expanded_info = 2;
inline bool SyncedNotificationRenderInfo::has_expanded_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncedNotificationRenderInfo::set_has_expanded_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncedNotificationRenderInfo::clear_has_expanded_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncedNotificationRenderInfo::clear_expanded_info() {
  if (expanded_info_ != NULL) expanded_info_->::sync_pb::ExpandedInfo::Clear();
  clear_has_expanded_info();
}
inline const ::sync_pb::ExpandedInfo& SyncedNotificationRenderInfo::expanded_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return expanded_info_ != NULL ? *expanded_info_ : *default_instance().expanded_info_;
#else
  return expanded_info_ != NULL ? *expanded_info_ : *default_instance_->expanded_info_;
#endif
}
inline ::sync_pb::ExpandedInfo* SyncedNotificationRenderInfo::mutable_expanded_info() {
  set_has_expanded_info();
  if (expanded_info_ == NULL) expanded_info_ = new ::sync_pb::ExpandedInfo;
  return expanded_info_;
}
inline ::sync_pb::ExpandedInfo* SyncedNotificationRenderInfo::release_expanded_info() {
  clear_has_expanded_info();
  ::sync_pb::ExpandedInfo* temp = expanded_info_;
  expanded_info_ = NULL;
  return temp;
}
inline void SyncedNotificationRenderInfo::set_allocated_expanded_info(::sync_pb::ExpandedInfo* expanded_info) {
  delete expanded_info_;
  expanded_info_ = expanded_info;
  if (expanded_info) {
    set_has_expanded_info();
  } else {
    clear_has_expanded_info();
  }
}

// -------------------------------------------------------------------

// CollapsedInfo

// optional .sync_pb.SimpleCollapsedLayout simple_collapsed_layout = 1;
inline bool CollapsedInfo::has_simple_collapsed_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollapsedInfo::set_has_simple_collapsed_layout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollapsedInfo::clear_has_simple_collapsed_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollapsedInfo::clear_simple_collapsed_layout() {
  if (simple_collapsed_layout_ != NULL) simple_collapsed_layout_->::sync_pb::SimpleCollapsedLayout::Clear();
  clear_has_simple_collapsed_layout();
}
inline const ::sync_pb::SimpleCollapsedLayout& CollapsedInfo::simple_collapsed_layout() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return simple_collapsed_layout_ != NULL ? *simple_collapsed_layout_ : *default_instance().simple_collapsed_layout_;
#else
  return simple_collapsed_layout_ != NULL ? *simple_collapsed_layout_ : *default_instance_->simple_collapsed_layout_;
#endif
}
inline ::sync_pb::SimpleCollapsedLayout* CollapsedInfo::mutable_simple_collapsed_layout() {
  set_has_simple_collapsed_layout();
  if (simple_collapsed_layout_ == NULL) simple_collapsed_layout_ = new ::sync_pb::SimpleCollapsedLayout;
  return simple_collapsed_layout_;
}
inline ::sync_pb::SimpleCollapsedLayout* CollapsedInfo::release_simple_collapsed_layout() {
  clear_has_simple_collapsed_layout();
  ::sync_pb::SimpleCollapsedLayout* temp = simple_collapsed_layout_;
  simple_collapsed_layout_ = NULL;
  return temp;
}
inline void CollapsedInfo::set_allocated_simple_collapsed_layout(::sync_pb::SimpleCollapsedLayout* simple_collapsed_layout) {
  delete simple_collapsed_layout_;
  simple_collapsed_layout_ = simple_collapsed_layout;
  if (simple_collapsed_layout) {
    set_has_simple_collapsed_layout();
  } else {
    clear_has_simple_collapsed_layout();
  }
}

// optional uint64 creation_timestamp_usec = 2;
inline bool CollapsedInfo::has_creation_timestamp_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollapsedInfo::set_has_creation_timestamp_usec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollapsedInfo::clear_has_creation_timestamp_usec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollapsedInfo::clear_creation_timestamp_usec() {
  creation_timestamp_usec_ = GOOGLE_ULONGLONG(0);
  clear_has_creation_timestamp_usec();
}
inline ::google::protobuf::uint64 CollapsedInfo::creation_timestamp_usec() const {
  return creation_timestamp_usec_;
}
inline void CollapsedInfo::set_creation_timestamp_usec(::google::protobuf::uint64 value) {
  set_has_creation_timestamp_usec();
  creation_timestamp_usec_ = value;
}

// optional .sync_pb.SyncedNotificationDestination default_destination = 3;
inline bool CollapsedInfo::has_default_destination() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollapsedInfo::set_has_default_destination() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollapsedInfo::clear_has_default_destination() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollapsedInfo::clear_default_destination() {
  if (default_destination_ != NULL) default_destination_->::sync_pb::SyncedNotificationDestination::Clear();
  clear_has_default_destination();
}
inline const ::sync_pb::SyncedNotificationDestination& CollapsedInfo::default_destination() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return default_destination_ != NULL ? *default_destination_ : *default_instance().default_destination_;
#else
  return default_destination_ != NULL ? *default_destination_ : *default_instance_->default_destination_;
#endif
}
inline ::sync_pb::SyncedNotificationDestination* CollapsedInfo::mutable_default_destination() {
  set_has_default_destination();
  if (default_destination_ == NULL) default_destination_ = new ::sync_pb::SyncedNotificationDestination;
  return default_destination_;
}
inline ::sync_pb::SyncedNotificationDestination* CollapsedInfo::release_default_destination() {
  clear_has_default_destination();
  ::sync_pb::SyncedNotificationDestination* temp = default_destination_;
  default_destination_ = NULL;
  return temp;
}
inline void CollapsedInfo::set_allocated_default_destination(::sync_pb::SyncedNotificationDestination* default_destination) {
  delete default_destination_;
  default_destination_ = default_destination;
  if (default_destination) {
    set_has_default_destination();
  } else {
    clear_has_default_destination();
  }
}

// repeated .sync_pb.Target target = 4;
inline int CollapsedInfo::target_size() const {
  return target_.size();
}
inline void CollapsedInfo::clear_target() {
  target_.Clear();
}
inline const ::sync_pb::Target& CollapsedInfo::target(int index) const {
  return target_.Get(index);
}
inline ::sync_pb::Target* CollapsedInfo::mutable_target(int index) {
  return target_.Mutable(index);
}
inline ::sync_pb::Target* CollapsedInfo::add_target() {
  return target_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >&
CollapsedInfo::target() const {
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >*
CollapsedInfo::mutable_target() {
  return &target_;
}

// repeated string meta_tag = 5;
inline int CollapsedInfo::meta_tag_size() const {
  return meta_tag_.size();
}
inline void CollapsedInfo::clear_meta_tag() {
  meta_tag_.Clear();
}
inline const ::std::string& CollapsedInfo::meta_tag(int index) const {
  return meta_tag_.Get(index);
}
inline ::std::string* CollapsedInfo::mutable_meta_tag(int index) {
  return meta_tag_.Mutable(index);
}
inline void CollapsedInfo::set_meta_tag(int index, const ::std::string& value) {
  meta_tag_.Mutable(index)->assign(value);
}
inline void CollapsedInfo::set_meta_tag(int index, const char* value) {
  meta_tag_.Mutable(index)->assign(value);
}
inline void CollapsedInfo::set_meta_tag(int index, const char* value, size_t size) {
  meta_tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CollapsedInfo::add_meta_tag() {
  return meta_tag_.Add();
}
inline void CollapsedInfo::add_meta_tag(const ::std::string& value) {
  meta_tag_.Add()->assign(value);
}
inline void CollapsedInfo::add_meta_tag(const char* value) {
  meta_tag_.Add()->assign(value);
}
inline void CollapsedInfo::add_meta_tag(const char* value, size_t size) {
  meta_tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CollapsedInfo::meta_tag() const {
  return meta_tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CollapsedInfo::mutable_meta_tag() {
  return &meta_tag_;
}

// -------------------------------------------------------------------

// ExpandedInfo

// optional .sync_pb.SimpleExpandedLayout simple_expanded_layout = 1;
inline bool ExpandedInfo::has_simple_expanded_layout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExpandedInfo::set_has_simple_expanded_layout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExpandedInfo::clear_has_simple_expanded_layout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExpandedInfo::clear_simple_expanded_layout() {
  if (simple_expanded_layout_ != NULL) simple_expanded_layout_->::sync_pb::SimpleExpandedLayout::Clear();
  clear_has_simple_expanded_layout();
}
inline const ::sync_pb::SimpleExpandedLayout& ExpandedInfo::simple_expanded_layout() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return simple_expanded_layout_ != NULL ? *simple_expanded_layout_ : *default_instance().simple_expanded_layout_;
#else
  return simple_expanded_layout_ != NULL ? *simple_expanded_layout_ : *default_instance_->simple_expanded_layout_;
#endif
}
inline ::sync_pb::SimpleExpandedLayout* ExpandedInfo::mutable_simple_expanded_layout() {
  set_has_simple_expanded_layout();
  if (simple_expanded_layout_ == NULL) simple_expanded_layout_ = new ::sync_pb::SimpleExpandedLayout;
  return simple_expanded_layout_;
}
inline ::sync_pb::SimpleExpandedLayout* ExpandedInfo::release_simple_expanded_layout() {
  clear_has_simple_expanded_layout();
  ::sync_pb::SimpleExpandedLayout* temp = simple_expanded_layout_;
  simple_expanded_layout_ = NULL;
  return temp;
}
inline void ExpandedInfo::set_allocated_simple_expanded_layout(::sync_pb::SimpleExpandedLayout* simple_expanded_layout) {
  delete simple_expanded_layout_;
  simple_expanded_layout_ = simple_expanded_layout;
  if (simple_expanded_layout) {
    set_has_simple_expanded_layout();
  } else {
    clear_has_simple_expanded_layout();
  }
}

// repeated .sync_pb.CollapsedInfo collapsed_info = 2;
inline int ExpandedInfo::collapsed_info_size() const {
  return collapsed_info_.size();
}
inline void ExpandedInfo::clear_collapsed_info() {
  collapsed_info_.Clear();
}
inline const ::sync_pb::CollapsedInfo& ExpandedInfo::collapsed_info(int index) const {
  return collapsed_info_.Get(index);
}
inline ::sync_pb::CollapsedInfo* ExpandedInfo::mutable_collapsed_info(int index) {
  return collapsed_info_.Mutable(index);
}
inline ::sync_pb::CollapsedInfo* ExpandedInfo::add_collapsed_info() {
  return collapsed_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::CollapsedInfo >&
ExpandedInfo::collapsed_info() const {
  return collapsed_info_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::CollapsedInfo >*
ExpandedInfo::mutable_collapsed_info() {
  return &collapsed_info_;
}

// repeated .sync_pb.Target target = 3;
inline int ExpandedInfo::target_size() const {
  return target_.size();
}
inline void ExpandedInfo::clear_target() {
  target_.Clear();
}
inline const ::sync_pb::Target& ExpandedInfo::target(int index) const {
  return target_.Get(index);
}
inline ::sync_pb::Target* ExpandedInfo::mutable_target(int index) {
  return target_.Mutable(index);
}
inline ::sync_pb::Target* ExpandedInfo::add_target() {
  return target_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >&
ExpandedInfo::target() const {
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >*
ExpandedInfo::mutable_target() {
  return &target_;
}

// repeated string meta_tag = 4;
inline int ExpandedInfo::meta_tag_size() const {
  return meta_tag_.size();
}
inline void ExpandedInfo::clear_meta_tag() {
  meta_tag_.Clear();
}
inline const ::std::string& ExpandedInfo::meta_tag(int index) const {
  return meta_tag_.Get(index);
}
inline ::std::string* ExpandedInfo::mutable_meta_tag(int index) {
  return meta_tag_.Mutable(index);
}
inline void ExpandedInfo::set_meta_tag(int index, const ::std::string& value) {
  meta_tag_.Mutable(index)->assign(value);
}
inline void ExpandedInfo::set_meta_tag(int index, const char* value) {
  meta_tag_.Mutable(index)->assign(value);
}
inline void ExpandedInfo::set_meta_tag(int index, const char* value, size_t size) {
  meta_tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpandedInfo::add_meta_tag() {
  return meta_tag_.Add();
}
inline void ExpandedInfo::add_meta_tag(const ::std::string& value) {
  meta_tag_.Add()->assign(value);
}
inline void ExpandedInfo::add_meta_tag(const char* value) {
  meta_tag_.Add()->assign(value);
}
inline void ExpandedInfo::add_meta_tag(const char* value, size_t size) {
  meta_tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ExpandedInfo::meta_tag() const {
  return meta_tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ExpandedInfo::mutable_meta_tag() {
  return &meta_tag_;
}

// -------------------------------------------------------------------

// SimpleCollapsedLayout

// optional .sync_pb.SyncedNotificationImage app_icon = 1;
inline bool SimpleCollapsedLayout::has_app_icon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleCollapsedLayout::set_has_app_icon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleCollapsedLayout::clear_has_app_icon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleCollapsedLayout::clear_app_icon() {
  if (app_icon_ != NULL) app_icon_->::sync_pb::SyncedNotificationImage::Clear();
  clear_has_app_icon();
}
inline const ::sync_pb::SyncedNotificationImage& SimpleCollapsedLayout::app_icon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return app_icon_ != NULL ? *app_icon_ : *default_instance().app_icon_;
#else
  return app_icon_ != NULL ? *app_icon_ : *default_instance_->app_icon_;
#endif
}
inline ::sync_pb::SyncedNotificationImage* SimpleCollapsedLayout::mutable_app_icon() {
  set_has_app_icon();
  if (app_icon_ == NULL) app_icon_ = new ::sync_pb::SyncedNotificationImage;
  return app_icon_;
}
inline ::sync_pb::SyncedNotificationImage* SimpleCollapsedLayout::release_app_icon() {
  clear_has_app_icon();
  ::sync_pb::SyncedNotificationImage* temp = app_icon_;
  app_icon_ = NULL;
  return temp;
}
inline void SimpleCollapsedLayout::set_allocated_app_icon(::sync_pb::SyncedNotificationImage* app_icon) {
  delete app_icon_;
  app_icon_ = app_icon;
  if (app_icon) {
    set_has_app_icon();
  } else {
    clear_has_app_icon();
  }
}

// repeated .sync_pb.SyncedNotificationProfileImage profile_image = 2;
inline int SimpleCollapsedLayout::profile_image_size() const {
  return profile_image_.size();
}
inline void SimpleCollapsedLayout::clear_profile_image() {
  profile_image_.Clear();
}
inline const ::sync_pb::SyncedNotificationProfileImage& SimpleCollapsedLayout::profile_image(int index) const {
  return profile_image_.Get(index);
}
inline ::sync_pb::SyncedNotificationProfileImage* SimpleCollapsedLayout::mutable_profile_image(int index) {
  return profile_image_.Mutable(index);
}
inline ::sync_pb::SyncedNotificationProfileImage* SimpleCollapsedLayout::add_profile_image() {
  return profile_image_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncedNotificationProfileImage >&
SimpleCollapsedLayout::profile_image() const {
  return profile_image_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncedNotificationProfileImage >*
SimpleCollapsedLayout::mutable_profile_image() {
  return &profile_image_;
}

// optional string heading = 3;
inline bool SimpleCollapsedLayout::has_heading() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SimpleCollapsedLayout::set_has_heading() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SimpleCollapsedLayout::clear_has_heading() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SimpleCollapsedLayout::clear_heading() {
  if (heading_ != &::google::protobuf::internal::GetEmptyString()) {
    heading_->clear();
  }
  clear_has_heading();
}
inline const ::std::string& SimpleCollapsedLayout::heading() const {
  return *heading_;
}
inline void SimpleCollapsedLayout::set_heading(const ::std::string& value) {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::GetEmptyString()) {
    heading_ = new ::std::string;
  }
  heading_->assign(value);
}
inline void SimpleCollapsedLayout::set_heading(const char* value) {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::GetEmptyString()) {
    heading_ = new ::std::string;
  }
  heading_->assign(value);
}
inline void SimpleCollapsedLayout::set_heading(const char* value, size_t size) {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::GetEmptyString()) {
    heading_ = new ::std::string;
  }
  heading_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SimpleCollapsedLayout::mutable_heading() {
  set_has_heading();
  if (heading_ == &::google::protobuf::internal::GetEmptyString()) {
    heading_ = new ::std::string;
  }
  return heading_;
}
inline ::std::string* SimpleCollapsedLayout::release_heading() {
  clear_has_heading();
  if (heading_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = heading_;
    heading_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SimpleCollapsedLayout::set_allocated_heading(::std::string* heading) {
  if (heading_ != &::google::protobuf::internal::GetEmptyString()) {
    delete heading_;
  }
  if (heading) {
    set_has_heading();
    heading_ = heading;
  } else {
    clear_has_heading();
    heading_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string description = 4;
inline bool SimpleCollapsedLayout::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SimpleCollapsedLayout::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SimpleCollapsedLayout::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SimpleCollapsedLayout::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyString()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& SimpleCollapsedLayout::description() const {
  return *description_;
}
inline void SimpleCollapsedLayout::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyString()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SimpleCollapsedLayout::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyString()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void SimpleCollapsedLayout::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyString()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SimpleCollapsedLayout::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyString()) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* SimpleCollapsedLayout::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SimpleCollapsedLayout::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyString()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .sync_pb.Media media = 5;
inline int SimpleCollapsedLayout::media_size() const {
  return media_.size();
}
inline void SimpleCollapsedLayout::clear_media() {
  media_.Clear();
}
inline const ::sync_pb::Media& SimpleCollapsedLayout::media(int index) const {
  return media_.Get(index);
}
inline ::sync_pb::Media* SimpleCollapsedLayout::mutable_media(int index) {
  return media_.Mutable(index);
}
inline ::sync_pb::Media* SimpleCollapsedLayout::add_media() {
  return media_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Media >&
SimpleCollapsedLayout::media() const {
  return media_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Media >*
SimpleCollapsedLayout::mutable_media() {
  return &media_;
}

// optional string annotation = 6;
inline bool SimpleCollapsedLayout::has_annotation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SimpleCollapsedLayout::set_has_annotation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SimpleCollapsedLayout::clear_has_annotation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SimpleCollapsedLayout::clear_annotation() {
  if (annotation_ != &::google::protobuf::internal::GetEmptyString()) {
    annotation_->clear();
  }
  clear_has_annotation();
}
inline const ::std::string& SimpleCollapsedLayout::annotation() const {
  return *annotation_;
}
inline void SimpleCollapsedLayout::set_annotation(const ::std::string& value) {
  set_has_annotation();
  if (annotation_ == &::google::protobuf::internal::GetEmptyString()) {
    annotation_ = new ::std::string;
  }
  annotation_->assign(value);
}
inline void SimpleCollapsedLayout::set_annotation(const char* value) {
  set_has_annotation();
  if (annotation_ == &::google::protobuf::internal::GetEmptyString()) {
    annotation_ = new ::std::string;
  }
  annotation_->assign(value);
}
inline void SimpleCollapsedLayout::set_annotation(const char* value, size_t size) {
  set_has_annotation();
  if (annotation_ == &::google::protobuf::internal::GetEmptyString()) {
    annotation_ = new ::std::string;
  }
  annotation_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SimpleCollapsedLayout::mutable_annotation() {
  set_has_annotation();
  if (annotation_ == &::google::protobuf::internal::GetEmptyString()) {
    annotation_ = new ::std::string;
  }
  return annotation_;
}
inline ::std::string* SimpleCollapsedLayout::release_annotation() {
  clear_has_annotation();
  if (annotation_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = annotation_;
    annotation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SimpleCollapsedLayout::set_allocated_annotation(::std::string* annotation) {
  if (annotation_ != &::google::protobuf::internal::GetEmptyString()) {
    delete annotation_;
  }
  if (annotation) {
    set_has_annotation();
    annotation_ = annotation;
  } else {
    clear_has_annotation();
    annotation_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// SimpleExpandedLayout

// optional string title = 1;
inline bool SimpleExpandedLayout::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SimpleExpandedLayout::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SimpleExpandedLayout::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SimpleExpandedLayout::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyString()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& SimpleExpandedLayout::title() const {
  return *title_;
}
inline void SimpleExpandedLayout::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void SimpleExpandedLayout::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void SimpleExpandedLayout::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SimpleExpandedLayout::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* SimpleExpandedLayout::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SimpleExpandedLayout::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyString()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string text = 2;
inline bool SimpleExpandedLayout::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SimpleExpandedLayout::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SimpleExpandedLayout::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SimpleExpandedLayout::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyString()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SimpleExpandedLayout::text() const {
  return *text_;
}
inline void SimpleExpandedLayout::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SimpleExpandedLayout::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SimpleExpandedLayout::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SimpleExpandedLayout::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SimpleExpandedLayout::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SimpleExpandedLayout::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyString()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .sync_pb.Media media = 3;
inline int SimpleExpandedLayout::media_size() const {
  return media_.size();
}
inline void SimpleExpandedLayout::clear_media() {
  media_.Clear();
}
inline const ::sync_pb::Media& SimpleExpandedLayout::media(int index) const {
  return media_.Get(index);
}
inline ::sync_pb::Media* SimpleExpandedLayout::mutable_media(int index) {
  return media_.Mutable(index);
}
inline ::sync_pb::Media* SimpleExpandedLayout::add_media() {
  return media_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Media >&
SimpleExpandedLayout::media() const {
  return media_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Media >*
SimpleExpandedLayout::mutable_media() {
  return &media_;
}

// optional .sync_pb.SyncedNotificationProfileImage profile_image = 4;
inline bool SimpleExpandedLayout::has_profile_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SimpleExpandedLayout::set_has_profile_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SimpleExpandedLayout::clear_has_profile_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SimpleExpandedLayout::clear_profile_image() {
  if (profile_image_ != NULL) profile_image_->::sync_pb::SyncedNotificationProfileImage::Clear();
  clear_has_profile_image();
}
inline const ::sync_pb::SyncedNotificationProfileImage& SimpleExpandedLayout::profile_image() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return profile_image_ != NULL ? *profile_image_ : *default_instance().profile_image_;
#else
  return profile_image_ != NULL ? *profile_image_ : *default_instance_->profile_image_;
#endif
}
inline ::sync_pb::SyncedNotificationProfileImage* SimpleExpandedLayout::mutable_profile_image() {
  set_has_profile_image();
  if (profile_image_ == NULL) profile_image_ = new ::sync_pb::SyncedNotificationProfileImage;
  return profile_image_;
}
inline ::sync_pb::SyncedNotificationProfileImage* SimpleExpandedLayout::release_profile_image() {
  clear_has_profile_image();
  ::sync_pb::SyncedNotificationProfileImage* temp = profile_image_;
  profile_image_ = NULL;
  return temp;
}
inline void SimpleExpandedLayout::set_allocated_profile_image(::sync_pb::SyncedNotificationProfileImage* profile_image) {
  delete profile_image_;
  profile_image_ = profile_image;
  if (profile_image) {
    set_has_profile_image();
  } else {
    clear_has_profile_image();
  }
}

// repeated .sync_pb.Target target = 5;
inline int SimpleExpandedLayout::target_size() const {
  return target_.size();
}
inline void SimpleExpandedLayout::clear_target() {
  target_.Clear();
}
inline const ::sync_pb::Target& SimpleExpandedLayout::target(int index) const {
  return target_.Get(index);
}
inline ::sync_pb::Target* SimpleExpandedLayout::mutable_target(int index) {
  return target_.Mutable(index);
}
inline ::sync_pb::Target* SimpleExpandedLayout::add_target() {
  return target_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >&
SimpleExpandedLayout::target() const {
  return target_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Target >*
SimpleExpandedLayout::mutable_target() {
  return &target_;
}

// -------------------------------------------------------------------

// Media

// optional .sync_pb.SyncedNotificationImage image = 1;
inline bool Media::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Media::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Media::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Media::clear_image() {
  if (image_ != NULL) image_->::sync_pb::SyncedNotificationImage::Clear();
  clear_has_image();
}
inline const ::sync_pb::SyncedNotificationImage& Media::image() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return image_ != NULL ? *image_ : *default_instance().image_;
#else
  return image_ != NULL ? *image_ : *default_instance_->image_;
#endif
}
inline ::sync_pb::SyncedNotificationImage* Media::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::sync_pb::SyncedNotificationImage;
  return image_;
}
inline ::sync_pb::SyncedNotificationImage* Media::release_image() {
  clear_has_image();
  ::sync_pb::SyncedNotificationImage* temp = image_;
  image_ = NULL;
  return temp;
}
inline void Media::set_allocated_image(::sync_pb::SyncedNotificationImage* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
}

// -------------------------------------------------------------------

// Target

// optional .sync_pb.SyncedNotificationDestination destination = 1;
inline bool Target::has_destination() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Target::set_has_destination() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Target::clear_has_destination() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Target::clear_destination() {
  if (destination_ != NULL) destination_->::sync_pb::SyncedNotificationDestination::Clear();
  clear_has_destination();
}
inline const ::sync_pb::SyncedNotificationDestination& Target::destination() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return destination_ != NULL ? *destination_ : *default_instance().destination_;
#else
  return destination_ != NULL ? *destination_ : *default_instance_->destination_;
#endif
}
inline ::sync_pb::SyncedNotificationDestination* Target::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) destination_ = new ::sync_pb::SyncedNotificationDestination;
  return destination_;
}
inline ::sync_pb::SyncedNotificationDestination* Target::release_destination() {
  clear_has_destination();
  ::sync_pb::SyncedNotificationDestination* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline void Target::set_allocated_destination(::sync_pb::SyncedNotificationDestination* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
}

// optional .sync_pb.SyncedNotificationAction action = 2;
inline bool Target::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Target::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Target::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Target::clear_action() {
  if (action_ != NULL) action_->::sync_pb::SyncedNotificationAction::Clear();
  clear_has_action();
}
inline const ::sync_pb::SyncedNotificationAction& Target::action() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return action_ != NULL ? *action_ : *default_instance().action_;
#else
  return action_ != NULL ? *action_ : *default_instance_->action_;
#endif
}
inline ::sync_pb::SyncedNotificationAction* Target::mutable_action() {
  set_has_action();
  if (action_ == NULL) action_ = new ::sync_pb::SyncedNotificationAction;
  return action_;
}
inline ::sync_pb::SyncedNotificationAction* Target::release_action() {
  clear_has_action();
  ::sync_pb::SyncedNotificationAction* temp = action_;
  action_ = NULL;
  return temp;
}
inline void Target::set_allocated_action(::sync_pb::SyncedNotificationAction* action) {
  delete action_;
  action_ = action;
  if (action) {
    set_has_action();
  } else {
    clear_has_action();
  }
}

// optional string target_key = 3;
inline bool Target::has_target_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Target::set_has_target_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Target::clear_has_target_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Target::clear_target_key() {
  if (target_key_ != &::google::protobuf::internal::GetEmptyString()) {
    target_key_->clear();
  }
  clear_has_target_key();
}
inline const ::std::string& Target::target_key() const {
  return *target_key_;
}
inline void Target::set_target_key(const ::std::string& value) {
  set_has_target_key();
  if (target_key_ == &::google::protobuf::internal::GetEmptyString()) {
    target_key_ = new ::std::string;
  }
  target_key_->assign(value);
}
inline void Target::set_target_key(const char* value) {
  set_has_target_key();
  if (target_key_ == &::google::protobuf::internal::GetEmptyString()) {
    target_key_ = new ::std::string;
  }
  target_key_->assign(value);
}
inline void Target::set_target_key(const char* value, size_t size) {
  set_has_target_key();
  if (target_key_ == &::google::protobuf::internal::GetEmptyString()) {
    target_key_ = new ::std::string;
  }
  target_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Target::mutable_target_key() {
  set_has_target_key();
  if (target_key_ == &::google::protobuf::internal::GetEmptyString()) {
    target_key_ = new ::std::string;
  }
  return target_key_;
}
inline ::std::string* Target::release_target_key() {
  clear_has_target_key();
  if (target_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = target_key_;
    target_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Target::set_allocated_target_key(::std::string* target_key) {
  if (target_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete target_key_;
  }
  if (target_key) {
    set_has_target_key();
    target_key_ = target_key;
  } else {
    clear_has_target_key();
    target_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// SyncedNotificationDestination

// optional string text = 1;
inline bool SyncedNotificationDestination::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncedNotificationDestination::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncedNotificationDestination::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncedNotificationDestination::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyString()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SyncedNotificationDestination::text() const {
  return *text_;
}
inline void SyncedNotificationDestination::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SyncedNotificationDestination::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SyncedNotificationDestination::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationDestination::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SyncedNotificationDestination::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationDestination::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyString()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.SyncedNotificationImage icon = 2;
inline bool SyncedNotificationDestination::has_icon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncedNotificationDestination::set_has_icon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncedNotificationDestination::clear_has_icon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncedNotificationDestination::clear_icon() {
  if (icon_ != NULL) icon_->::sync_pb::SyncedNotificationImage::Clear();
  clear_has_icon();
}
inline const ::sync_pb::SyncedNotificationImage& SyncedNotificationDestination::icon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return icon_ != NULL ? *icon_ : *default_instance().icon_;
#else
  return icon_ != NULL ? *icon_ : *default_instance_->icon_;
#endif
}
inline ::sync_pb::SyncedNotificationImage* SyncedNotificationDestination::mutable_icon() {
  set_has_icon();
  if (icon_ == NULL) icon_ = new ::sync_pb::SyncedNotificationImage;
  return icon_;
}
inline ::sync_pb::SyncedNotificationImage* SyncedNotificationDestination::release_icon() {
  clear_has_icon();
  ::sync_pb::SyncedNotificationImage* temp = icon_;
  icon_ = NULL;
  return temp;
}
inline void SyncedNotificationDestination::set_allocated_icon(::sync_pb::SyncedNotificationImage* icon) {
  delete icon_;
  icon_ = icon;
  if (icon) {
    set_has_icon();
  } else {
    clear_has_icon();
  }
}

// optional string url = 3;
inline bool SyncedNotificationDestination::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncedNotificationDestination::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncedNotificationDestination::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncedNotificationDestination::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyString()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& SyncedNotificationDestination::url() const {
  return *url_;
}
inline void SyncedNotificationDestination::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SyncedNotificationDestination::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SyncedNotificationDestination::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationDestination::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* SyncedNotificationDestination::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationDestination::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyString()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string accessibility_label = 4;
inline bool SyncedNotificationDestination::has_accessibility_label() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncedNotificationDestination::set_has_accessibility_label() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncedNotificationDestination::clear_has_accessibility_label() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncedNotificationDestination::clear_accessibility_label() {
  if (accessibility_label_ != &::google::protobuf::internal::GetEmptyString()) {
    accessibility_label_->clear();
  }
  clear_has_accessibility_label();
}
inline const ::std::string& SyncedNotificationDestination::accessibility_label() const {
  return *accessibility_label_;
}
inline void SyncedNotificationDestination::set_accessibility_label(const ::std::string& value) {
  set_has_accessibility_label();
  if (accessibility_label_ == &::google::protobuf::internal::GetEmptyString()) {
    accessibility_label_ = new ::std::string;
  }
  accessibility_label_->assign(value);
}
inline void SyncedNotificationDestination::set_accessibility_label(const char* value) {
  set_has_accessibility_label();
  if (accessibility_label_ == &::google::protobuf::internal::GetEmptyString()) {
    accessibility_label_ = new ::std::string;
  }
  accessibility_label_->assign(value);
}
inline void SyncedNotificationDestination::set_accessibility_label(const char* value, size_t size) {
  set_has_accessibility_label();
  if (accessibility_label_ == &::google::protobuf::internal::GetEmptyString()) {
    accessibility_label_ = new ::std::string;
  }
  accessibility_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationDestination::mutable_accessibility_label() {
  set_has_accessibility_label();
  if (accessibility_label_ == &::google::protobuf::internal::GetEmptyString()) {
    accessibility_label_ = new ::std::string;
  }
  return accessibility_label_;
}
inline ::std::string* SyncedNotificationDestination::release_accessibility_label() {
  clear_has_accessibility_label();
  if (accessibility_label_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = accessibility_label_;
    accessibility_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationDestination::set_allocated_accessibility_label(::std::string* accessibility_label) {
  if (accessibility_label_ != &::google::protobuf::internal::GetEmptyString()) {
    delete accessibility_label_;
  }
  if (accessibility_label) {
    set_has_accessibility_label();
    accessibility_label_ = accessibility_label;
  } else {
    clear_has_accessibility_label();
    accessibility_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// SyncedNotificationAction

// optional string text = 1;
inline bool SyncedNotificationAction::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncedNotificationAction::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncedNotificationAction::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncedNotificationAction::clear_text() {
  if (text_ != &::google::protobuf::internal::GetEmptyString()) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& SyncedNotificationAction::text() const {
  return *text_;
}
inline void SyncedNotificationAction::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SyncedNotificationAction::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void SyncedNotificationAction::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationAction::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* SyncedNotificationAction::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationAction::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::GetEmptyString()) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.SyncedNotificationImage icon = 2;
inline bool SyncedNotificationAction::has_icon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncedNotificationAction::set_has_icon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncedNotificationAction::clear_has_icon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncedNotificationAction::clear_icon() {
  if (icon_ != NULL) icon_->::sync_pb::SyncedNotificationImage::Clear();
  clear_has_icon();
}
inline const ::sync_pb::SyncedNotificationImage& SyncedNotificationAction::icon() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return icon_ != NULL ? *icon_ : *default_instance().icon_;
#else
  return icon_ != NULL ? *icon_ : *default_instance_->icon_;
#endif
}
inline ::sync_pb::SyncedNotificationImage* SyncedNotificationAction::mutable_icon() {
  set_has_icon();
  if (icon_ == NULL) icon_ = new ::sync_pb::SyncedNotificationImage;
  return icon_;
}
inline ::sync_pb::SyncedNotificationImage* SyncedNotificationAction::release_icon() {
  clear_has_icon();
  ::sync_pb::SyncedNotificationImage* temp = icon_;
  icon_ = NULL;
  return temp;
}
inline void SyncedNotificationAction::set_allocated_icon(::sync_pb::SyncedNotificationImage* icon) {
  delete icon_;
  icon_ = icon;
  if (icon) {
    set_has_icon();
  } else {
    clear_has_icon();
  }
}

// optional string url = 3;
inline bool SyncedNotificationAction::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncedNotificationAction::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncedNotificationAction::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncedNotificationAction::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyString()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& SyncedNotificationAction::url() const {
  return *url_;
}
inline void SyncedNotificationAction::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SyncedNotificationAction::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SyncedNotificationAction::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationAction::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* SyncedNotificationAction::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationAction::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyString()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string request_data = 4;
inline bool SyncedNotificationAction::has_request_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncedNotificationAction::set_has_request_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncedNotificationAction::clear_has_request_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncedNotificationAction::clear_request_data() {
  if (request_data_ != &::google::protobuf::internal::GetEmptyString()) {
    request_data_->clear();
  }
  clear_has_request_data();
}
inline const ::std::string& SyncedNotificationAction::request_data() const {
  return *request_data_;
}
inline void SyncedNotificationAction::set_request_data(const ::std::string& value) {
  set_has_request_data();
  if (request_data_ == &::google::protobuf::internal::GetEmptyString()) {
    request_data_ = new ::std::string;
  }
  request_data_->assign(value);
}
inline void SyncedNotificationAction::set_request_data(const char* value) {
  set_has_request_data();
  if (request_data_ == &::google::protobuf::internal::GetEmptyString()) {
    request_data_ = new ::std::string;
  }
  request_data_->assign(value);
}
inline void SyncedNotificationAction::set_request_data(const char* value, size_t size) {
  set_has_request_data();
  if (request_data_ == &::google::protobuf::internal::GetEmptyString()) {
    request_data_ = new ::std::string;
  }
  request_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationAction::mutable_request_data() {
  set_has_request_data();
  if (request_data_ == &::google::protobuf::internal::GetEmptyString()) {
    request_data_ = new ::std::string;
  }
  return request_data_;
}
inline ::std::string* SyncedNotificationAction::release_request_data() {
  clear_has_request_data();
  if (request_data_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = request_data_;
    request_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationAction::set_allocated_request_data(::std::string* request_data) {
  if (request_data_ != &::google::protobuf::internal::GetEmptyString()) {
    delete request_data_;
  }
  if (request_data) {
    set_has_request_data();
    request_data_ = request_data;
  } else {
    clear_has_request_data();
    request_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string accessibility_label = 5;
inline bool SyncedNotificationAction::has_accessibility_label() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SyncedNotificationAction::set_has_accessibility_label() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SyncedNotificationAction::clear_has_accessibility_label() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SyncedNotificationAction::clear_accessibility_label() {
  if (accessibility_label_ != &::google::protobuf::internal::GetEmptyString()) {
    accessibility_label_->clear();
  }
  clear_has_accessibility_label();
}
inline const ::std::string& SyncedNotificationAction::accessibility_label() const {
  return *accessibility_label_;
}
inline void SyncedNotificationAction::set_accessibility_label(const ::std::string& value) {
  set_has_accessibility_label();
  if (accessibility_label_ == &::google::protobuf::internal::GetEmptyString()) {
    accessibility_label_ = new ::std::string;
  }
  accessibility_label_->assign(value);
}
inline void SyncedNotificationAction::set_accessibility_label(const char* value) {
  set_has_accessibility_label();
  if (accessibility_label_ == &::google::protobuf::internal::GetEmptyString()) {
    accessibility_label_ = new ::std::string;
  }
  accessibility_label_->assign(value);
}
inline void SyncedNotificationAction::set_accessibility_label(const char* value, size_t size) {
  set_has_accessibility_label();
  if (accessibility_label_ == &::google::protobuf::internal::GetEmptyString()) {
    accessibility_label_ = new ::std::string;
  }
  accessibility_label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationAction::mutable_accessibility_label() {
  set_has_accessibility_label();
  if (accessibility_label_ == &::google::protobuf::internal::GetEmptyString()) {
    accessibility_label_ = new ::std::string;
  }
  return accessibility_label_;
}
inline ::std::string* SyncedNotificationAction::release_accessibility_label() {
  clear_has_accessibility_label();
  if (accessibility_label_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = accessibility_label_;
    accessibility_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationAction::set_allocated_accessibility_label(::std::string* accessibility_label) {
  if (accessibility_label_ != &::google::protobuf::internal::GetEmptyString()) {
    delete accessibility_label_;
  }
  if (accessibility_label) {
    set_has_accessibility_label();
    accessibility_label_ = accessibility_label;
  } else {
    clear_has_accessibility_label();
    accessibility_label_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated string meta_tag = 6;
inline int SyncedNotificationAction::meta_tag_size() const {
  return meta_tag_.size();
}
inline void SyncedNotificationAction::clear_meta_tag() {
  meta_tag_.Clear();
}
inline const ::std::string& SyncedNotificationAction::meta_tag(int index) const {
  return meta_tag_.Get(index);
}
inline ::std::string* SyncedNotificationAction::mutable_meta_tag(int index) {
  return meta_tag_.Mutable(index);
}
inline void SyncedNotificationAction::set_meta_tag(int index, const ::std::string& value) {
  meta_tag_.Mutable(index)->assign(value);
}
inline void SyncedNotificationAction::set_meta_tag(int index, const char* value) {
  meta_tag_.Mutable(index)->assign(value);
}
inline void SyncedNotificationAction::set_meta_tag(int index, const char* value, size_t size) {
  meta_tag_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationAction::add_meta_tag() {
  return meta_tag_.Add();
}
inline void SyncedNotificationAction::add_meta_tag(const ::std::string& value) {
  meta_tag_.Add()->assign(value);
}
inline void SyncedNotificationAction::add_meta_tag(const char* value) {
  meta_tag_.Add()->assign(value);
}
inline void SyncedNotificationAction::add_meta_tag(const char* value, size_t size) {
  meta_tag_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SyncedNotificationAction::meta_tag() const {
  return meta_tag_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SyncedNotificationAction::mutable_meta_tag() {
  return &meta_tag_;
}

// -------------------------------------------------------------------

// SyncedNotificationImage

// optional string url = 1;
inline bool SyncedNotificationImage::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncedNotificationImage::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncedNotificationImage::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncedNotificationImage::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyString()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& SyncedNotificationImage::url() const {
  return *url_;
}
inline void SyncedNotificationImage::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SyncedNotificationImage::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void SyncedNotificationImage::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationImage::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* SyncedNotificationImage::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationImage::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyString()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string alt_text = 2;
inline bool SyncedNotificationImage::has_alt_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncedNotificationImage::set_has_alt_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncedNotificationImage::clear_has_alt_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncedNotificationImage::clear_alt_text() {
  if (alt_text_ != &::google::protobuf::internal::GetEmptyString()) {
    alt_text_->clear();
  }
  clear_has_alt_text();
}
inline const ::std::string& SyncedNotificationImage::alt_text() const {
  return *alt_text_;
}
inline void SyncedNotificationImage::set_alt_text(const ::std::string& value) {
  set_has_alt_text();
  if (alt_text_ == &::google::protobuf::internal::GetEmptyString()) {
    alt_text_ = new ::std::string;
  }
  alt_text_->assign(value);
}
inline void SyncedNotificationImage::set_alt_text(const char* value) {
  set_has_alt_text();
  if (alt_text_ == &::google::protobuf::internal::GetEmptyString()) {
    alt_text_ = new ::std::string;
  }
  alt_text_->assign(value);
}
inline void SyncedNotificationImage::set_alt_text(const char* value, size_t size) {
  set_has_alt_text();
  if (alt_text_ == &::google::protobuf::internal::GetEmptyString()) {
    alt_text_ = new ::std::string;
  }
  alt_text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationImage::mutable_alt_text() {
  set_has_alt_text();
  if (alt_text_ == &::google::protobuf::internal::GetEmptyString()) {
    alt_text_ = new ::std::string;
  }
  return alt_text_;
}
inline ::std::string* SyncedNotificationImage::release_alt_text() {
  clear_has_alt_text();
  if (alt_text_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = alt_text_;
    alt_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationImage::set_allocated_alt_text(::std::string* alt_text) {
  if (alt_text_ != &::google::protobuf::internal::GetEmptyString()) {
    delete alt_text_;
  }
  if (alt_text) {
    set_has_alt_text();
    alt_text_ = alt_text;
  } else {
    clear_has_alt_text();
    alt_text_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int32 preferred_width = 3;
inline bool SyncedNotificationImage::has_preferred_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncedNotificationImage::set_has_preferred_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncedNotificationImage::clear_has_preferred_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncedNotificationImage::clear_preferred_width() {
  preferred_width_ = 0;
  clear_has_preferred_width();
}
inline ::google::protobuf::int32 SyncedNotificationImage::preferred_width() const {
  return preferred_width_;
}
inline void SyncedNotificationImage::set_preferred_width(::google::protobuf::int32 value) {
  set_has_preferred_width();
  preferred_width_ = value;
}

// optional int32 preferred_height = 4;
inline bool SyncedNotificationImage::has_preferred_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncedNotificationImage::set_has_preferred_height() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncedNotificationImage::clear_has_preferred_height() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncedNotificationImage::clear_preferred_height() {
  preferred_height_ = 0;
  clear_has_preferred_height();
}
inline ::google::protobuf::int32 SyncedNotificationImage::preferred_height() const {
  return preferred_height_;
}
inline void SyncedNotificationImage::set_preferred_height(::google::protobuf::int32 value) {
  set_has_preferred_height();
  preferred_height_ = value;
}

// -------------------------------------------------------------------

// SyncedNotificationProfileImage

// optional string image_url = 1;
inline bool SyncedNotificationProfileImage::has_image_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncedNotificationProfileImage::set_has_image_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncedNotificationProfileImage::clear_has_image_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncedNotificationProfileImage::clear_image_url() {
  if (image_url_ != &::google::protobuf::internal::GetEmptyString()) {
    image_url_->clear();
  }
  clear_has_image_url();
}
inline const ::std::string& SyncedNotificationProfileImage::image_url() const {
  return *image_url_;
}
inline void SyncedNotificationProfileImage::set_image_url(const ::std::string& value) {
  set_has_image_url();
  if (image_url_ == &::google::protobuf::internal::GetEmptyString()) {
    image_url_ = new ::std::string;
  }
  image_url_->assign(value);
}
inline void SyncedNotificationProfileImage::set_image_url(const char* value) {
  set_has_image_url();
  if (image_url_ == &::google::protobuf::internal::GetEmptyString()) {
    image_url_ = new ::std::string;
  }
  image_url_->assign(value);
}
inline void SyncedNotificationProfileImage::set_image_url(const char* value, size_t size) {
  set_has_image_url();
  if (image_url_ == &::google::protobuf::internal::GetEmptyString()) {
    image_url_ = new ::std::string;
  }
  image_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationProfileImage::mutable_image_url() {
  set_has_image_url();
  if (image_url_ == &::google::protobuf::internal::GetEmptyString()) {
    image_url_ = new ::std::string;
  }
  return image_url_;
}
inline ::std::string* SyncedNotificationProfileImage::release_image_url() {
  clear_has_image_url();
  if (image_url_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = image_url_;
    image_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationProfileImage::set_allocated_image_url(::std::string* image_url) {
  if (image_url_ != &::google::protobuf::internal::GetEmptyString()) {
    delete image_url_;
  }
  if (image_url) {
    set_has_image_url();
    image_url_ = image_url;
  } else {
    clear_has_image_url();
    image_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string oid = 2;
inline bool SyncedNotificationProfileImage::has_oid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncedNotificationProfileImage::set_has_oid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncedNotificationProfileImage::clear_has_oid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncedNotificationProfileImage::clear_oid() {
  if (oid_ != &::google::protobuf::internal::GetEmptyString()) {
    oid_->clear();
  }
  clear_has_oid();
}
inline const ::std::string& SyncedNotificationProfileImage::oid() const {
  return *oid_;
}
inline void SyncedNotificationProfileImage::set_oid(const ::std::string& value) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::GetEmptyString()) {
    oid_ = new ::std::string;
  }
  oid_->assign(value);
}
inline void SyncedNotificationProfileImage::set_oid(const char* value) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::GetEmptyString()) {
    oid_ = new ::std::string;
  }
  oid_->assign(value);
}
inline void SyncedNotificationProfileImage::set_oid(const char* value, size_t size) {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::GetEmptyString()) {
    oid_ = new ::std::string;
  }
  oid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationProfileImage::mutable_oid() {
  set_has_oid();
  if (oid_ == &::google::protobuf::internal::GetEmptyString()) {
    oid_ = new ::std::string;
  }
  return oid_;
}
inline ::std::string* SyncedNotificationProfileImage::release_oid() {
  clear_has_oid();
  if (oid_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = oid_;
    oid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationProfileImage::set_allocated_oid(::std::string* oid) {
  if (oid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete oid_;
  }
  if (oid) {
    set_has_oid();
    oid_ = oid;
  } else {
    clear_has_oid();
    oid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string display_name = 3;
inline bool SyncedNotificationProfileImage::has_display_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncedNotificationProfileImage::set_has_display_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncedNotificationProfileImage::clear_has_display_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncedNotificationProfileImage::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::GetEmptyString()) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& SyncedNotificationProfileImage::display_name() const {
  return *display_name_;
}
inline void SyncedNotificationProfileImage::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyString()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void SyncedNotificationProfileImage::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyString()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void SyncedNotificationProfileImage::set_display_name(const char* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyString()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationProfileImage::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyString()) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}
inline ::std::string* SyncedNotificationProfileImage::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationProfileImage::set_allocated_display_name(::std::string* display_name) {
  if (display_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete display_name_;
  }
  if (display_name) {
    set_has_display_name();
    display_name_ = display_name;
  } else {
    clear_has_display_name();
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sync_pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_synced_5fnotification_5frender_2eproto__INCLUDED
