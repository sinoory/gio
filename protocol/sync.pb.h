// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sync.proto

#ifndef PROTOBUF_sync_2eproto__INCLUDED
#define PROTOBUF_sync_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "app_list_specifics.pb.h"
#include "app_notification_specifics.pb.h"
#include "app_setting_specifics.pb.h"
#include "app_specifics.pb.h"
#include "article_specifics.pb.h"
#include "autofill_specifics.pb.h"
#include "bookmark_specifics.pb.h"
#include "client_commands.pb.h"
#include "client_debug_info.pb.h"
#include "device_info_specifics.pb.h"
#include "dictionary_specifics.pb.h"
#include "encryption.pb.h"
#include "experiments_specifics.pb.h"
#include "extension_setting_specifics.pb.h"
#include "extension_specifics.pb.h"
#include "favicon_image_specifics.pb.h"
#include "favicon_tracking_specifics.pb.h"
#include "get_updates_caller_info.pb.h"
#include "history_delete_directive_specifics.pb.h"
#include "nigori_specifics.pb.h"
#include "managed_user_setting_specifics.pb.h"
#include "managed_user_shared_setting_specifics.pb.h"
#include "managed_user_specifics.pb.h"
#include "password_specifics.pb.h"
#include "preference_specifics.pb.h"
#include "priority_preference_specifics.pb.h"
#include "search_engine_specifics.pb.h"
#include "session_specifics.pb.h"
#include "sync_enums.pb.h"
#include "synced_notification_app_info_specifics.pb.h"
#include "synced_notification_specifics.pb.h"
#include "theme_specifics.pb.h"
#include "typed_url_specifics.pb.h"
#include "unique_position.pb.h"
// @@protoc_insertion_point(includes)
#include "sync/base/sync_export.h"

namespace sync_pb {

// Internal implementation detail -- do not call these.
void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
void protobuf_AssignDesc_sync_2eproto();
void protobuf_ShutdownFile_sync_2eproto();

class ProfilingData;
class EntitySpecifics;
class SyncEntity;
class SyncEntity_BookmarkData;
class ChromiumExtensionsActivity;
class ClientConfigParams;
class CommitMessage;
class GetUpdateTriggers;
class GarbageCollectionDirective;
class DataTypeProgressMarker;
class GetUpdatesMessage;
class AuthenticateMessage;
class ClearUserDataMessage;
class ClearUserDataResponse;
class ChipBag;
class ClientStatus;
class ClientToServerMessage;
class GetCrashInfoRequest;
class GetCrashInfoResponse;
class CommitResponse;
class CommitResponse_EntryResponse;
class GetUpdatesResponse;
class GetUpdatesMetadataResponse;
class GetUpdatesStreamingResponse;
class UserIdentification;
class AuthenticateResponse;
class ThrottleParameters;
class ClientToServerResponse;
class ClientToServerResponse_Error;

enum GarbageCollectionDirective_Type {
  GarbageCollectionDirective_Type_UNKNOWN = 0,
  GarbageCollectionDirective_Type_VERSION_WATERMARK = 1,
  GarbageCollectionDirective_Type_AGE_WATERMARK = 2,
  GarbageCollectionDirective_Type_MAX_ITEM_COUNT = 3
};
SYNC_EXPORT bool GarbageCollectionDirective_Type_IsValid(int value);
const GarbageCollectionDirective_Type GarbageCollectionDirective_Type_Type_MIN = GarbageCollectionDirective_Type_UNKNOWN;
const GarbageCollectionDirective_Type GarbageCollectionDirective_Type_Type_MAX = GarbageCollectionDirective_Type_MAX_ITEM_COUNT;
const int GarbageCollectionDirective_Type_Type_ARRAYSIZE = GarbageCollectionDirective_Type_Type_MAX + 1;

enum ClientToServerMessage_Contents {
  ClientToServerMessage_Contents_COMMIT = 1,
  ClientToServerMessage_Contents_GET_UPDATES = 2,
  ClientToServerMessage_Contents_AUTHENTICATE = 3,
  ClientToServerMessage_Contents_CLEAR_DATA = 4
};
SYNC_EXPORT bool ClientToServerMessage_Contents_IsValid(int value);
const ClientToServerMessage_Contents ClientToServerMessage_Contents_Contents_MIN = ClientToServerMessage_Contents_COMMIT;
const ClientToServerMessage_Contents ClientToServerMessage_Contents_Contents_MAX = ClientToServerMessage_Contents_CLEAR_DATA;
const int ClientToServerMessage_Contents_Contents_ARRAYSIZE = ClientToServerMessage_Contents_Contents_MAX + 1;

enum CommitResponse_ResponseType {
  CommitResponse_ResponseType_SUCCESS = 1,
  CommitResponse_ResponseType_CONFLICT = 2,
  CommitResponse_ResponseType_RETRY = 3,
  CommitResponse_ResponseType_INVALID_MESSAGE = 4,
  CommitResponse_ResponseType_OVER_QUOTA = 5,
  CommitResponse_ResponseType_TRANSIENT_ERROR = 6
};
SYNC_EXPORT bool CommitResponse_ResponseType_IsValid(int value);
const CommitResponse_ResponseType CommitResponse_ResponseType_ResponseType_MIN = CommitResponse_ResponseType_SUCCESS;
const CommitResponse_ResponseType CommitResponse_ResponseType_ResponseType_MAX = CommitResponse_ResponseType_TRANSIENT_ERROR;
const int CommitResponse_ResponseType_ResponseType_ARRAYSIZE = CommitResponse_ResponseType_ResponseType_MAX + 1;

// ===================================================================

class SYNC_EXPORT ProfilingData : public ::google::protobuf::MessageLite {
 public:
  ProfilingData();
  virtual ~ProfilingData();

  ProfilingData(const ProfilingData& from);

  inline ProfilingData& operator=(const ProfilingData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ProfilingData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProfilingData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProfilingData* other);

  // implements Message ----------------------------------------------

  ProfilingData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProfilingData& from);
  void MergeFrom(const ProfilingData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 meta_data_write_time = 1;
  inline bool has_meta_data_write_time() const;
  inline void clear_meta_data_write_time();
  static const int kMetaDataWriteTimeFieldNumber = 1;
  inline ::google::protobuf::int64 meta_data_write_time() const;
  inline void set_meta_data_write_time(::google::protobuf::int64 value);

  // optional int64 file_data_write_time = 2;
  inline bool has_file_data_write_time() const;
  inline void clear_file_data_write_time();
  static const int kFileDataWriteTimeFieldNumber = 2;
  inline ::google::protobuf::int64 file_data_write_time() const;
  inline void set_file_data_write_time(::google::protobuf::int64 value);

  // optional int64 user_lookup_time = 3;
  inline bool has_user_lookup_time() const;
  inline void clear_user_lookup_time();
  static const int kUserLookupTimeFieldNumber = 3;
  inline ::google::protobuf::int64 user_lookup_time() const;
  inline void set_user_lookup_time(::google::protobuf::int64 value);

  // optional int64 meta_data_read_time = 4;
  inline bool has_meta_data_read_time() const;
  inline void clear_meta_data_read_time();
  static const int kMetaDataReadTimeFieldNumber = 4;
  inline ::google::protobuf::int64 meta_data_read_time() const;
  inline void set_meta_data_read_time(::google::protobuf::int64 value);

  // optional int64 file_data_read_time = 5;
  inline bool has_file_data_read_time() const;
  inline void clear_file_data_read_time();
  static const int kFileDataReadTimeFieldNumber = 5;
  inline ::google::protobuf::int64 file_data_read_time() const;
  inline void set_file_data_read_time(::google::protobuf::int64 value);

  // optional int64 total_request_time = 6;
  inline bool has_total_request_time() const;
  inline void clear_total_request_time();
  static const int kTotalRequestTimeFieldNumber = 6;
  inline ::google::protobuf::int64 total_request_time() const;
  inline void set_total_request_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sync_pb.ProfilingData)
 private:
  inline void set_has_meta_data_write_time();
  inline void clear_has_meta_data_write_time();
  inline void set_has_file_data_write_time();
  inline void clear_has_file_data_write_time();
  inline void set_has_user_lookup_time();
  inline void clear_has_user_lookup_time();
  inline void set_has_meta_data_read_time();
  inline void clear_has_meta_data_read_time();
  inline void set_has_file_data_read_time();
  inline void clear_has_file_data_read_time();
  inline void set_has_total_request_time();
  inline void clear_has_total_request_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 meta_data_write_time_;
  ::google::protobuf::int64 file_data_write_time_;
  ::google::protobuf::int64 user_lookup_time_;
  ::google::protobuf::int64 meta_data_read_time_;
  ::google::protobuf::int64 file_data_read_time_;
  ::google::protobuf::int64 total_request_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ProfilingData* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT EntitySpecifics : public ::google::protobuf::MessageLite {
 public:
  EntitySpecifics();
  virtual ~EntitySpecifics();

  EntitySpecifics(const EntitySpecifics& from);

  inline EntitySpecifics& operator=(const EntitySpecifics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EntitySpecifics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EntitySpecifics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EntitySpecifics* other);

  // implements Message ----------------------------------------------

  EntitySpecifics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EntitySpecifics& from);
  void MergeFrom(const EntitySpecifics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sync_pb.EncryptedData encrypted = 1;
  inline bool has_encrypted() const;
  inline void clear_encrypted();
  static const int kEncryptedFieldNumber = 1;
  inline const ::sync_pb::EncryptedData& encrypted() const;
  inline ::sync_pb::EncryptedData* mutable_encrypted();
  inline ::sync_pb::EncryptedData* release_encrypted();
  inline void set_allocated_encrypted(::sync_pb::EncryptedData* encrypted);

  // optional .sync_pb.AutofillSpecifics autofill = 31729;
  inline bool has_autofill() const;
  inline void clear_autofill();
  static const int kAutofillFieldNumber = 31729;
  inline const ::sync_pb::AutofillSpecifics& autofill() const;
  inline ::sync_pb::AutofillSpecifics* mutable_autofill();
  inline ::sync_pb::AutofillSpecifics* release_autofill();
  inline void set_allocated_autofill(::sync_pb::AutofillSpecifics* autofill);

  // optional .sync_pb.BookmarkSpecifics bookmark = 32904;
  inline bool has_bookmark() const;
  inline void clear_bookmark();
  static const int kBookmarkFieldNumber = 32904;
  inline const ::sync_pb::BookmarkSpecifics& bookmark() const;
  inline ::sync_pb::BookmarkSpecifics* mutable_bookmark();
  inline ::sync_pb::BookmarkSpecifics* release_bookmark();
  inline void set_allocated_bookmark(::sync_pb::BookmarkSpecifics* bookmark);

  // optional .sync_pb.PreferenceSpecifics preference = 37702;
  inline bool has_preference() const;
  inline void clear_preference();
  static const int kPreferenceFieldNumber = 37702;
  inline const ::sync_pb::PreferenceSpecifics& preference() const;
  inline ::sync_pb::PreferenceSpecifics* mutable_preference();
  inline ::sync_pb::PreferenceSpecifics* release_preference();
  inline void set_allocated_preference(::sync_pb::PreferenceSpecifics* preference);

  // optional .sync_pb.TypedUrlSpecifics typed_url = 40781;
  inline bool has_typed_url() const;
  inline void clear_typed_url();
  static const int kTypedUrlFieldNumber = 40781;
  inline const ::sync_pb::TypedUrlSpecifics& typed_url() const;
  inline ::sync_pb::TypedUrlSpecifics* mutable_typed_url();
  inline ::sync_pb::TypedUrlSpecifics* release_typed_url();
  inline void set_allocated_typed_url(::sync_pb::TypedUrlSpecifics* typed_url);

  // optional .sync_pb.ThemeSpecifics theme = 41210;
  inline bool has_theme() const;
  inline void clear_theme();
  static const int kThemeFieldNumber = 41210;
  inline const ::sync_pb::ThemeSpecifics& theme() const;
  inline ::sync_pb::ThemeSpecifics* mutable_theme();
  inline ::sync_pb::ThemeSpecifics* release_theme();
  inline void set_allocated_theme(::sync_pb::ThemeSpecifics* theme);

  // optional .sync_pb.AppNotification app_notification = 45184;
  inline bool has_app_notification() const;
  inline void clear_app_notification();
  static const int kAppNotificationFieldNumber = 45184;
  inline const ::sync_pb::AppNotification& app_notification() const;
  inline ::sync_pb::AppNotification* mutable_app_notification();
  inline ::sync_pb::AppNotification* release_app_notification();
  inline void set_allocated_app_notification(::sync_pb::AppNotification* app_notification);

  // optional .sync_pb.PasswordSpecifics password = 45873;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 45873;
  inline const ::sync_pb::PasswordSpecifics& password() const;
  inline ::sync_pb::PasswordSpecifics* mutable_password();
  inline ::sync_pb::PasswordSpecifics* release_password();
  inline void set_allocated_password(::sync_pb::PasswordSpecifics* password);

  // optional .sync_pb.NigoriSpecifics nigori = 47745;
  inline bool has_nigori() const;
  inline void clear_nigori();
  static const int kNigoriFieldNumber = 47745;
  inline const ::sync_pb::NigoriSpecifics& nigori() const;
  inline ::sync_pb::NigoriSpecifics* mutable_nigori();
  inline ::sync_pb::NigoriSpecifics* release_nigori();
  inline void set_allocated_nigori(::sync_pb::NigoriSpecifics* nigori);

  // optional .sync_pb.ExtensionSpecifics extension = 48119;
  inline bool has_extension() const;
  inline void clear_extension();
  static const int kExtensionFieldNumber = 48119;
  inline const ::sync_pb::ExtensionSpecifics& extension() const;
  inline ::sync_pb::ExtensionSpecifics* mutable_extension();
  inline ::sync_pb::ExtensionSpecifics* release_extension();
  inline void set_allocated_extension(::sync_pb::ExtensionSpecifics* extension);

  // optional .sync_pb.AppSpecifics app = 48364;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 48364;
  inline const ::sync_pb::AppSpecifics& app() const;
  inline ::sync_pb::AppSpecifics* mutable_app();
  inline ::sync_pb::AppSpecifics* release_app();
  inline void set_allocated_app(::sync_pb::AppSpecifics* app);

  // optional .sync_pb.SessionSpecifics session = 50119;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 50119;
  inline const ::sync_pb::SessionSpecifics& session() const;
  inline ::sync_pb::SessionSpecifics* mutable_session();
  inline ::sync_pb::SessionSpecifics* release_session();
  inline void set_allocated_session(::sync_pb::SessionSpecifics* session);

  // optional .sync_pb.AutofillProfileSpecifics autofill_profile = 63951;
  inline bool has_autofill_profile() const;
  inline void clear_autofill_profile();
  static const int kAutofillProfileFieldNumber = 63951;
  inline const ::sync_pb::AutofillProfileSpecifics& autofill_profile() const;
  inline ::sync_pb::AutofillProfileSpecifics* mutable_autofill_profile();
  inline ::sync_pb::AutofillProfileSpecifics* release_autofill_profile();
  inline void set_allocated_autofill_profile(::sync_pb::AutofillProfileSpecifics* autofill_profile);

  // optional .sync_pb.SearchEngineSpecifics search_engine = 88610;
  inline bool has_search_engine() const;
  inline void clear_search_engine();
  static const int kSearchEngineFieldNumber = 88610;
  inline const ::sync_pb::SearchEngineSpecifics& search_engine() const;
  inline ::sync_pb::SearchEngineSpecifics* mutable_search_engine();
  inline ::sync_pb::SearchEngineSpecifics* release_search_engine();
  inline void set_allocated_search_engine(::sync_pb::SearchEngineSpecifics* search_engine);

  // optional .sync_pb.ExtensionSettingSpecifics extension_setting = 96159;
  inline bool has_extension_setting() const;
  inline void clear_extension_setting();
  static const int kExtensionSettingFieldNumber = 96159;
  inline const ::sync_pb::ExtensionSettingSpecifics& extension_setting() const;
  inline ::sync_pb::ExtensionSettingSpecifics* mutable_extension_setting();
  inline ::sync_pb::ExtensionSettingSpecifics* release_extension_setting();
  inline void set_allocated_extension_setting(::sync_pb::ExtensionSettingSpecifics* extension_setting);

  // optional .sync_pb.AppSettingSpecifics app_setting = 103656;
  inline bool has_app_setting() const;
  inline void clear_app_setting();
  static const int kAppSettingFieldNumber = 103656;
  inline const ::sync_pb::AppSettingSpecifics& app_setting() const;
  inline ::sync_pb::AppSettingSpecifics* mutable_app_setting();
  inline ::sync_pb::AppSettingSpecifics* release_app_setting();
  inline void set_allocated_app_setting(::sync_pb::AppSettingSpecifics* app_setting);

  // optional .sync_pb.HistoryDeleteDirectiveSpecifics history_delete_directive = 150251;
  inline bool has_history_delete_directive() const;
  inline void clear_history_delete_directive();
  static const int kHistoryDeleteDirectiveFieldNumber = 150251;
  inline const ::sync_pb::HistoryDeleteDirectiveSpecifics& history_delete_directive() const;
  inline ::sync_pb::HistoryDeleteDirectiveSpecifics* mutable_history_delete_directive();
  inline ::sync_pb::HistoryDeleteDirectiveSpecifics* release_history_delete_directive();
  inline void set_allocated_history_delete_directive(::sync_pb::HistoryDeleteDirectiveSpecifics* history_delete_directive);

  // optional .sync_pb.SyncedNotificationSpecifics synced_notification = 153108;
  inline bool has_synced_notification() const;
  inline void clear_synced_notification();
  static const int kSyncedNotificationFieldNumber = 153108;
  inline const ::sync_pb::SyncedNotificationSpecifics& synced_notification() const;
  inline ::sync_pb::SyncedNotificationSpecifics* mutable_synced_notification();
  inline ::sync_pb::SyncedNotificationSpecifics* release_synced_notification();
  inline void set_allocated_synced_notification(::sync_pb::SyncedNotificationSpecifics* synced_notification);

  // optional .sync_pb.SyncedNotificationAppInfoSpecifics synced_notification_app_info = 235816;
  inline bool has_synced_notification_app_info() const;
  inline void clear_synced_notification_app_info();
  static const int kSyncedNotificationAppInfoFieldNumber = 235816;
  inline const ::sync_pb::SyncedNotificationAppInfoSpecifics& synced_notification_app_info() const;
  inline ::sync_pb::SyncedNotificationAppInfoSpecifics* mutable_synced_notification_app_info();
  inline ::sync_pb::SyncedNotificationAppInfoSpecifics* release_synced_notification_app_info();
  inline void set_allocated_synced_notification_app_info(::sync_pb::SyncedNotificationAppInfoSpecifics* synced_notification_app_info);

  // optional .sync_pb.DeviceInfoSpecifics device_info = 154522;
  inline bool has_device_info() const;
  inline void clear_device_info();
  static const int kDeviceInfoFieldNumber = 154522;
  inline const ::sync_pb::DeviceInfoSpecifics& device_info() const;
  inline ::sync_pb::DeviceInfoSpecifics* mutable_device_info();
  inline ::sync_pb::DeviceInfoSpecifics* release_device_info();
  inline void set_allocated_device_info(::sync_pb::DeviceInfoSpecifics* device_info);

  // optional .sync_pb.ExperimentsSpecifics experiments = 161496;
  inline bool has_experiments() const;
  inline void clear_experiments();
  static const int kExperimentsFieldNumber = 161496;
  inline const ::sync_pb::ExperimentsSpecifics& experiments() const;
  inline ::sync_pb::ExperimentsSpecifics* mutable_experiments();
  inline ::sync_pb::ExperimentsSpecifics* release_experiments();
  inline void set_allocated_experiments(::sync_pb::ExperimentsSpecifics* experiments);

  // optional .sync_pb.PriorityPreferenceSpecifics priority_preference = 163425;
  inline bool has_priority_preference() const;
  inline void clear_priority_preference();
  static const int kPriorityPreferenceFieldNumber = 163425;
  inline const ::sync_pb::PriorityPreferenceSpecifics& priority_preference() const;
  inline ::sync_pb::PriorityPreferenceSpecifics* mutable_priority_preference();
  inline ::sync_pb::PriorityPreferenceSpecifics* release_priority_preference();
  inline void set_allocated_priority_preference(::sync_pb::PriorityPreferenceSpecifics* priority_preference);

  // optional .sync_pb.DictionarySpecifics dictionary = 170540;
  inline bool has_dictionary() const;
  inline void clear_dictionary();
  static const int kDictionaryFieldNumber = 170540;
  inline const ::sync_pb::DictionarySpecifics& dictionary() const;
  inline ::sync_pb::DictionarySpecifics* mutable_dictionary();
  inline ::sync_pb::DictionarySpecifics* release_dictionary();
  inline void set_allocated_dictionary(::sync_pb::DictionarySpecifics* dictionary);

  // optional .sync_pb.FaviconTrackingSpecifics favicon_tracking = 181534;
  inline bool has_favicon_tracking() const;
  inline void clear_favicon_tracking();
  static const int kFaviconTrackingFieldNumber = 181534;
  inline const ::sync_pb::FaviconTrackingSpecifics& favicon_tracking() const;
  inline ::sync_pb::FaviconTrackingSpecifics* mutable_favicon_tracking();
  inline ::sync_pb::FaviconTrackingSpecifics* release_favicon_tracking();
  inline void set_allocated_favicon_tracking(::sync_pb::FaviconTrackingSpecifics* favicon_tracking);

  // optional .sync_pb.FaviconImageSpecifics favicon_image = 182019;
  inline bool has_favicon_image() const;
  inline void clear_favicon_image();
  static const int kFaviconImageFieldNumber = 182019;
  inline const ::sync_pb::FaviconImageSpecifics& favicon_image() const;
  inline ::sync_pb::FaviconImageSpecifics* mutable_favicon_image();
  inline ::sync_pb::FaviconImageSpecifics* release_favicon_image();
  inline void set_allocated_favicon_image(::sync_pb::FaviconImageSpecifics* favicon_image);

  // optional .sync_pb.ManagedUserSettingSpecifics managed_user_setting = 186662;
  inline bool has_managed_user_setting() const;
  inline void clear_managed_user_setting();
  static const int kManagedUserSettingFieldNumber = 186662;
  inline const ::sync_pb::ManagedUserSettingSpecifics& managed_user_setting() const;
  inline ::sync_pb::ManagedUserSettingSpecifics* mutable_managed_user_setting();
  inline ::sync_pb::ManagedUserSettingSpecifics* release_managed_user_setting();
  inline void set_allocated_managed_user_setting(::sync_pb::ManagedUserSettingSpecifics* managed_user_setting);

  // optional .sync_pb.ManagedUserSpecifics managed_user = 194582;
  inline bool has_managed_user() const;
  inline void clear_managed_user();
  static const int kManagedUserFieldNumber = 194582;
  inline const ::sync_pb::ManagedUserSpecifics& managed_user() const;
  inline ::sync_pb::ManagedUserSpecifics* mutable_managed_user();
  inline ::sync_pb::ManagedUserSpecifics* release_managed_user();
  inline void set_allocated_managed_user(::sync_pb::ManagedUserSpecifics* managed_user);

  // optional .sync_pb.ManagedUserSharedSettingSpecifics managed_user_shared_setting = 202026;
  inline bool has_managed_user_shared_setting() const;
  inline void clear_managed_user_shared_setting();
  static const int kManagedUserSharedSettingFieldNumber = 202026;
  inline const ::sync_pb::ManagedUserSharedSettingSpecifics& managed_user_shared_setting() const;
  inline ::sync_pb::ManagedUserSharedSettingSpecifics* mutable_managed_user_shared_setting();
  inline ::sync_pb::ManagedUserSharedSettingSpecifics* release_managed_user_shared_setting();
  inline void set_allocated_managed_user_shared_setting(::sync_pb::ManagedUserSharedSettingSpecifics* managed_user_shared_setting);

  // optional .sync_pb.ArticleSpecifics article = 223759;
  inline bool has_article() const;
  inline void clear_article();
  static const int kArticleFieldNumber = 223759;
  inline const ::sync_pb::ArticleSpecifics& article() const;
  inline ::sync_pb::ArticleSpecifics* mutable_article();
  inline ::sync_pb::ArticleSpecifics* release_article();
  inline void set_allocated_article(::sync_pb::ArticleSpecifics* article);

  // optional .sync_pb.AppListSpecifics app_list = 229170;
  inline bool has_app_list() const;
  inline void clear_app_list();
  static const int kAppListFieldNumber = 229170;
  inline const ::sync_pb::AppListSpecifics& app_list() const;
  inline ::sync_pb::AppListSpecifics* mutable_app_list();
  inline ::sync_pb::AppListSpecifics* release_app_list();
  inline void set_allocated_app_list(::sync_pb::AppListSpecifics* app_list);

  // @@protoc_insertion_point(class_scope:sync_pb.EntitySpecifics)
 private:
  inline void set_has_encrypted();
  inline void clear_has_encrypted();
  inline void set_has_autofill();
  inline void clear_has_autofill();
  inline void set_has_bookmark();
  inline void clear_has_bookmark();
  inline void set_has_preference();
  inline void clear_has_preference();
  inline void set_has_typed_url();
  inline void clear_has_typed_url();
  inline void set_has_theme();
  inline void clear_has_theme();
  inline void set_has_app_notification();
  inline void clear_has_app_notification();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_nigori();
  inline void clear_has_nigori();
  inline void set_has_extension();
  inline void clear_has_extension();
  inline void set_has_app();
  inline void clear_has_app();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_autofill_profile();
  inline void clear_has_autofill_profile();
  inline void set_has_search_engine();
  inline void clear_has_search_engine();
  inline void set_has_extension_setting();
  inline void clear_has_extension_setting();
  inline void set_has_app_setting();
  inline void clear_has_app_setting();
  inline void set_has_history_delete_directive();
  inline void clear_has_history_delete_directive();
  inline void set_has_synced_notification();
  inline void clear_has_synced_notification();
  inline void set_has_synced_notification_app_info();
  inline void clear_has_synced_notification_app_info();
  inline void set_has_device_info();
  inline void clear_has_device_info();
  inline void set_has_experiments();
  inline void clear_has_experiments();
  inline void set_has_priority_preference();
  inline void clear_has_priority_preference();
  inline void set_has_dictionary();
  inline void clear_has_dictionary();
  inline void set_has_favicon_tracking();
  inline void clear_has_favicon_tracking();
  inline void set_has_favicon_image();
  inline void clear_has_favicon_image();
  inline void set_has_managed_user_setting();
  inline void clear_has_managed_user_setting();
  inline void set_has_managed_user();
  inline void clear_has_managed_user();
  inline void set_has_managed_user_shared_setting();
  inline void clear_has_managed_user_shared_setting();
  inline void set_has_article();
  inline void clear_has_article();
  inline void set_has_app_list();
  inline void clear_has_app_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::EncryptedData* encrypted_;
  ::sync_pb::AutofillSpecifics* autofill_;
  ::sync_pb::BookmarkSpecifics* bookmark_;
  ::sync_pb::PreferenceSpecifics* preference_;
  ::sync_pb::TypedUrlSpecifics* typed_url_;
  ::sync_pb::ThemeSpecifics* theme_;
  ::sync_pb::AppNotification* app_notification_;
  ::sync_pb::PasswordSpecifics* password_;
  ::sync_pb::NigoriSpecifics* nigori_;
  ::sync_pb::ExtensionSpecifics* extension_;
  ::sync_pb::AppSpecifics* app_;
  ::sync_pb::SessionSpecifics* session_;
  ::sync_pb::AutofillProfileSpecifics* autofill_profile_;
  ::sync_pb::SearchEngineSpecifics* search_engine_;
  ::sync_pb::ExtensionSettingSpecifics* extension_setting_;
  ::sync_pb::AppSettingSpecifics* app_setting_;
  ::sync_pb::HistoryDeleteDirectiveSpecifics* history_delete_directive_;
  ::sync_pb::SyncedNotificationSpecifics* synced_notification_;
  ::sync_pb::SyncedNotificationAppInfoSpecifics* synced_notification_app_info_;
  ::sync_pb::DeviceInfoSpecifics* device_info_;
  ::sync_pb::ExperimentsSpecifics* experiments_;
  ::sync_pb::PriorityPreferenceSpecifics* priority_preference_;
  ::sync_pb::DictionarySpecifics* dictionary_;
  ::sync_pb::FaviconTrackingSpecifics* favicon_tracking_;
  ::sync_pb::FaviconImageSpecifics* favicon_image_;
  ::sync_pb::ManagedUserSettingSpecifics* managed_user_setting_;
  ::sync_pb::ManagedUserSpecifics* managed_user_;
  ::sync_pb::ManagedUserSharedSettingSpecifics* managed_user_shared_setting_;
  ::sync_pb::ArticleSpecifics* article_;
  ::sync_pb::AppListSpecifics* app_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static EntitySpecifics* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SyncEntity_BookmarkData : public ::google::protobuf::MessageLite {
 public:
  SyncEntity_BookmarkData();
  virtual ~SyncEntity_BookmarkData();

  SyncEntity_BookmarkData(const SyncEntity_BookmarkData& from);

  inline SyncEntity_BookmarkData& operator=(const SyncEntity_BookmarkData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncEntity_BookmarkData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncEntity_BookmarkData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncEntity_BookmarkData* other);

  // implements Message ----------------------------------------------

  SyncEntity_BookmarkData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncEntity_BookmarkData& from);
  void MergeFrom(const SyncEntity_BookmarkData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool bookmark_folder = 12;
  inline bool has_bookmark_folder() const;
  inline void clear_bookmark_folder();
  static const int kBookmarkFolderFieldNumber = 12;
  inline bool bookmark_folder() const;
  inline void set_bookmark_folder(bool value);

  // optional string bookmark_url = 13;
  inline bool has_bookmark_url() const;
  inline void clear_bookmark_url();
  static const int kBookmarkUrlFieldNumber = 13;
  inline const ::std::string& bookmark_url() const;
  inline void set_bookmark_url(const ::std::string& value);
  inline void set_bookmark_url(const char* value);
  inline void set_bookmark_url(const char* value, size_t size);
  inline ::std::string* mutable_bookmark_url();
  inline ::std::string* release_bookmark_url();
  inline void set_allocated_bookmark_url(::std::string* bookmark_url);

  // optional bytes bookmark_favicon = 14;
  inline bool has_bookmark_favicon() const;
  inline void clear_bookmark_favicon();
  static const int kBookmarkFaviconFieldNumber = 14;
  inline const ::std::string& bookmark_favicon() const;
  inline void set_bookmark_favicon(const ::std::string& value);
  inline void set_bookmark_favicon(const char* value);
  inline void set_bookmark_favicon(const void* value, size_t size);
  inline ::std::string* mutable_bookmark_favicon();
  inline ::std::string* release_bookmark_favicon();
  inline void set_allocated_bookmark_favicon(::std::string* bookmark_favicon);

  // @@protoc_insertion_point(class_scope:sync_pb.SyncEntity.BookmarkData)
 private:
  inline void set_has_bookmark_folder();
  inline void clear_has_bookmark_folder();
  inline void set_has_bookmark_url();
  inline void clear_has_bookmark_url();
  inline void set_has_bookmark_favicon();
  inline void clear_has_bookmark_favicon();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* bookmark_url_;
  ::std::string* bookmark_favicon_;
  bool bookmark_folder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static SyncEntity_BookmarkData* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SyncEntity : public ::google::protobuf::MessageLite {
 public:
  SyncEntity();
  virtual ~SyncEntity();

  SyncEntity(const SyncEntity& from);

  inline SyncEntity& operator=(const SyncEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncEntity& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncEntity* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncEntity* other);

  // implements Message ----------------------------------------------

  SyncEntity* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncEntity& from);
  void MergeFrom(const SyncEntity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SyncEntity_BookmarkData BookmarkData;

  // accessors -------------------------------------------------------

  // optional string id_string = 1;
  inline bool has_id_string() const;
  inline void clear_id_string();
  static const int kIdStringFieldNumber = 1;
  inline const ::std::string& id_string() const;
  inline void set_id_string(const ::std::string& value);
  inline void set_id_string(const char* value);
  inline void set_id_string(const char* value, size_t size);
  inline ::std::string* mutable_id_string();
  inline ::std::string* release_id_string();
  inline void set_allocated_id_string(::std::string* id_string);

  // optional string parent_id_string = 2;
  inline bool has_parent_id_string() const;
  inline void clear_parent_id_string();
  static const int kParentIdStringFieldNumber = 2;
  inline const ::std::string& parent_id_string() const;
  inline void set_parent_id_string(const ::std::string& value);
  inline void set_parent_id_string(const char* value);
  inline void set_parent_id_string(const char* value, size_t size);
  inline ::std::string* mutable_parent_id_string();
  inline ::std::string* release_parent_id_string();
  inline void set_allocated_parent_id_string(::std::string* parent_id_string);

  // optional string old_parent_id = 3;
  inline bool has_old_parent_id() const;
  inline void clear_old_parent_id();
  static const int kOldParentIdFieldNumber = 3;
  inline const ::std::string& old_parent_id() const;
  inline void set_old_parent_id(const ::std::string& value);
  inline void set_old_parent_id(const char* value);
  inline void set_old_parent_id(const char* value, size_t size);
  inline ::std::string* mutable_old_parent_id();
  inline ::std::string* release_old_parent_id();
  inline void set_allocated_old_parent_id(::std::string* old_parent_id);

  // required int64 version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::int64 version() const;
  inline void set_version(::google::protobuf::int64 value);

  // optional int64 mtime = 5;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 5;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);

  // optional int64 ctime = 6;
  inline bool has_ctime() const;
  inline void clear_ctime();
  static const int kCtimeFieldNumber = 6;
  inline ::google::protobuf::int64 ctime() const;
  inline void set_ctime(::google::protobuf::int64 value);

  // required string name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string non_unique_name = 8;
  inline bool has_non_unique_name() const;
  inline void clear_non_unique_name();
  static const int kNonUniqueNameFieldNumber = 8;
  inline const ::std::string& non_unique_name() const;
  inline void set_non_unique_name(const ::std::string& value);
  inline void set_non_unique_name(const char* value);
  inline void set_non_unique_name(const char* value, size_t size);
  inline ::std::string* mutable_non_unique_name();
  inline ::std::string* release_non_unique_name();
  inline void set_allocated_non_unique_name(::std::string* non_unique_name);

  // optional int64 sync_timestamp = 9;
  inline bool has_sync_timestamp() const;
  inline void clear_sync_timestamp();
  static const int kSyncTimestampFieldNumber = 9;
  inline ::google::protobuf::int64 sync_timestamp() const;
  inline void set_sync_timestamp(::google::protobuf::int64 value);

  // optional string server_defined_unique_tag = 10;
  inline bool has_server_defined_unique_tag() const;
  inline void clear_server_defined_unique_tag();
  static const int kServerDefinedUniqueTagFieldNumber = 10;
  inline const ::std::string& server_defined_unique_tag() const;
  inline void set_server_defined_unique_tag(const ::std::string& value);
  inline void set_server_defined_unique_tag(const char* value);
  inline void set_server_defined_unique_tag(const char* value, size_t size);
  inline ::std::string* mutable_server_defined_unique_tag();
  inline ::std::string* release_server_defined_unique_tag();
  inline void set_allocated_server_defined_unique_tag(::std::string* server_defined_unique_tag);

  // optional group BookmarkData = 11 {
  inline bool has_bookmarkdata() const;
  inline void clear_bookmarkdata();
  static const int kBookmarkdataFieldNumber = 11;
  inline const ::sync_pb::SyncEntity_BookmarkData& bookmarkdata() const;
  inline ::sync_pb::SyncEntity_BookmarkData* mutable_bookmarkdata();
  inline ::sync_pb::SyncEntity_BookmarkData* release_bookmarkdata();
  inline void set_allocated_bookmarkdata(::sync_pb::SyncEntity_BookmarkData* bookmarkdata);

  // optional int64 position_in_parent = 15;
  inline bool has_position_in_parent() const;
  inline void clear_position_in_parent();
  static const int kPositionInParentFieldNumber = 15;
  inline ::google::protobuf::int64 position_in_parent() const;
  inline void set_position_in_parent(::google::protobuf::int64 value);

  // optional string insert_after_item_id = 16;
  inline bool has_insert_after_item_id() const;
  inline void clear_insert_after_item_id();
  static const int kInsertAfterItemIdFieldNumber = 16;
  inline const ::std::string& insert_after_item_id() const;
  inline void set_insert_after_item_id(const ::std::string& value);
  inline void set_insert_after_item_id(const char* value);
  inline void set_insert_after_item_id(const char* value, size_t size);
  inline ::std::string* mutable_insert_after_item_id();
  inline ::std::string* release_insert_after_item_id();
  inline void set_allocated_insert_after_item_id(::std::string* insert_after_item_id);

  // optional bool deleted = 18 [default = false];
  inline bool has_deleted() const;
  inline void clear_deleted();
  static const int kDeletedFieldNumber = 18;
  inline bool deleted() const;
  inline void set_deleted(bool value);

  // optional string originator_cache_guid = 19;
  inline bool has_originator_cache_guid() const;
  inline void clear_originator_cache_guid();
  static const int kOriginatorCacheGuidFieldNumber = 19;
  inline const ::std::string& originator_cache_guid() const;
  inline void set_originator_cache_guid(const ::std::string& value);
  inline void set_originator_cache_guid(const char* value);
  inline void set_originator_cache_guid(const char* value, size_t size);
  inline ::std::string* mutable_originator_cache_guid();
  inline ::std::string* release_originator_cache_guid();
  inline void set_allocated_originator_cache_guid(::std::string* originator_cache_guid);

  // optional string originator_client_item_id = 20;
  inline bool has_originator_client_item_id() const;
  inline void clear_originator_client_item_id();
  static const int kOriginatorClientItemIdFieldNumber = 20;
  inline const ::std::string& originator_client_item_id() const;
  inline void set_originator_client_item_id(const ::std::string& value);
  inline void set_originator_client_item_id(const char* value);
  inline void set_originator_client_item_id(const char* value, size_t size);
  inline ::std::string* mutable_originator_client_item_id();
  inline ::std::string* release_originator_client_item_id();
  inline void set_allocated_originator_client_item_id(::std::string* originator_client_item_id);

  // optional .sync_pb.EntitySpecifics specifics = 21;
  inline bool has_specifics() const;
  inline void clear_specifics();
  static const int kSpecificsFieldNumber = 21;
  inline const ::sync_pb::EntitySpecifics& specifics() const;
  inline ::sync_pb::EntitySpecifics* mutable_specifics();
  inline ::sync_pb::EntitySpecifics* release_specifics();
  inline void set_allocated_specifics(::sync_pb::EntitySpecifics* specifics);

  // optional bool folder = 22 [default = false];
  inline bool has_folder() const;
  inline void clear_folder();
  static const int kFolderFieldNumber = 22;
  inline bool folder() const;
  inline void set_folder(bool value);

  // optional string client_defined_unique_tag = 23;
  inline bool has_client_defined_unique_tag() const;
  inline void clear_client_defined_unique_tag();
  static const int kClientDefinedUniqueTagFieldNumber = 23;
  inline const ::std::string& client_defined_unique_tag() const;
  inline void set_client_defined_unique_tag(const ::std::string& value);
  inline void set_client_defined_unique_tag(const char* value);
  inline void set_client_defined_unique_tag(const char* value, size_t size);
  inline ::std::string* mutable_client_defined_unique_tag();
  inline ::std::string* release_client_defined_unique_tag();
  inline void set_allocated_client_defined_unique_tag(::std::string* client_defined_unique_tag);

  // optional bytes ordinal_in_parent = 24;
  inline bool has_ordinal_in_parent() const;
  inline void clear_ordinal_in_parent();
  static const int kOrdinalInParentFieldNumber = 24;
  inline const ::std::string& ordinal_in_parent() const;
  inline void set_ordinal_in_parent(const ::std::string& value);
  inline void set_ordinal_in_parent(const char* value);
  inline void set_ordinal_in_parent(const void* value, size_t size);
  inline ::std::string* mutable_ordinal_in_parent();
  inline ::std::string* release_ordinal_in_parent();
  inline void set_allocated_ordinal_in_parent(::std::string* ordinal_in_parent);

  // optional .sync_pb.UniquePosition unique_position = 25;
  inline bool has_unique_position() const;
  inline void clear_unique_position();
  static const int kUniquePositionFieldNumber = 25;
  inline const ::sync_pb::UniquePosition& unique_position() const;
  inline ::sync_pb::UniquePosition* mutable_unique_position();
  inline ::sync_pb::UniquePosition* release_unique_position();
  inline void set_allocated_unique_position(::sync_pb::UniquePosition* unique_position);

  // @@protoc_insertion_point(class_scope:sync_pb.SyncEntity)
 private:
  inline void set_has_id_string();
  inline void clear_has_id_string();
  inline void set_has_parent_id_string();
  inline void clear_has_parent_id_string();
  inline void set_has_old_parent_id();
  inline void clear_has_old_parent_id();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_mtime();
  inline void clear_has_mtime();
  inline void set_has_ctime();
  inline void clear_has_ctime();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_non_unique_name();
  inline void clear_has_non_unique_name();
  inline void set_has_sync_timestamp();
  inline void clear_has_sync_timestamp();
  inline void set_has_server_defined_unique_tag();
  inline void clear_has_server_defined_unique_tag();
  inline void set_has_bookmarkdata();
  inline void clear_has_bookmarkdata();
  inline void set_has_position_in_parent();
  inline void clear_has_position_in_parent();
  inline void set_has_insert_after_item_id();
  inline void clear_has_insert_after_item_id();
  inline void set_has_deleted();
  inline void clear_has_deleted();
  inline void set_has_originator_cache_guid();
  inline void clear_has_originator_cache_guid();
  inline void set_has_originator_client_item_id();
  inline void clear_has_originator_client_item_id();
  inline void set_has_specifics();
  inline void clear_has_specifics();
  inline void set_has_folder();
  inline void clear_has_folder();
  inline void set_has_client_defined_unique_tag();
  inline void clear_has_client_defined_unique_tag();
  inline void set_has_ordinal_in_parent();
  inline void clear_has_ordinal_in_parent();
  inline void set_has_unique_position();
  inline void clear_has_unique_position();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_string_;
  ::std::string* parent_id_string_;
  ::std::string* old_parent_id_;
  ::google::protobuf::int64 version_;
  ::google::protobuf::int64 mtime_;
  ::google::protobuf::int64 ctime_;
  ::std::string* name_;
  ::std::string* non_unique_name_;
  ::google::protobuf::int64 sync_timestamp_;
  ::std::string* server_defined_unique_tag_;
  ::sync_pb::SyncEntity_BookmarkData* bookmarkdata_;
  ::google::protobuf::int64 position_in_parent_;
  ::std::string* insert_after_item_id_;
  ::std::string* originator_cache_guid_;
  ::std::string* originator_client_item_id_;
  ::sync_pb::EntitySpecifics* specifics_;
  ::std::string* client_defined_unique_tag_;
  ::std::string* ordinal_in_parent_;
  ::sync_pb::UniquePosition* unique_position_;
  bool deleted_;
  bool folder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static SyncEntity* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ChromiumExtensionsActivity : public ::google::protobuf::MessageLite {
 public:
  ChromiumExtensionsActivity();
  virtual ~ChromiumExtensionsActivity();

  ChromiumExtensionsActivity(const ChromiumExtensionsActivity& from);

  inline ChromiumExtensionsActivity& operator=(const ChromiumExtensionsActivity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChromiumExtensionsActivity& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChromiumExtensionsActivity* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChromiumExtensionsActivity* other);

  // implements Message ----------------------------------------------

  ChromiumExtensionsActivity* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChromiumExtensionsActivity& from);
  void MergeFrom(const ChromiumExtensionsActivity& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string extension_id = 1;
  inline bool has_extension_id() const;
  inline void clear_extension_id();
  static const int kExtensionIdFieldNumber = 1;
  inline const ::std::string& extension_id() const;
  inline void set_extension_id(const ::std::string& value);
  inline void set_extension_id(const char* value);
  inline void set_extension_id(const char* value, size_t size);
  inline ::std::string* mutable_extension_id();
  inline ::std::string* release_extension_id();
  inline void set_allocated_extension_id(::std::string* extension_id);

  // optional uint32 bookmark_writes_since_last_commit = 2;
  inline bool has_bookmark_writes_since_last_commit() const;
  inline void clear_bookmark_writes_since_last_commit();
  static const int kBookmarkWritesSinceLastCommitFieldNumber = 2;
  inline ::google::protobuf::uint32 bookmark_writes_since_last_commit() const;
  inline void set_bookmark_writes_since_last_commit(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:sync_pb.ChromiumExtensionsActivity)
 private:
  inline void set_has_extension_id();
  inline void clear_has_extension_id();
  inline void set_has_bookmark_writes_since_last_commit();
  inline void clear_has_bookmark_writes_since_last_commit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extension_id_;
  ::google::protobuf::uint32 bookmark_writes_since_last_commit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ChromiumExtensionsActivity* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ClientConfigParams : public ::google::protobuf::MessageLite {
 public:
  ClientConfigParams();
  virtual ~ClientConfigParams();

  ClientConfigParams(const ClientConfigParams& from);

  inline ClientConfigParams& operator=(const ClientConfigParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientConfigParams& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientConfigParams* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientConfigParams* other);

  // implements Message ----------------------------------------------

  ClientConfigParams* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientConfigParams& from);
  void MergeFrom(const ClientConfigParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 enabled_type_ids = 1;
  inline int enabled_type_ids_size() const;
  inline void clear_enabled_type_ids();
  static const int kEnabledTypeIdsFieldNumber = 1;
  inline ::google::protobuf::int32 enabled_type_ids(int index) const;
  inline void set_enabled_type_ids(int index, ::google::protobuf::int32 value);
  inline void add_enabled_type_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      enabled_type_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_enabled_type_ids();

  // optional bool tabs_datatype_enabled = 2;
  inline bool has_tabs_datatype_enabled() const;
  inline void clear_tabs_datatype_enabled();
  static const int kTabsDatatypeEnabledFieldNumber = 2;
  inline bool tabs_datatype_enabled() const;
  inline void set_tabs_datatype_enabled(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.ClientConfigParams)
 private:
  inline void set_has_tabs_datatype_enabled();
  inline void clear_has_tabs_datatype_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > enabled_type_ids_;
  bool tabs_datatype_enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ClientConfigParams* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT CommitMessage : public ::google::protobuf::MessageLite {
 public:
  CommitMessage();
  virtual ~CommitMessage();

  CommitMessage(const CommitMessage& from);

  inline CommitMessage& operator=(const CommitMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommitMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitMessage* other);

  // implements Message ----------------------------------------------

  CommitMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitMessage& from);
  void MergeFrom(const CommitMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sync_pb.SyncEntity entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::sync_pb::SyncEntity& entries(int index) const;
  inline ::sync_pb::SyncEntity* mutable_entries(int index);
  inline ::sync_pb::SyncEntity* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >*
      mutable_entries();

  // optional string cache_guid = 2;
  inline bool has_cache_guid() const;
  inline void clear_cache_guid();
  static const int kCacheGuidFieldNumber = 2;
  inline const ::std::string& cache_guid() const;
  inline void set_cache_guid(const ::std::string& value);
  inline void set_cache_guid(const char* value);
  inline void set_cache_guid(const char* value, size_t size);
  inline ::std::string* mutable_cache_guid();
  inline ::std::string* release_cache_guid();
  inline void set_allocated_cache_guid(::std::string* cache_guid);

  // repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
  inline int extensions_activity_size() const;
  inline void clear_extensions_activity();
  static const int kExtensionsActivityFieldNumber = 3;
  inline const ::sync_pb::ChromiumExtensionsActivity& extensions_activity(int index) const;
  inline ::sync_pb::ChromiumExtensionsActivity* mutable_extensions_activity(int index);
  inline ::sync_pb::ChromiumExtensionsActivity* add_extensions_activity();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::ChromiumExtensionsActivity >&
      extensions_activity() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::ChromiumExtensionsActivity >*
      mutable_extensions_activity();

  // optional .sync_pb.ClientConfigParams config_params = 4;
  inline bool has_config_params() const;
  inline void clear_config_params();
  static const int kConfigParamsFieldNumber = 4;
  inline const ::sync_pb::ClientConfigParams& config_params() const;
  inline ::sync_pb::ClientConfigParams* mutable_config_params();
  inline ::sync_pb::ClientConfigParams* release_config_params();
  inline void set_allocated_config_params(::sync_pb::ClientConfigParams* config_params);

  // @@protoc_insertion_point(class_scope:sync_pb.CommitMessage)
 private:
  inline void set_has_cache_guid();
  inline void clear_has_cache_guid();
  inline void set_has_config_params();
  inline void clear_has_config_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity > entries_;
  ::std::string* cache_guid_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::ChromiumExtensionsActivity > extensions_activity_;
  ::sync_pb::ClientConfigParams* config_params_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static CommitMessage* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT GetUpdateTriggers : public ::google::protobuf::MessageLite {
 public:
  GetUpdateTriggers();
  virtual ~GetUpdateTriggers();

  GetUpdateTriggers(const GetUpdateTriggers& from);

  inline GetUpdateTriggers& operator=(const GetUpdateTriggers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUpdateTriggers& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUpdateTriggers* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUpdateTriggers* other);

  // implements Message ----------------------------------------------

  GetUpdateTriggers* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUpdateTriggers& from);
  void MergeFrom(const GetUpdateTriggers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string notification_hint = 1;
  inline int notification_hint_size() const;
  inline void clear_notification_hint();
  static const int kNotificationHintFieldNumber = 1;
  inline const ::std::string& notification_hint(int index) const;
  inline ::std::string* mutable_notification_hint(int index);
  inline void set_notification_hint(int index, const ::std::string& value);
  inline void set_notification_hint(int index, const char* value);
  inline void set_notification_hint(int index, const char* value, size_t size);
  inline ::std::string* add_notification_hint();
  inline void add_notification_hint(const ::std::string& value);
  inline void add_notification_hint(const char* value);
  inline void add_notification_hint(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& notification_hint() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_notification_hint();

  // optional bool client_dropped_hints = 2;
  inline bool has_client_dropped_hints() const;
  inline void clear_client_dropped_hints();
  static const int kClientDroppedHintsFieldNumber = 2;
  inline bool client_dropped_hints() const;
  inline void set_client_dropped_hints(bool value);

  // optional bool invalidations_out_of_sync = 3;
  inline bool has_invalidations_out_of_sync() const;
  inline void clear_invalidations_out_of_sync();
  static const int kInvalidationsOutOfSyncFieldNumber = 3;
  inline bool invalidations_out_of_sync() const;
  inline void set_invalidations_out_of_sync(bool value);

  // optional int64 local_modification_nudges = 4;
  inline bool has_local_modification_nudges() const;
  inline void clear_local_modification_nudges();
  static const int kLocalModificationNudgesFieldNumber = 4;
  inline ::google::protobuf::int64 local_modification_nudges() const;
  inline void set_local_modification_nudges(::google::protobuf::int64 value);

  // optional int64 datatype_refresh_nudges = 5;
  inline bool has_datatype_refresh_nudges() const;
  inline void clear_datatype_refresh_nudges();
  static const int kDatatypeRefreshNudgesFieldNumber = 5;
  inline ::google::protobuf::int64 datatype_refresh_nudges() const;
  inline void set_datatype_refresh_nudges(::google::protobuf::int64 value);

  // optional bool server_dropped_hints = 6;
  inline bool has_server_dropped_hints() const;
  inline void clear_server_dropped_hints();
  static const int kServerDroppedHintsFieldNumber = 6;
  inline bool server_dropped_hints() const;
  inline void set_server_dropped_hints(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.GetUpdateTriggers)
 private:
  inline void set_has_client_dropped_hints();
  inline void clear_has_client_dropped_hints();
  inline void set_has_invalidations_out_of_sync();
  inline void clear_has_invalidations_out_of_sync();
  inline void set_has_local_modification_nudges();
  inline void clear_has_local_modification_nudges();
  inline void set_has_datatype_refresh_nudges();
  inline void clear_has_datatype_refresh_nudges();
  inline void set_has_server_dropped_hints();
  inline void clear_has_server_dropped_hints();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> notification_hint_;
  ::google::protobuf::int64 local_modification_nudges_;
  ::google::protobuf::int64 datatype_refresh_nudges_;
  bool client_dropped_hints_;
  bool invalidations_out_of_sync_;
  bool server_dropped_hints_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static GetUpdateTriggers* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT GarbageCollectionDirective : public ::google::protobuf::MessageLite {
 public:
  GarbageCollectionDirective();
  virtual ~GarbageCollectionDirective();

  GarbageCollectionDirective(const GarbageCollectionDirective& from);

  inline GarbageCollectionDirective& operator=(const GarbageCollectionDirective& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GarbageCollectionDirective& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GarbageCollectionDirective* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GarbageCollectionDirective* other);

  // implements Message ----------------------------------------------

  GarbageCollectionDirective* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GarbageCollectionDirective& from);
  void MergeFrom(const GarbageCollectionDirective& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef GarbageCollectionDirective_Type Type;
  static const Type UNKNOWN = GarbageCollectionDirective_Type_UNKNOWN;
  static const Type VERSION_WATERMARK = GarbageCollectionDirective_Type_VERSION_WATERMARK;
  static const Type AGE_WATERMARK = GarbageCollectionDirective_Type_AGE_WATERMARK;
  static const Type MAX_ITEM_COUNT = GarbageCollectionDirective_Type_MAX_ITEM_COUNT;
  static inline bool Type_IsValid(int value) {
    return GarbageCollectionDirective_Type_IsValid(value);
  }
  static const Type Type_MIN =
    GarbageCollectionDirective_Type_Type_MIN;
  static const Type Type_MAX =
    GarbageCollectionDirective_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    GarbageCollectionDirective_Type_Type_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .sync_pb.GarbageCollectionDirective.Type type = 1 [default = UNKNOWN];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::sync_pb::GarbageCollectionDirective_Type type() const;
  inline void set_type(::sync_pb::GarbageCollectionDirective_Type value);

  // optional int64 version_watermark = 2;
  inline bool has_version_watermark() const;
  inline void clear_version_watermark();
  static const int kVersionWatermarkFieldNumber = 2;
  inline ::google::protobuf::int64 version_watermark() const;
  inline void set_version_watermark(::google::protobuf::int64 value);

  // optional int32 age_watermark_in_days = 3;
  inline bool has_age_watermark_in_days() const;
  inline void clear_age_watermark_in_days();
  static const int kAgeWatermarkInDaysFieldNumber = 3;
  inline ::google::protobuf::int32 age_watermark_in_days() const;
  inline void set_age_watermark_in_days(::google::protobuf::int32 value);

  // optional int32 max_number_of_items = 4;
  inline bool has_max_number_of_items() const;
  inline void clear_max_number_of_items();
  static const int kMaxNumberOfItemsFieldNumber = 4;
  inline ::google::protobuf::int32 max_number_of_items() const;
  inline void set_max_number_of_items(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sync_pb.GarbageCollectionDirective)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_version_watermark();
  inline void clear_has_version_watermark();
  inline void set_has_age_watermark_in_days();
  inline void clear_has_age_watermark_in_days();
  inline void set_has_max_number_of_items();
  inline void clear_has_max_number_of_items();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 version_watermark_;
  int type_;
  ::google::protobuf::int32 age_watermark_in_days_;
  ::google::protobuf::int32 max_number_of_items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static GarbageCollectionDirective* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT DataTypeProgressMarker : public ::google::protobuf::MessageLite {
 public:
  DataTypeProgressMarker();
  virtual ~DataTypeProgressMarker();

  DataTypeProgressMarker(const DataTypeProgressMarker& from);

  inline DataTypeProgressMarker& operator=(const DataTypeProgressMarker& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const DataTypeProgressMarker& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const DataTypeProgressMarker* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(DataTypeProgressMarker* other);

  // implements Message ----------------------------------------------

  DataTypeProgressMarker* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const DataTypeProgressMarker& from);
  void MergeFrom(const DataTypeProgressMarker& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 data_type_id = 1;
  inline bool has_data_type_id() const;
  inline void clear_data_type_id();
  static const int kDataTypeIdFieldNumber = 1;
  inline ::google::protobuf::int32 data_type_id() const;
  inline void set_data_type_id(::google::protobuf::int32 value);

  // optional bytes token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const void* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional int64 timestamp_token_for_migration = 3;
  inline bool has_timestamp_token_for_migration() const;
  inline void clear_timestamp_token_for_migration();
  static const int kTimestampTokenForMigrationFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp_token_for_migration() const;
  inline void set_timestamp_token_for_migration(::google::protobuf::int64 value);

  // optional string notification_hint = 4;
  inline bool has_notification_hint() const;
  inline void clear_notification_hint();
  static const int kNotificationHintFieldNumber = 4;
  inline const ::std::string& notification_hint() const;
  inline void set_notification_hint(const ::std::string& value);
  inline void set_notification_hint(const char* value);
  inline void set_notification_hint(const char* value, size_t size);
  inline ::std::string* mutable_notification_hint();
  inline ::std::string* release_notification_hint();
  inline void set_allocated_notification_hint(::std::string* notification_hint);

  // optional .sync_pb.GetUpdateTriggers get_update_triggers = 5;
  inline bool has_get_update_triggers() const;
  inline void clear_get_update_triggers();
  static const int kGetUpdateTriggersFieldNumber = 5;
  inline const ::sync_pb::GetUpdateTriggers& get_update_triggers() const;
  inline ::sync_pb::GetUpdateTriggers* mutable_get_update_triggers();
  inline ::sync_pb::GetUpdateTriggers* release_get_update_triggers();
  inline void set_allocated_get_update_triggers(::sync_pb::GetUpdateTriggers* get_update_triggers);

  // optional .sync_pb.GarbageCollectionDirective gc_directive = 6;
  inline bool has_gc_directive() const;
  inline void clear_gc_directive();
  static const int kGcDirectiveFieldNumber = 6;
  inline const ::sync_pb::GarbageCollectionDirective& gc_directive() const;
  inline ::sync_pb::GarbageCollectionDirective* mutable_gc_directive();
  inline ::sync_pb::GarbageCollectionDirective* release_gc_directive();
  inline void set_allocated_gc_directive(::sync_pb::GarbageCollectionDirective* gc_directive);

  // @@protoc_insertion_point(class_scope:sync_pb.DataTypeProgressMarker)
 private:
  inline void set_has_data_type_id();
  inline void clear_has_data_type_id();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_timestamp_token_for_migration();
  inline void clear_has_timestamp_token_for_migration();
  inline void set_has_notification_hint();
  inline void clear_has_notification_hint();
  inline void set_has_get_update_triggers();
  inline void clear_has_get_update_triggers();
  inline void set_has_gc_directive();
  inline void clear_has_gc_directive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::google::protobuf::int64 timestamp_token_for_migration_;
  ::std::string* notification_hint_;
  ::sync_pb::GetUpdateTriggers* get_update_triggers_;
  ::sync_pb::GarbageCollectionDirective* gc_directive_;
  ::google::protobuf::int32 data_type_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static DataTypeProgressMarker* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT GetUpdatesMessage : public ::google::protobuf::MessageLite {
 public:
  GetUpdatesMessage();
  virtual ~GetUpdatesMessage();

  GetUpdatesMessage(const GetUpdatesMessage& from);

  inline GetUpdatesMessage& operator=(const GetUpdatesMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUpdatesMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUpdatesMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUpdatesMessage* other);

  // implements Message ----------------------------------------------

  GetUpdatesMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUpdatesMessage& from);
  void MergeFrom(const GetUpdatesMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 from_timestamp = 1;
  inline bool has_from_timestamp() const;
  inline void clear_from_timestamp();
  static const int kFromTimestampFieldNumber = 1;
  inline ::google::protobuf::int64 from_timestamp() const;
  inline void set_from_timestamp(::google::protobuf::int64 value);

  // optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
  inline bool has_caller_info() const;
  inline void clear_caller_info();
  static const int kCallerInfoFieldNumber = 2;
  inline const ::sync_pb::GetUpdatesCallerInfo& caller_info() const;
  inline ::sync_pb::GetUpdatesCallerInfo* mutable_caller_info();
  inline ::sync_pb::GetUpdatesCallerInfo* release_caller_info();
  inline void set_allocated_caller_info(::sync_pb::GetUpdatesCallerInfo* caller_info);

  // optional bool fetch_folders = 3 [default = true];
  inline bool has_fetch_folders() const;
  inline void clear_fetch_folders();
  static const int kFetchFoldersFieldNumber = 3;
  inline bool fetch_folders() const;
  inline void set_fetch_folders(bool value);

  // optional .sync_pb.EntitySpecifics requested_types = 4;
  inline bool has_requested_types() const;
  inline void clear_requested_types();
  static const int kRequestedTypesFieldNumber = 4;
  inline const ::sync_pb::EntitySpecifics& requested_types() const;
  inline ::sync_pb::EntitySpecifics* mutable_requested_types();
  inline ::sync_pb::EntitySpecifics* release_requested_types();
  inline void set_allocated_requested_types(::sync_pb::EntitySpecifics* requested_types);

  // optional int32 batch_size = 5;
  inline bool has_batch_size() const;
  inline void clear_batch_size();
  static const int kBatchSizeFieldNumber = 5;
  inline ::google::protobuf::int32 batch_size() const;
  inline void set_batch_size(::google::protobuf::int32 value);

  // repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
  inline int from_progress_marker_size() const;
  inline void clear_from_progress_marker();
  static const int kFromProgressMarkerFieldNumber = 6;
  inline const ::sync_pb::DataTypeProgressMarker& from_progress_marker(int index) const;
  inline ::sync_pb::DataTypeProgressMarker* mutable_from_progress_marker(int index);
  inline ::sync_pb::DataTypeProgressMarker* add_from_progress_marker();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >&
      from_progress_marker() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >*
      mutable_from_progress_marker();

  // optional bool streaming = 7 [default = false];
  inline bool has_streaming() const;
  inline void clear_streaming();
  static const int kStreamingFieldNumber = 7;
  inline bool streaming() const;
  inline void set_streaming(bool value);

  // optional bool need_encryption_key = 8 [default = false];
  inline bool has_need_encryption_key() const;
  inline void clear_need_encryption_key();
  static const int kNeedEncryptionKeyFieldNumber = 8;
  inline bool need_encryption_key() const;
  inline void set_need_encryption_key(bool value);

  // optional bool create_mobile_bookmarks_folder = 1000 [default = false];
  inline bool has_create_mobile_bookmarks_folder() const;
  inline void clear_create_mobile_bookmarks_folder();
  static const int kCreateMobileBookmarksFolderFieldNumber = 1000;
  inline bool create_mobile_bookmarks_folder() const;
  inline void set_create_mobile_bookmarks_folder(bool value);

  // optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
  inline bool has_get_updates_origin() const;
  inline void clear_get_updates_origin();
  static const int kGetUpdatesOriginFieldNumber = 9;
  inline ::sync_pb::SyncEnums_GetUpdatesOrigin get_updates_origin() const;
  inline void set_get_updates_origin(::sync_pb::SyncEnums_GetUpdatesOrigin value);

  // optional bool is_retry = 10 [default = false];
  inline bool has_is_retry() const;
  inline void clear_is_retry();
  static const int kIsRetryFieldNumber = 10;
  inline bool is_retry() const;
  inline void set_is_retry(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.GetUpdatesMessage)
 private:
  inline void set_has_from_timestamp();
  inline void clear_has_from_timestamp();
  inline void set_has_caller_info();
  inline void clear_has_caller_info();
  inline void set_has_fetch_folders();
  inline void clear_has_fetch_folders();
  inline void set_has_requested_types();
  inline void clear_has_requested_types();
  inline void set_has_batch_size();
  inline void clear_has_batch_size();
  inline void set_has_streaming();
  inline void clear_has_streaming();
  inline void set_has_need_encryption_key();
  inline void clear_has_need_encryption_key();
  inline void set_has_create_mobile_bookmarks_folder();
  inline void clear_has_create_mobile_bookmarks_folder();
  inline void set_has_get_updates_origin();
  inline void clear_has_get_updates_origin();
  inline void set_has_is_retry();
  inline void clear_has_is_retry();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 from_timestamp_;
  ::sync_pb::GetUpdatesCallerInfo* caller_info_;
  ::sync_pb::EntitySpecifics* requested_types_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker > from_progress_marker_;
  ::google::protobuf::int32 batch_size_;
  bool fetch_folders_;
  bool streaming_;
  bool need_encryption_key_;
  bool create_mobile_bookmarks_folder_;
  int get_updates_origin_;
  bool is_retry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static GetUpdatesMessage* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT AuthenticateMessage : public ::google::protobuf::MessageLite {
 public:
  AuthenticateMessage();
  virtual ~AuthenticateMessage();

  AuthenticateMessage(const AuthenticateMessage& from);

  inline AuthenticateMessage& operator=(const AuthenticateMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateMessage* other);

  // implements Message ----------------------------------------------

  AuthenticateMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateMessage& from);
  void MergeFrom(const AuthenticateMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string auth_token = 1;
  inline bool has_auth_token() const;
  inline void clear_auth_token();
  static const int kAuthTokenFieldNumber = 1;
  inline const ::std::string& auth_token() const;
  inline void set_auth_token(const ::std::string& value);
  inline void set_auth_token(const char* value);
  inline void set_auth_token(const char* value, size_t size);
  inline ::std::string* mutable_auth_token();
  inline ::std::string* release_auth_token();
  inline void set_allocated_auth_token(::std::string* auth_token);

  // @@protoc_insertion_point(class_scope:sync_pb.AuthenticateMessage)
 private:
  inline void set_has_auth_token();
  inline void clear_has_auth_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* auth_token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateMessage* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ClearUserDataMessage : public ::google::protobuf::MessageLite {
 public:
  ClearUserDataMessage();
  virtual ~ClearUserDataMessage();

  ClearUserDataMessage(const ClearUserDataMessage& from);

  inline ClearUserDataMessage& operator=(const ClearUserDataMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClearUserDataMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClearUserDataMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClearUserDataMessage* other);

  // implements Message ----------------------------------------------

  ClearUserDataMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClearUserDataMessage& from);
  void MergeFrom(const ClearUserDataMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sync_pb.ClearUserDataMessage)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ClearUserDataMessage* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ClearUserDataResponse : public ::google::protobuf::MessageLite {
 public:
  ClearUserDataResponse();
  virtual ~ClearUserDataResponse();

  ClearUserDataResponse(const ClearUserDataResponse& from);

  inline ClearUserDataResponse& operator=(const ClearUserDataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClearUserDataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClearUserDataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClearUserDataResponse* other);

  // implements Message ----------------------------------------------

  ClearUserDataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClearUserDataResponse& from);
  void MergeFrom(const ClearUserDataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:sync_pb.ClearUserDataResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ClearUserDataResponse* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ChipBag : public ::google::protobuf::MessageLite {
 public:
  ChipBag();
  virtual ~ChipBag();

  ChipBag(const ChipBag& from);

  inline ChipBag& operator=(const ChipBag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ChipBag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ChipBag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ChipBag* other);

  // implements Message ----------------------------------------------

  ChipBag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ChipBag& from);
  void MergeFrom(const ChipBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes server_chips = 1;
  inline bool has_server_chips() const;
  inline void clear_server_chips();
  static const int kServerChipsFieldNumber = 1;
  inline const ::std::string& server_chips() const;
  inline void set_server_chips(const ::std::string& value);
  inline void set_server_chips(const char* value);
  inline void set_server_chips(const void* value, size_t size);
  inline ::std::string* mutable_server_chips();
  inline ::std::string* release_server_chips();
  inline void set_allocated_server_chips(::std::string* server_chips);

  // @@protoc_insertion_point(class_scope:sync_pb.ChipBag)
 private:
  inline void set_has_server_chips();
  inline void clear_has_server_chips();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* server_chips_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ChipBag* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ClientStatus : public ::google::protobuf::MessageLite {
 public:
  ClientStatus();
  virtual ~ClientStatus();

  ClientStatus(const ClientStatus& from);

  inline ClientStatus& operator=(const ClientStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientStatus& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientStatus* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientStatus* other);

  // implements Message ----------------------------------------------

  ClientStatus* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientStatus& from);
  void MergeFrom(const ClientStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool hierarchy_conflict_detected = 1;
  inline bool has_hierarchy_conflict_detected() const;
  inline void clear_hierarchy_conflict_detected();
  static const int kHierarchyConflictDetectedFieldNumber = 1;
  inline bool hierarchy_conflict_detected() const;
  inline void set_hierarchy_conflict_detected(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.ClientStatus)
 private:
  inline void set_has_hierarchy_conflict_detected();
  inline void clear_has_hierarchy_conflict_detected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool hierarchy_conflict_detected_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ClientStatus* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ClientToServerMessage : public ::google::protobuf::MessageLite {
 public:
  ClientToServerMessage();
  virtual ~ClientToServerMessage();

  ClientToServerMessage(const ClientToServerMessage& from);

  inline ClientToServerMessage& operator=(const ClientToServerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientToServerMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientToServerMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientToServerMessage* other);

  // implements Message ----------------------------------------------

  ClientToServerMessage* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientToServerMessage& from);
  void MergeFrom(const ClientToServerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientToServerMessage_Contents Contents;
  static const Contents COMMIT = ClientToServerMessage_Contents_COMMIT;
  static const Contents GET_UPDATES = ClientToServerMessage_Contents_GET_UPDATES;
  static const Contents AUTHENTICATE = ClientToServerMessage_Contents_AUTHENTICATE;
  static const Contents CLEAR_DATA = ClientToServerMessage_Contents_CLEAR_DATA;
  static inline bool Contents_IsValid(int value) {
    return ClientToServerMessage_Contents_IsValid(value);
  }
  static const Contents Contents_MIN =
    ClientToServerMessage_Contents_Contents_MIN;
  static const Contents Contents_MAX =
    ClientToServerMessage_Contents_Contents_MAX;
  static const int Contents_ARRAYSIZE =
    ClientToServerMessage_Contents_Contents_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // required string share = 1;
  inline bool has_share() const;
  inline void clear_share();
  static const int kShareFieldNumber = 1;
  inline const ::std::string& share() const;
  inline void set_share(const ::std::string& value);
  inline void set_share(const char* value);
  inline void set_share(const char* value, size_t size);
  inline ::std::string* mutable_share();
  inline ::std::string* release_share();
  inline void set_allocated_share(::std::string* share);

  // optional int32 protocol_version = 2 [default = 31];
  inline bool has_protocol_version() const;
  inline void clear_protocol_version();
  static const int kProtocolVersionFieldNumber = 2;
  inline ::google::protobuf::int32 protocol_version() const;
  inline void set_protocol_version(::google::protobuf::int32 value);

  // required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
  inline bool has_message_contents() const;
  inline void clear_message_contents();
  static const int kMessageContentsFieldNumber = 3;
  inline ::sync_pb::ClientToServerMessage_Contents message_contents() const;
  inline void set_message_contents(::sync_pb::ClientToServerMessage_Contents value);

  // optional .sync_pb.CommitMessage commit = 4;
  inline bool has_commit() const;
  inline void clear_commit();
  static const int kCommitFieldNumber = 4;
  inline const ::sync_pb::CommitMessage& commit() const;
  inline ::sync_pb::CommitMessage* mutable_commit();
  inline ::sync_pb::CommitMessage* release_commit();
  inline void set_allocated_commit(::sync_pb::CommitMessage* commit);

  // optional .sync_pb.GetUpdatesMessage get_updates = 5;
  inline bool has_get_updates() const;
  inline void clear_get_updates();
  static const int kGetUpdatesFieldNumber = 5;
  inline const ::sync_pb::GetUpdatesMessage& get_updates() const;
  inline ::sync_pb::GetUpdatesMessage* mutable_get_updates();
  inline ::sync_pb::GetUpdatesMessage* release_get_updates();
  inline void set_allocated_get_updates(::sync_pb::GetUpdatesMessage* get_updates);

  // optional .sync_pb.AuthenticateMessage authenticate = 6;
  inline bool has_authenticate() const;
  inline void clear_authenticate();
  static const int kAuthenticateFieldNumber = 6;
  inline const ::sync_pb::AuthenticateMessage& authenticate() const;
  inline ::sync_pb::AuthenticateMessage* mutable_authenticate();
  inline ::sync_pb::AuthenticateMessage* release_authenticate();
  inline void set_allocated_authenticate(::sync_pb::AuthenticateMessage* authenticate);

  // optional .sync_pb.ClearUserDataMessage clear_user_data = 9;
  inline bool has_clear_user_data() const;
  inline void clear_clear_user_data();
  static const int kClearUserDataFieldNumber = 9;
  inline const ::sync_pb::ClearUserDataMessage& clear_user_data() const;
  inline ::sync_pb::ClearUserDataMessage* mutable_clear_user_data();
  inline ::sync_pb::ClearUserDataMessage* release_clear_user_data();
  inline void set_allocated_clear_user_data(::sync_pb::ClearUserDataMessage* clear_user_data);

  // optional string store_birthday = 7;
  inline bool has_store_birthday() const;
  inline void clear_store_birthday();
  static const int kStoreBirthdayFieldNumber = 7;
  inline const ::std::string& store_birthday() const;
  inline void set_store_birthday(const ::std::string& value);
  inline void set_store_birthday(const char* value);
  inline void set_store_birthday(const char* value, size_t size);
  inline ::std::string* mutable_store_birthday();
  inline ::std::string* release_store_birthday();
  inline void set_allocated_store_birthday(::std::string* store_birthday);

  // optional bool sync_problem_detected = 8 [default = false];
  inline bool has_sync_problem_detected() const;
  inline void clear_sync_problem_detected();
  static const int kSyncProblemDetectedFieldNumber = 8;
  inline bool sync_problem_detected() const;
  inline void set_sync_problem_detected(bool value);

  // optional .sync_pb.DebugInfo debug_info = 10;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 10;
  inline const ::sync_pb::DebugInfo& debug_info() const;
  inline ::sync_pb::DebugInfo* mutable_debug_info();
  inline ::sync_pb::DebugInfo* release_debug_info();
  inline void set_allocated_debug_info(::sync_pb::DebugInfo* debug_info);

  // optional .sync_pb.ChipBag bag_of_chips = 11;
  inline bool has_bag_of_chips() const;
  inline void clear_bag_of_chips();
  static const int kBagOfChipsFieldNumber = 11;
  inline const ::sync_pb::ChipBag& bag_of_chips() const;
  inline ::sync_pb::ChipBag* mutable_bag_of_chips();
  inline ::sync_pb::ChipBag* release_bag_of_chips();
  inline void set_allocated_bag_of_chips(::sync_pb::ChipBag* bag_of_chips);

  // optional string api_key = 12;
  inline bool has_api_key() const;
  inline void clear_api_key();
  static const int kApiKeyFieldNumber = 12;
  inline const ::std::string& api_key() const;
  inline void set_api_key(const ::std::string& value);
  inline void set_api_key(const char* value);
  inline void set_api_key(const char* value, size_t size);
  inline ::std::string* mutable_api_key();
  inline ::std::string* release_api_key();
  inline void set_allocated_api_key(::std::string* api_key);

  // optional .sync_pb.ClientStatus client_status = 13;
  inline bool has_client_status() const;
  inline void clear_client_status();
  static const int kClientStatusFieldNumber = 13;
  inline const ::sync_pb::ClientStatus& client_status() const;
  inline ::sync_pb::ClientStatus* mutable_client_status();
  inline ::sync_pb::ClientStatus* release_client_status();
  inline void set_allocated_client_status(::sync_pb::ClientStatus* client_status);

  // optional string invalidator_client_id = 14;
  inline bool has_invalidator_client_id() const;
  inline void clear_invalidator_client_id();
  static const int kInvalidatorClientIdFieldNumber = 14;
  inline const ::std::string& invalidator_client_id() const;
  inline void set_invalidator_client_id(const ::std::string& value);
  inline void set_invalidator_client_id(const char* value);
  inline void set_invalidator_client_id(const char* value, size_t size);
  inline ::std::string* mutable_invalidator_client_id();
  inline ::std::string* release_invalidator_client_id();
  inline void set_allocated_invalidator_client_id(::std::string* invalidator_client_id);

  // @@protoc_insertion_point(class_scope:sync_pb.ClientToServerMessage)
 private:
  inline void set_has_share();
  inline void clear_has_share();
  inline void set_has_protocol_version();
  inline void clear_has_protocol_version();
  inline void set_has_message_contents();
  inline void clear_has_message_contents();
  inline void set_has_commit();
  inline void clear_has_commit();
  inline void set_has_get_updates();
  inline void clear_has_get_updates();
  inline void set_has_authenticate();
  inline void clear_has_authenticate();
  inline void set_has_clear_user_data();
  inline void clear_has_clear_user_data();
  inline void set_has_store_birthday();
  inline void clear_has_store_birthday();
  inline void set_has_sync_problem_detected();
  inline void clear_has_sync_problem_detected();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  inline void set_has_bag_of_chips();
  inline void clear_has_bag_of_chips();
  inline void set_has_api_key();
  inline void clear_has_api_key();
  inline void set_has_client_status();
  inline void clear_has_client_status();
  inline void set_has_invalidator_client_id();
  inline void clear_has_invalidator_client_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* share_;
  ::google::protobuf::int32 protocol_version_;
  int message_contents_;
  ::sync_pb::CommitMessage* commit_;
  ::sync_pb::GetUpdatesMessage* get_updates_;
  ::sync_pb::AuthenticateMessage* authenticate_;
  ::sync_pb::ClearUserDataMessage* clear_user_data_;
  ::std::string* store_birthday_;
  ::sync_pb::DebugInfo* debug_info_;
  ::sync_pb::ChipBag* bag_of_chips_;
  ::std::string* api_key_;
  ::sync_pb::ClientStatus* client_status_;
  ::std::string* invalidator_client_id_;
  bool sync_problem_detected_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ClientToServerMessage* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT GetCrashInfoRequest : public ::google::protobuf::MessageLite {
 public:
  GetCrashInfoRequest();
  virtual ~GetCrashInfoRequest();

  GetCrashInfoRequest(const GetCrashInfoRequest& from);

  inline GetCrashInfoRequest& operator=(const GetCrashInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCrashInfoRequest& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCrashInfoRequest* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCrashInfoRequest* other);

  // implements Message ----------------------------------------------

  GetCrashInfoRequest* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCrashInfoRequest& from);
  void MergeFrom(const GetCrashInfoRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string crash_id = 1;
  inline bool has_crash_id() const;
  inline void clear_crash_id();
  static const int kCrashIdFieldNumber = 1;
  inline const ::std::string& crash_id() const;
  inline void set_crash_id(const ::std::string& value);
  inline void set_crash_id(const char* value);
  inline void set_crash_id(const char* value, size_t size);
  inline ::std::string* mutable_crash_id();
  inline ::std::string* release_crash_id();
  inline void set_allocated_crash_id(::std::string* crash_id);

  // optional int64 crash_time_millis = 2;
  inline bool has_crash_time_millis() const;
  inline void clear_crash_time_millis();
  static const int kCrashTimeMillisFieldNumber = 2;
  inline ::google::protobuf::int64 crash_time_millis() const;
  inline void set_crash_time_millis(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sync_pb.GetCrashInfoRequest)
 private:
  inline void set_has_crash_id();
  inline void clear_has_crash_id();
  inline void set_has_crash_time_millis();
  inline void clear_has_crash_time_millis();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* crash_id_;
  ::google::protobuf::int64 crash_time_millis_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static GetCrashInfoRequest* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT GetCrashInfoResponse : public ::google::protobuf::MessageLite {
 public:
  GetCrashInfoResponse();
  virtual ~GetCrashInfoResponse();

  GetCrashInfoResponse(const GetCrashInfoResponse& from);

  inline GetCrashInfoResponse& operator=(const GetCrashInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetCrashInfoResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetCrashInfoResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetCrashInfoResponse* other);

  // implements Message ----------------------------------------------

  GetCrashInfoResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetCrashInfoResponse& from);
  void MergeFrom(const GetCrashInfoResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string stack_id = 1;
  inline bool has_stack_id() const;
  inline void clear_stack_id();
  static const int kStackIdFieldNumber = 1;
  inline const ::std::string& stack_id() const;
  inline void set_stack_id(const ::std::string& value);
  inline void set_stack_id(const char* value);
  inline void set_stack_id(const char* value, size_t size);
  inline ::std::string* mutable_stack_id();
  inline ::std::string* release_stack_id();
  inline void set_allocated_stack_id(::std::string* stack_id);

  // optional int64 crash_time_millis = 2;
  inline bool has_crash_time_millis() const;
  inline void clear_crash_time_millis();
  static const int kCrashTimeMillisFieldNumber = 2;
  inline ::google::protobuf::int64 crash_time_millis() const;
  inline void set_crash_time_millis(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sync_pb.GetCrashInfoResponse)
 private:
  inline void set_has_stack_id();
  inline void clear_has_stack_id();
  inline void set_has_crash_time_millis();
  inline void clear_has_crash_time_millis();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stack_id_;
  ::google::protobuf::int64 crash_time_millis_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static GetCrashInfoResponse* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT CommitResponse_EntryResponse : public ::google::protobuf::MessageLite {
 public:
  CommitResponse_EntryResponse();
  virtual ~CommitResponse_EntryResponse();

  CommitResponse_EntryResponse(const CommitResponse_EntryResponse& from);

  inline CommitResponse_EntryResponse& operator=(const CommitResponse_EntryResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommitResponse_EntryResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitResponse_EntryResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitResponse_EntryResponse* other);

  // implements Message ----------------------------------------------

  CommitResponse_EntryResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitResponse_EntryResponse& from);
  void MergeFrom(const CommitResponse_EntryResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .sync_pb.CommitResponse.ResponseType response_type = 2;
  inline bool has_response_type() const;
  inline void clear_response_type();
  static const int kResponseTypeFieldNumber = 2;
  inline ::sync_pb::CommitResponse_ResponseType response_type() const;
  inline void set_response_type(::sync_pb::CommitResponse_ResponseType value);

  // optional string id_string = 3;
  inline bool has_id_string() const;
  inline void clear_id_string();
  static const int kIdStringFieldNumber = 3;
  inline const ::std::string& id_string() const;
  inline void set_id_string(const ::std::string& value);
  inline void set_id_string(const char* value);
  inline void set_id_string(const char* value, size_t size);
  inline ::std::string* mutable_id_string();
  inline ::std::string* release_id_string();
  inline void set_allocated_id_string(::std::string* id_string);

  // optional string parent_id_string = 4;
  inline bool has_parent_id_string() const;
  inline void clear_parent_id_string();
  static const int kParentIdStringFieldNumber = 4;
  inline const ::std::string& parent_id_string() const;
  inline void set_parent_id_string(const ::std::string& value);
  inline void set_parent_id_string(const char* value);
  inline void set_parent_id_string(const char* value, size_t size);
  inline ::std::string* mutable_parent_id_string();
  inline ::std::string* release_parent_id_string();
  inline void set_allocated_parent_id_string(::std::string* parent_id_string);

  // optional int64 position_in_parent = 5;
  inline bool has_position_in_parent() const;
  inline void clear_position_in_parent();
  static const int kPositionInParentFieldNumber = 5;
  inline ::google::protobuf::int64 position_in_parent() const;
  inline void set_position_in_parent(::google::protobuf::int64 value);

  // optional int64 version = 6;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 6;
  inline ::google::protobuf::int64 version() const;
  inline void set_version(::google::protobuf::int64 value);

  // optional string name = 7;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 7;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string non_unique_name = 8;
  inline bool has_non_unique_name() const;
  inline void clear_non_unique_name();
  static const int kNonUniqueNameFieldNumber = 8;
  inline const ::std::string& non_unique_name() const;
  inline void set_non_unique_name(const ::std::string& value);
  inline void set_non_unique_name(const char* value);
  inline void set_non_unique_name(const char* value, size_t size);
  inline ::std::string* mutable_non_unique_name();
  inline ::std::string* release_non_unique_name();
  inline void set_allocated_non_unique_name(::std::string* non_unique_name);

  // optional string error_message = 9;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 9;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // optional int64 mtime = 10;
  inline bool has_mtime() const;
  inline void clear_mtime();
  static const int kMtimeFieldNumber = 10;
  inline ::google::protobuf::int64 mtime() const;
  inline void set_mtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:sync_pb.CommitResponse.EntryResponse)
 private:
  inline void set_has_response_type();
  inline void clear_has_response_type();
  inline void set_has_id_string();
  inline void clear_has_id_string();
  inline void set_has_parent_id_string();
  inline void clear_has_parent_id_string();
  inline void set_has_position_in_parent();
  inline void clear_has_position_in_parent();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_non_unique_name();
  inline void clear_has_non_unique_name();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_mtime();
  inline void clear_has_mtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_string_;
  ::std::string* parent_id_string_;
  ::google::protobuf::int64 position_in_parent_;
  ::google::protobuf::int64 version_;
  ::std::string* name_;
  ::std::string* non_unique_name_;
  ::std::string* error_message_;
  ::google::protobuf::int64 mtime_;
  int response_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static CommitResponse_EntryResponse* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT CommitResponse : public ::google::protobuf::MessageLite {
 public:
  CommitResponse();
  virtual ~CommitResponse();

  CommitResponse(const CommitResponse& from);

  inline CommitResponse& operator=(const CommitResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CommitResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CommitResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CommitResponse* other);

  // implements Message ----------------------------------------------

  CommitResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CommitResponse& from);
  void MergeFrom(const CommitResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CommitResponse_EntryResponse EntryResponse;

  typedef CommitResponse_ResponseType ResponseType;
  static const ResponseType SUCCESS = CommitResponse_ResponseType_SUCCESS;
  static const ResponseType CONFLICT = CommitResponse_ResponseType_CONFLICT;
  static const ResponseType RETRY = CommitResponse_ResponseType_RETRY;
  static const ResponseType INVALID_MESSAGE = CommitResponse_ResponseType_INVALID_MESSAGE;
  static const ResponseType OVER_QUOTA = CommitResponse_ResponseType_OVER_QUOTA;
  static const ResponseType TRANSIENT_ERROR = CommitResponse_ResponseType_TRANSIENT_ERROR;
  static inline bool ResponseType_IsValid(int value) {
    return CommitResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    CommitResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    CommitResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    CommitResponse_ResponseType_ResponseType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // repeated group EntryResponse = 1 {
  inline int entryresponse_size() const;
  inline void clear_entryresponse();
  static const int kEntryresponseFieldNumber = 1;
  inline const ::sync_pb::CommitResponse_EntryResponse& entryresponse(int index) const;
  inline ::sync_pb::CommitResponse_EntryResponse* mutable_entryresponse(int index);
  inline ::sync_pb::CommitResponse_EntryResponse* add_entryresponse();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::CommitResponse_EntryResponse >&
      entryresponse() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::CommitResponse_EntryResponse >*
      mutable_entryresponse();

  // @@protoc_insertion_point(class_scope:sync_pb.CommitResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sync_pb::CommitResponse_EntryResponse > entryresponse_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static CommitResponse* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT GetUpdatesResponse : public ::google::protobuf::MessageLite {
 public:
  GetUpdatesResponse();
  virtual ~GetUpdatesResponse();

  GetUpdatesResponse(const GetUpdatesResponse& from);

  inline GetUpdatesResponse& operator=(const GetUpdatesResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUpdatesResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUpdatesResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUpdatesResponse* other);

  // implements Message ----------------------------------------------

  GetUpdatesResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUpdatesResponse& from);
  void MergeFrom(const GetUpdatesResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sync_pb.SyncEntity entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::sync_pb::SyncEntity& entries(int index) const;
  inline ::sync_pb::SyncEntity* mutable_entries(int index);
  inline ::sync_pb::SyncEntity* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >*
      mutable_entries();

  // optional int64 new_timestamp = 2;
  inline bool has_new_timestamp() const;
  inline void clear_new_timestamp();
  static const int kNewTimestampFieldNumber = 2;
  inline ::google::protobuf::int64 new_timestamp() const;
  inline void set_new_timestamp(::google::protobuf::int64 value);

  // optional int64 deprecated_newest_timestamp = 3;
  inline bool has_deprecated_newest_timestamp() const;
  inline void clear_deprecated_newest_timestamp();
  static const int kDeprecatedNewestTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 deprecated_newest_timestamp() const;
  inline void set_deprecated_newest_timestamp(::google::protobuf::int64 value);

  // optional int64 changes_remaining = 4;
  inline bool has_changes_remaining() const;
  inline void clear_changes_remaining();
  static const int kChangesRemainingFieldNumber = 4;
  inline ::google::protobuf::int64 changes_remaining() const;
  inline void set_changes_remaining(::google::protobuf::int64 value);

  // repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
  inline int new_progress_marker_size() const;
  inline void clear_new_progress_marker();
  static const int kNewProgressMarkerFieldNumber = 5;
  inline const ::sync_pb::DataTypeProgressMarker& new_progress_marker(int index) const;
  inline ::sync_pb::DataTypeProgressMarker* mutable_new_progress_marker(int index);
  inline ::sync_pb::DataTypeProgressMarker* add_new_progress_marker();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >&
      new_progress_marker() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >*
      mutable_new_progress_marker();

  // repeated bytes encryption_keys = 6;
  inline int encryption_keys_size() const;
  inline void clear_encryption_keys();
  static const int kEncryptionKeysFieldNumber = 6;
  inline const ::std::string& encryption_keys(int index) const;
  inline ::std::string* mutable_encryption_keys(int index);
  inline void set_encryption_keys(int index, const ::std::string& value);
  inline void set_encryption_keys(int index, const char* value);
  inline void set_encryption_keys(int index, const void* value, size_t size);
  inline ::std::string* add_encryption_keys();
  inline void add_encryption_keys(const ::std::string& value);
  inline void add_encryption_keys(const char* value);
  inline void add_encryption_keys(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& encryption_keys() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_encryption_keys();

  // @@protoc_insertion_point(class_scope:sync_pb.GetUpdatesResponse)
 private:
  inline void set_has_new_timestamp();
  inline void clear_has_new_timestamp();
  inline void set_has_deprecated_newest_timestamp();
  inline void clear_has_deprecated_newest_timestamp();
  inline void set_has_changes_remaining();
  inline void clear_has_changes_remaining();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity > entries_;
  ::google::protobuf::int64 new_timestamp_;
  ::google::protobuf::int64 deprecated_newest_timestamp_;
  ::google::protobuf::int64 changes_remaining_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker > new_progress_marker_;
  ::google::protobuf::RepeatedPtrField< ::std::string> encryption_keys_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static GetUpdatesResponse* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT GetUpdatesMetadataResponse : public ::google::protobuf::MessageLite {
 public:
  GetUpdatesMetadataResponse();
  virtual ~GetUpdatesMetadataResponse();

  GetUpdatesMetadataResponse(const GetUpdatesMetadataResponse& from);

  inline GetUpdatesMetadataResponse& operator=(const GetUpdatesMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUpdatesMetadataResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUpdatesMetadataResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUpdatesMetadataResponse* other);

  // implements Message ----------------------------------------------

  GetUpdatesMetadataResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUpdatesMetadataResponse& from);
  void MergeFrom(const GetUpdatesMetadataResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 changes_remaining = 1;
  inline bool has_changes_remaining() const;
  inline void clear_changes_remaining();
  static const int kChangesRemainingFieldNumber = 1;
  inline ::google::protobuf::int64 changes_remaining() const;
  inline void set_changes_remaining(::google::protobuf::int64 value);

  // repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 2;
  inline int new_progress_marker_size() const;
  inline void clear_new_progress_marker();
  static const int kNewProgressMarkerFieldNumber = 2;
  inline const ::sync_pb::DataTypeProgressMarker& new_progress_marker(int index) const;
  inline ::sync_pb::DataTypeProgressMarker* mutable_new_progress_marker(int index);
  inline ::sync_pb::DataTypeProgressMarker* add_new_progress_marker();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >&
      new_progress_marker() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >*
      mutable_new_progress_marker();

  // @@protoc_insertion_point(class_scope:sync_pb.GetUpdatesMetadataResponse)
 private:
  inline void set_has_changes_remaining();
  inline void clear_has_changes_remaining();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 changes_remaining_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker > new_progress_marker_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static GetUpdatesMetadataResponse* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT GetUpdatesStreamingResponse : public ::google::protobuf::MessageLite {
 public:
  GetUpdatesStreamingResponse();
  virtual ~GetUpdatesStreamingResponse();

  GetUpdatesStreamingResponse(const GetUpdatesStreamingResponse& from);

  inline GetUpdatesStreamingResponse& operator=(const GetUpdatesStreamingResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GetUpdatesStreamingResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetUpdatesStreamingResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetUpdatesStreamingResponse* other);

  // implements Message ----------------------------------------------

  GetUpdatesStreamingResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetUpdatesStreamingResponse& from);
  void MergeFrom(const GetUpdatesStreamingResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sync_pb.SyncEntity entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::sync_pb::SyncEntity& entries(int index) const;
  inline ::sync_pb::SyncEntity* mutable_entries(int index);
  inline ::sync_pb::SyncEntity* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:sync_pb.GetUpdatesStreamingResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static GetUpdatesStreamingResponse* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT UserIdentification : public ::google::protobuf::MessageLite {
 public:
  UserIdentification();
  virtual ~UserIdentification();

  UserIdentification(const UserIdentification& from);

  inline UserIdentification& operator=(const UserIdentification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const UserIdentification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UserIdentification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UserIdentification* other);

  // implements Message ----------------------------------------------

  UserIdentification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UserIdentification& from);
  void MergeFrom(const UserIdentification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional string display_name = 2;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 2;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  inline void set_allocated_display_name(::std::string* display_name);

  // optional string obfuscated_id = 3;
  inline bool has_obfuscated_id() const;
  inline void clear_obfuscated_id();
  static const int kObfuscatedIdFieldNumber = 3;
  inline const ::std::string& obfuscated_id() const;
  inline void set_obfuscated_id(const ::std::string& value);
  inline void set_obfuscated_id(const char* value);
  inline void set_obfuscated_id(const char* value, size_t size);
  inline ::std::string* mutable_obfuscated_id();
  inline ::std::string* release_obfuscated_id();
  inline void set_allocated_obfuscated_id(::std::string* obfuscated_id);

  // @@protoc_insertion_point(class_scope:sync_pb.UserIdentification)
 private:
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_display_name();
  inline void clear_has_display_name();
  inline void set_has_obfuscated_id();
  inline void clear_has_obfuscated_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* email_;
  ::std::string* display_name_;
  ::std::string* obfuscated_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static UserIdentification* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT AuthenticateResponse : public ::google::protobuf::MessageLite {
 public:
  AuthenticateResponse();
  virtual ~AuthenticateResponse();

  AuthenticateResponse(const AuthenticateResponse& from);

  inline AuthenticateResponse& operator=(const AuthenticateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AuthenticateResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AuthenticateResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AuthenticateResponse* other);

  // implements Message ----------------------------------------------

  AuthenticateResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AuthenticateResponse& from);
  void MergeFrom(const AuthenticateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sync_pb.UserIdentification user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::sync_pb::UserIdentification& user() const;
  inline ::sync_pb::UserIdentification* mutable_user();
  inline ::sync_pb::UserIdentification* release_user();
  inline void set_allocated_user(::sync_pb::UserIdentification* user);

  // @@protoc_insertion_point(class_scope:sync_pb.AuthenticateResponse)
 private:
  inline void set_has_user();
  inline void clear_has_user();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::UserIdentification* user_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static AuthenticateResponse* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ThrottleParameters : public ::google::protobuf::MessageLite {
 public:
  ThrottleParameters();
  virtual ~ThrottleParameters();

  ThrottleParameters(const ThrottleParameters& from);

  inline ThrottleParameters& operator=(const ThrottleParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ThrottleParameters& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ThrottleParameters* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ThrottleParameters* other);

  // implements Message ----------------------------------------------

  ThrottleParameters* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ThrottleParameters& from);
  void MergeFrom(const ThrottleParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 min_measure_payload_size = 1;
  inline bool has_min_measure_payload_size() const;
  inline void clear_min_measure_payload_size();
  static const int kMinMeasurePayloadSizeFieldNumber = 1;
  inline ::google::protobuf::int32 min_measure_payload_size() const;
  inline void set_min_measure_payload_size(::google::protobuf::int32 value);

  // required double target_utilization = 2;
  inline bool has_target_utilization() const;
  inline void clear_target_utilization();
  static const int kTargetUtilizationFieldNumber = 2;
  inline double target_utilization() const;
  inline void set_target_utilization(double value);

  // required double measure_interval_max = 3;
  inline bool has_measure_interval_max() const;
  inline void clear_measure_interval_max();
  static const int kMeasureIntervalMaxFieldNumber = 3;
  inline double measure_interval_max() const;
  inline void set_measure_interval_max(double value);

  // required double measure_interval_min = 4;
  inline bool has_measure_interval_min() const;
  inline void clear_measure_interval_min();
  static const int kMeasureIntervalMinFieldNumber = 4;
  inline double measure_interval_min() const;
  inline void set_measure_interval_min(double value);

  // required double observation_window = 5;
  inline bool has_observation_window() const;
  inline void clear_observation_window();
  static const int kObservationWindowFieldNumber = 5;
  inline double observation_window() const;
  inline void set_observation_window(double value);

  // @@protoc_insertion_point(class_scope:sync_pb.ThrottleParameters)
 private:
  inline void set_has_min_measure_payload_size();
  inline void clear_has_min_measure_payload_size();
  inline void set_has_target_utilization();
  inline void clear_has_target_utilization();
  inline void set_has_measure_interval_max();
  inline void clear_has_measure_interval_max();
  inline void set_has_measure_interval_min();
  inline void clear_has_measure_interval_min();
  inline void set_has_observation_window();
  inline void clear_has_observation_window();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double target_utilization_;
  double measure_interval_max_;
  double measure_interval_min_;
  double observation_window_;
  ::google::protobuf::int32 min_measure_payload_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ThrottleParameters* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ClientToServerResponse_Error : public ::google::protobuf::MessageLite {
 public:
  ClientToServerResponse_Error();
  virtual ~ClientToServerResponse_Error();

  ClientToServerResponse_Error(const ClientToServerResponse_Error& from);

  inline ClientToServerResponse_Error& operator=(const ClientToServerResponse_Error& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientToServerResponse_Error& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientToServerResponse_Error* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientToServerResponse_Error* other);

  // implements Message ----------------------------------------------

  ClientToServerResponse_Error* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientToServerResponse_Error& from);
  void MergeFrom(const ClientToServerResponse_Error& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 1;
  inline ::sync_pb::SyncEnums_ErrorType error_type() const;
  inline void set_error_type(::sync_pb::SyncEnums_ErrorType value);

  // optional string error_description = 2;
  inline bool has_error_description() const;
  inline void clear_error_description();
  static const int kErrorDescriptionFieldNumber = 2;
  inline const ::std::string& error_description() const;
  inline void set_error_description(const ::std::string& value);
  inline void set_error_description(const char* value);
  inline void set_error_description(const char* value, size_t size);
  inline ::std::string* mutable_error_description();
  inline ::std::string* release_error_description();
  inline void set_allocated_error_description(::std::string* error_description);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 4;
  inline ::sync_pb::SyncEnums_Action action() const;
  inline void set_action(::sync_pb::SyncEnums_Action value);

  // repeated int32 error_data_type_ids = 5;
  inline int error_data_type_ids_size() const;
  inline void clear_error_data_type_ids();
  static const int kErrorDataTypeIdsFieldNumber = 5;
  inline ::google::protobuf::int32 error_data_type_ids(int index) const;
  inline void set_error_data_type_ids(int index, ::google::protobuf::int32 value);
  inline void add_error_data_type_ids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      error_data_type_ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_error_data_type_ids();

  // @@protoc_insertion_point(class_scope:sync_pb.ClientToServerResponse.Error)
 private:
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_error_description();
  inline void clear_has_error_description();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_action();
  inline void clear_has_action();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* error_description_;
  int error_type_;
  int action_;
  ::std::string* url_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > error_data_type_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ClientToServerResponse_Error* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ClientToServerResponse : public ::google::protobuf::MessageLite {
 public:
  ClientToServerResponse();
  virtual ~ClientToServerResponse();

  ClientToServerResponse(const ClientToServerResponse& from);

  inline ClientToServerResponse& operator=(const ClientToServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ClientToServerResponse& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ClientToServerResponse* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ClientToServerResponse* other);

  // implements Message ----------------------------------------------

  ClientToServerResponse* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ClientToServerResponse& from);
  void MergeFrom(const ClientToServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef ClientToServerResponse_Error Error;

  // accessors -------------------------------------------------------

  // optional .sync_pb.CommitResponse commit = 1;
  inline bool has_commit() const;
  inline void clear_commit();
  static const int kCommitFieldNumber = 1;
  inline const ::sync_pb::CommitResponse& commit() const;
  inline ::sync_pb::CommitResponse* mutable_commit();
  inline ::sync_pb::CommitResponse* release_commit();
  inline void set_allocated_commit(::sync_pb::CommitResponse* commit);

  // optional .sync_pb.GetUpdatesResponse get_updates = 2;
  inline bool has_get_updates() const;
  inline void clear_get_updates();
  static const int kGetUpdatesFieldNumber = 2;
  inline const ::sync_pb::GetUpdatesResponse& get_updates() const;
  inline ::sync_pb::GetUpdatesResponse* mutable_get_updates();
  inline ::sync_pb::GetUpdatesResponse* release_get_updates();
  inline void set_allocated_get_updates(::sync_pb::GetUpdatesResponse* get_updates);

  // optional .sync_pb.AuthenticateResponse authenticate = 3;
  inline bool has_authenticate() const;
  inline void clear_authenticate();
  static const int kAuthenticateFieldNumber = 3;
  inline const ::sync_pb::AuthenticateResponse& authenticate() const;
  inline ::sync_pb::AuthenticateResponse* mutable_authenticate();
  inline ::sync_pb::AuthenticateResponse* release_authenticate();
  inline void set_allocated_authenticate(::sync_pb::AuthenticateResponse* authenticate);

  // optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
  inline bool has_error_code() const;
  inline void clear_error_code();
  static const int kErrorCodeFieldNumber = 4;
  inline ::sync_pb::SyncEnums_ErrorType error_code() const;
  inline void set_error_code(::sync_pb::SyncEnums_ErrorType value);

  // optional string error_message = 5;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 5;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // optional string store_birthday = 6;
  inline bool has_store_birthday() const;
  inline void clear_store_birthday();
  static const int kStoreBirthdayFieldNumber = 6;
  inline const ::std::string& store_birthday() const;
  inline void set_store_birthday(const ::std::string& value);
  inline void set_store_birthday(const char* value);
  inline void set_store_birthday(const char* value, size_t size);
  inline ::std::string* mutable_store_birthday();
  inline ::std::string* release_store_birthday();
  inline void set_allocated_store_birthday(::std::string* store_birthday);

  // optional .sync_pb.ClientCommand client_command = 7;
  inline bool has_client_command() const;
  inline void clear_client_command();
  static const int kClientCommandFieldNumber = 7;
  inline const ::sync_pb::ClientCommand& client_command() const;
  inline ::sync_pb::ClientCommand* mutable_client_command();
  inline ::sync_pb::ClientCommand* release_client_command();
  inline void set_allocated_client_command(::sync_pb::ClientCommand* client_command);

  // optional .sync_pb.ProfilingData profiling_data = 8;
  inline bool has_profiling_data() const;
  inline void clear_profiling_data();
  static const int kProfilingDataFieldNumber = 8;
  inline const ::sync_pb::ProfilingData& profiling_data() const;
  inline ::sync_pb::ProfilingData* mutable_profiling_data();
  inline ::sync_pb::ProfilingData* release_profiling_data();
  inline void set_allocated_profiling_data(::sync_pb::ProfilingData* profiling_data);

  // optional .sync_pb.ClearUserDataResponse clear_user_data = 9;
  inline bool has_clear_user_data() const;
  inline void clear_clear_user_data();
  static const int kClearUserDataFieldNumber = 9;
  inline const ::sync_pb::ClearUserDataResponse& clear_user_data() const;
  inline ::sync_pb::ClearUserDataResponse* mutable_clear_user_data();
  inline ::sync_pb::ClearUserDataResponse* release_clear_user_data();
  inline void set_allocated_clear_user_data(::sync_pb::ClearUserDataResponse* clear_user_data);

  // optional .sync_pb.GetUpdatesMetadataResponse stream_metadata = 10;
  inline bool has_stream_metadata() const;
  inline void clear_stream_metadata();
  static const int kStreamMetadataFieldNumber = 10;
  inline const ::sync_pb::GetUpdatesMetadataResponse& stream_metadata() const;
  inline ::sync_pb::GetUpdatesMetadataResponse* mutable_stream_metadata();
  inline ::sync_pb::GetUpdatesMetadataResponse* release_stream_metadata();
  inline void set_allocated_stream_metadata(::sync_pb::GetUpdatesMetadataResponse* stream_metadata);

  // optional .sync_pb.GetUpdatesStreamingResponse stream_data = 11;
  inline bool has_stream_data() const;
  inline void clear_stream_data();
  static const int kStreamDataFieldNumber = 11;
  inline const ::sync_pb::GetUpdatesStreamingResponse& stream_data() const;
  inline ::sync_pb::GetUpdatesStreamingResponse* mutable_stream_data();
  inline ::sync_pb::GetUpdatesStreamingResponse* release_stream_data();
  inline void set_allocated_stream_data(::sync_pb::GetUpdatesStreamingResponse* stream_data);

  // repeated int32 migrated_data_type_id = 12;
  inline int migrated_data_type_id_size() const;
  inline void clear_migrated_data_type_id();
  static const int kMigratedDataTypeIdFieldNumber = 12;
  inline ::google::protobuf::int32 migrated_data_type_id(int index) const;
  inline void set_migrated_data_type_id(int index, ::google::protobuf::int32 value);
  inline void add_migrated_data_type_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      migrated_data_type_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_migrated_data_type_id();

  // optional .sync_pb.ClientToServerResponse.Error error = 13;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 13;
  inline const ::sync_pb::ClientToServerResponse_Error& error() const;
  inline ::sync_pb::ClientToServerResponse_Error* mutable_error();
  inline ::sync_pb::ClientToServerResponse_Error* release_error();
  inline void set_allocated_error(::sync_pb::ClientToServerResponse_Error* error);

  // optional .sync_pb.ChipBag new_bag_of_chips = 14;
  inline bool has_new_bag_of_chips() const;
  inline void clear_new_bag_of_chips();
  static const int kNewBagOfChipsFieldNumber = 14;
  inline const ::sync_pb::ChipBag& new_bag_of_chips() const;
  inline ::sync_pb::ChipBag* mutable_new_bag_of_chips();
  inline ::sync_pb::ChipBag* release_new_bag_of_chips();
  inline void set_allocated_new_bag_of_chips(::sync_pb::ChipBag* new_bag_of_chips);

  // @@protoc_insertion_point(class_scope:sync_pb.ClientToServerResponse)
 private:
  inline void set_has_commit();
  inline void clear_has_commit();
  inline void set_has_get_updates();
  inline void clear_has_get_updates();
  inline void set_has_authenticate();
  inline void clear_has_authenticate();
  inline void set_has_error_code();
  inline void clear_has_error_code();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_store_birthday();
  inline void clear_has_store_birthday();
  inline void set_has_client_command();
  inline void clear_has_client_command();
  inline void set_has_profiling_data();
  inline void clear_has_profiling_data();
  inline void set_has_clear_user_data();
  inline void clear_has_clear_user_data();
  inline void set_has_stream_metadata();
  inline void clear_has_stream_metadata();
  inline void set_has_stream_data();
  inline void clear_has_stream_data();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_new_bag_of_chips();
  inline void clear_has_new_bag_of_chips();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::CommitResponse* commit_;
  ::sync_pb::GetUpdatesResponse* get_updates_;
  ::sync_pb::AuthenticateResponse* authenticate_;
  ::std::string* error_message_;
  ::std::string* store_birthday_;
  ::sync_pb::ClientCommand* client_command_;
  ::sync_pb::ProfilingData* profiling_data_;
  ::sync_pb::ClearUserDataResponse* clear_user_data_;
  ::sync_pb::GetUpdatesMetadataResponse* stream_metadata_;
  ::sync_pb::GetUpdatesStreamingResponse* stream_data_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > migrated_data_type_id_;
  ::sync_pb::ClientToServerResponse_Error* error_;
  ::sync_pb::ChipBag* new_bag_of_chips_;
  int error_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_sync_2eproto();
  #endif
  friend void protobuf_AssignDesc_sync_2eproto();
  friend void protobuf_ShutdownFile_sync_2eproto();

  void InitAsDefaultInstance();
  static ClientToServerResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// ProfilingData

// optional int64 meta_data_write_time = 1;
inline bool ProfilingData::has_meta_data_write_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProfilingData::set_has_meta_data_write_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProfilingData::clear_has_meta_data_write_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProfilingData::clear_meta_data_write_time() {
  meta_data_write_time_ = GOOGLE_LONGLONG(0);
  clear_has_meta_data_write_time();
}
inline ::google::protobuf::int64 ProfilingData::meta_data_write_time() const {
  return meta_data_write_time_;
}
inline void ProfilingData::set_meta_data_write_time(::google::protobuf::int64 value) {
  set_has_meta_data_write_time();
  meta_data_write_time_ = value;
}

// optional int64 file_data_write_time = 2;
inline bool ProfilingData::has_file_data_write_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProfilingData::set_has_file_data_write_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProfilingData::clear_has_file_data_write_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProfilingData::clear_file_data_write_time() {
  file_data_write_time_ = GOOGLE_LONGLONG(0);
  clear_has_file_data_write_time();
}
inline ::google::protobuf::int64 ProfilingData::file_data_write_time() const {
  return file_data_write_time_;
}
inline void ProfilingData::set_file_data_write_time(::google::protobuf::int64 value) {
  set_has_file_data_write_time();
  file_data_write_time_ = value;
}

// optional int64 user_lookup_time = 3;
inline bool ProfilingData::has_user_lookup_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProfilingData::set_has_user_lookup_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProfilingData::clear_has_user_lookup_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProfilingData::clear_user_lookup_time() {
  user_lookup_time_ = GOOGLE_LONGLONG(0);
  clear_has_user_lookup_time();
}
inline ::google::protobuf::int64 ProfilingData::user_lookup_time() const {
  return user_lookup_time_;
}
inline void ProfilingData::set_user_lookup_time(::google::protobuf::int64 value) {
  set_has_user_lookup_time();
  user_lookup_time_ = value;
}

// optional int64 meta_data_read_time = 4;
inline bool ProfilingData::has_meta_data_read_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProfilingData::set_has_meta_data_read_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProfilingData::clear_has_meta_data_read_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProfilingData::clear_meta_data_read_time() {
  meta_data_read_time_ = GOOGLE_LONGLONG(0);
  clear_has_meta_data_read_time();
}
inline ::google::protobuf::int64 ProfilingData::meta_data_read_time() const {
  return meta_data_read_time_;
}
inline void ProfilingData::set_meta_data_read_time(::google::protobuf::int64 value) {
  set_has_meta_data_read_time();
  meta_data_read_time_ = value;
}

// optional int64 file_data_read_time = 5;
inline bool ProfilingData::has_file_data_read_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProfilingData::set_has_file_data_read_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProfilingData::clear_has_file_data_read_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProfilingData::clear_file_data_read_time() {
  file_data_read_time_ = GOOGLE_LONGLONG(0);
  clear_has_file_data_read_time();
}
inline ::google::protobuf::int64 ProfilingData::file_data_read_time() const {
  return file_data_read_time_;
}
inline void ProfilingData::set_file_data_read_time(::google::protobuf::int64 value) {
  set_has_file_data_read_time();
  file_data_read_time_ = value;
}

// optional int64 total_request_time = 6;
inline bool ProfilingData::has_total_request_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProfilingData::set_has_total_request_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProfilingData::clear_has_total_request_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProfilingData::clear_total_request_time() {
  total_request_time_ = GOOGLE_LONGLONG(0);
  clear_has_total_request_time();
}
inline ::google::protobuf::int64 ProfilingData::total_request_time() const {
  return total_request_time_;
}
inline void ProfilingData::set_total_request_time(::google::protobuf::int64 value) {
  set_has_total_request_time();
  total_request_time_ = value;
}

// -------------------------------------------------------------------

// EntitySpecifics

// optional .sync_pb.EncryptedData encrypted = 1;
inline bool EntitySpecifics::has_encrypted() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EntitySpecifics::set_has_encrypted() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EntitySpecifics::clear_has_encrypted() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EntitySpecifics::clear_encrypted() {
  if (encrypted_ != NULL) encrypted_->::sync_pb::EncryptedData::Clear();
  clear_has_encrypted();
}
inline const ::sync_pb::EncryptedData& EntitySpecifics::encrypted() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return encrypted_ != NULL ? *encrypted_ : *default_instance().encrypted_;
#else
  return encrypted_ != NULL ? *encrypted_ : *default_instance_->encrypted_;
#endif
}
inline ::sync_pb::EncryptedData* EntitySpecifics::mutable_encrypted() {
  set_has_encrypted();
  if (encrypted_ == NULL) encrypted_ = new ::sync_pb::EncryptedData;
  return encrypted_;
}
inline ::sync_pb::EncryptedData* EntitySpecifics::release_encrypted() {
  clear_has_encrypted();
  ::sync_pb::EncryptedData* temp = encrypted_;
  encrypted_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_encrypted(::sync_pb::EncryptedData* encrypted) {
  delete encrypted_;
  encrypted_ = encrypted;
  if (encrypted) {
    set_has_encrypted();
  } else {
    clear_has_encrypted();
  }
}

// optional .sync_pb.AutofillSpecifics autofill = 31729;
inline bool EntitySpecifics::has_autofill() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EntitySpecifics::set_has_autofill() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EntitySpecifics::clear_has_autofill() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EntitySpecifics::clear_autofill() {
  if (autofill_ != NULL) autofill_->::sync_pb::AutofillSpecifics::Clear();
  clear_has_autofill();
}
inline const ::sync_pb::AutofillSpecifics& EntitySpecifics::autofill() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return autofill_ != NULL ? *autofill_ : *default_instance().autofill_;
#else
  return autofill_ != NULL ? *autofill_ : *default_instance_->autofill_;
#endif
}
inline ::sync_pb::AutofillSpecifics* EntitySpecifics::mutable_autofill() {
  set_has_autofill();
  if (autofill_ == NULL) autofill_ = new ::sync_pb::AutofillSpecifics;
  return autofill_;
}
inline ::sync_pb::AutofillSpecifics* EntitySpecifics::release_autofill() {
  clear_has_autofill();
  ::sync_pb::AutofillSpecifics* temp = autofill_;
  autofill_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_autofill(::sync_pb::AutofillSpecifics* autofill) {
  delete autofill_;
  autofill_ = autofill;
  if (autofill) {
    set_has_autofill();
  } else {
    clear_has_autofill();
  }
}

// optional .sync_pb.BookmarkSpecifics bookmark = 32904;
inline bool EntitySpecifics::has_bookmark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EntitySpecifics::set_has_bookmark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EntitySpecifics::clear_has_bookmark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EntitySpecifics::clear_bookmark() {
  if (bookmark_ != NULL) bookmark_->::sync_pb::BookmarkSpecifics::Clear();
  clear_has_bookmark();
}
inline const ::sync_pb::BookmarkSpecifics& EntitySpecifics::bookmark() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bookmark_ != NULL ? *bookmark_ : *default_instance().bookmark_;
#else
  return bookmark_ != NULL ? *bookmark_ : *default_instance_->bookmark_;
#endif
}
inline ::sync_pb::BookmarkSpecifics* EntitySpecifics::mutable_bookmark() {
  set_has_bookmark();
  if (bookmark_ == NULL) bookmark_ = new ::sync_pb::BookmarkSpecifics;
  return bookmark_;
}
inline ::sync_pb::BookmarkSpecifics* EntitySpecifics::release_bookmark() {
  clear_has_bookmark();
  ::sync_pb::BookmarkSpecifics* temp = bookmark_;
  bookmark_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_bookmark(::sync_pb::BookmarkSpecifics* bookmark) {
  delete bookmark_;
  bookmark_ = bookmark;
  if (bookmark) {
    set_has_bookmark();
  } else {
    clear_has_bookmark();
  }
}

// optional .sync_pb.PreferenceSpecifics preference = 37702;
inline bool EntitySpecifics::has_preference() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EntitySpecifics::set_has_preference() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EntitySpecifics::clear_has_preference() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EntitySpecifics::clear_preference() {
  if (preference_ != NULL) preference_->::sync_pb::PreferenceSpecifics::Clear();
  clear_has_preference();
}
inline const ::sync_pb::PreferenceSpecifics& EntitySpecifics::preference() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return preference_ != NULL ? *preference_ : *default_instance().preference_;
#else
  return preference_ != NULL ? *preference_ : *default_instance_->preference_;
#endif
}
inline ::sync_pb::PreferenceSpecifics* EntitySpecifics::mutable_preference() {
  set_has_preference();
  if (preference_ == NULL) preference_ = new ::sync_pb::PreferenceSpecifics;
  return preference_;
}
inline ::sync_pb::PreferenceSpecifics* EntitySpecifics::release_preference() {
  clear_has_preference();
  ::sync_pb::PreferenceSpecifics* temp = preference_;
  preference_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_preference(::sync_pb::PreferenceSpecifics* preference) {
  delete preference_;
  preference_ = preference;
  if (preference) {
    set_has_preference();
  } else {
    clear_has_preference();
  }
}

// optional .sync_pb.TypedUrlSpecifics typed_url = 40781;
inline bool EntitySpecifics::has_typed_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EntitySpecifics::set_has_typed_url() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EntitySpecifics::clear_has_typed_url() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EntitySpecifics::clear_typed_url() {
  if (typed_url_ != NULL) typed_url_->::sync_pb::TypedUrlSpecifics::Clear();
  clear_has_typed_url();
}
inline const ::sync_pb::TypedUrlSpecifics& EntitySpecifics::typed_url() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return typed_url_ != NULL ? *typed_url_ : *default_instance().typed_url_;
#else
  return typed_url_ != NULL ? *typed_url_ : *default_instance_->typed_url_;
#endif
}
inline ::sync_pb::TypedUrlSpecifics* EntitySpecifics::mutable_typed_url() {
  set_has_typed_url();
  if (typed_url_ == NULL) typed_url_ = new ::sync_pb::TypedUrlSpecifics;
  return typed_url_;
}
inline ::sync_pb::TypedUrlSpecifics* EntitySpecifics::release_typed_url() {
  clear_has_typed_url();
  ::sync_pb::TypedUrlSpecifics* temp = typed_url_;
  typed_url_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_typed_url(::sync_pb::TypedUrlSpecifics* typed_url) {
  delete typed_url_;
  typed_url_ = typed_url;
  if (typed_url) {
    set_has_typed_url();
  } else {
    clear_has_typed_url();
  }
}

// optional .sync_pb.ThemeSpecifics theme = 41210;
inline bool EntitySpecifics::has_theme() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EntitySpecifics::set_has_theme() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EntitySpecifics::clear_has_theme() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EntitySpecifics::clear_theme() {
  if (theme_ != NULL) theme_->::sync_pb::ThemeSpecifics::Clear();
  clear_has_theme();
}
inline const ::sync_pb::ThemeSpecifics& EntitySpecifics::theme() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return theme_ != NULL ? *theme_ : *default_instance().theme_;
#else
  return theme_ != NULL ? *theme_ : *default_instance_->theme_;
#endif
}
inline ::sync_pb::ThemeSpecifics* EntitySpecifics::mutable_theme() {
  set_has_theme();
  if (theme_ == NULL) theme_ = new ::sync_pb::ThemeSpecifics;
  return theme_;
}
inline ::sync_pb::ThemeSpecifics* EntitySpecifics::release_theme() {
  clear_has_theme();
  ::sync_pb::ThemeSpecifics* temp = theme_;
  theme_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_theme(::sync_pb::ThemeSpecifics* theme) {
  delete theme_;
  theme_ = theme;
  if (theme) {
    set_has_theme();
  } else {
    clear_has_theme();
  }
}

// optional .sync_pb.AppNotification app_notification = 45184;
inline bool EntitySpecifics::has_app_notification() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EntitySpecifics::set_has_app_notification() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EntitySpecifics::clear_has_app_notification() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EntitySpecifics::clear_app_notification() {
  if (app_notification_ != NULL) app_notification_->::sync_pb::AppNotification::Clear();
  clear_has_app_notification();
}
inline const ::sync_pb::AppNotification& EntitySpecifics::app_notification() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return app_notification_ != NULL ? *app_notification_ : *default_instance().app_notification_;
#else
  return app_notification_ != NULL ? *app_notification_ : *default_instance_->app_notification_;
#endif
}
inline ::sync_pb::AppNotification* EntitySpecifics::mutable_app_notification() {
  set_has_app_notification();
  if (app_notification_ == NULL) app_notification_ = new ::sync_pb::AppNotification;
  return app_notification_;
}
inline ::sync_pb::AppNotification* EntitySpecifics::release_app_notification() {
  clear_has_app_notification();
  ::sync_pb::AppNotification* temp = app_notification_;
  app_notification_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_app_notification(::sync_pb::AppNotification* app_notification) {
  delete app_notification_;
  app_notification_ = app_notification;
  if (app_notification) {
    set_has_app_notification();
  } else {
    clear_has_app_notification();
  }
}

// optional .sync_pb.PasswordSpecifics password = 45873;
inline bool EntitySpecifics::has_password() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void EntitySpecifics::set_has_password() {
  _has_bits_[0] |= 0x00000080u;
}
inline void EntitySpecifics::clear_has_password() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void EntitySpecifics::clear_password() {
  if (password_ != NULL) password_->::sync_pb::PasswordSpecifics::Clear();
  clear_has_password();
}
inline const ::sync_pb::PasswordSpecifics& EntitySpecifics::password() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return password_ != NULL ? *password_ : *default_instance().password_;
#else
  return password_ != NULL ? *password_ : *default_instance_->password_;
#endif
}
inline ::sync_pb::PasswordSpecifics* EntitySpecifics::mutable_password() {
  set_has_password();
  if (password_ == NULL) password_ = new ::sync_pb::PasswordSpecifics;
  return password_;
}
inline ::sync_pb::PasswordSpecifics* EntitySpecifics::release_password() {
  clear_has_password();
  ::sync_pb::PasswordSpecifics* temp = password_;
  password_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_password(::sync_pb::PasswordSpecifics* password) {
  delete password_;
  password_ = password;
  if (password) {
    set_has_password();
  } else {
    clear_has_password();
  }
}

// optional .sync_pb.NigoriSpecifics nigori = 47745;
inline bool EntitySpecifics::has_nigori() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void EntitySpecifics::set_has_nigori() {
  _has_bits_[0] |= 0x00000100u;
}
inline void EntitySpecifics::clear_has_nigori() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void EntitySpecifics::clear_nigori() {
  if (nigori_ != NULL) nigori_->::sync_pb::NigoriSpecifics::Clear();
  clear_has_nigori();
}
inline const ::sync_pb::NigoriSpecifics& EntitySpecifics::nigori() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return nigori_ != NULL ? *nigori_ : *default_instance().nigori_;
#else
  return nigori_ != NULL ? *nigori_ : *default_instance_->nigori_;
#endif
}
inline ::sync_pb::NigoriSpecifics* EntitySpecifics::mutable_nigori() {
  set_has_nigori();
  if (nigori_ == NULL) nigori_ = new ::sync_pb::NigoriSpecifics;
  return nigori_;
}
inline ::sync_pb::NigoriSpecifics* EntitySpecifics::release_nigori() {
  clear_has_nigori();
  ::sync_pb::NigoriSpecifics* temp = nigori_;
  nigori_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_nigori(::sync_pb::NigoriSpecifics* nigori) {
  delete nigori_;
  nigori_ = nigori;
  if (nigori) {
    set_has_nigori();
  } else {
    clear_has_nigori();
  }
}

// optional .sync_pb.ExtensionSpecifics extension = 48119;
inline bool EntitySpecifics::has_extension() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void EntitySpecifics::set_has_extension() {
  _has_bits_[0] |= 0x00000200u;
}
inline void EntitySpecifics::clear_has_extension() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void EntitySpecifics::clear_extension() {
  if (extension_ != NULL) extension_->::sync_pb::ExtensionSpecifics::Clear();
  clear_has_extension();
}
inline const ::sync_pb::ExtensionSpecifics& EntitySpecifics::extension() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return extension_ != NULL ? *extension_ : *default_instance().extension_;
#else
  return extension_ != NULL ? *extension_ : *default_instance_->extension_;
#endif
}
inline ::sync_pb::ExtensionSpecifics* EntitySpecifics::mutable_extension() {
  set_has_extension();
  if (extension_ == NULL) extension_ = new ::sync_pb::ExtensionSpecifics;
  return extension_;
}
inline ::sync_pb::ExtensionSpecifics* EntitySpecifics::release_extension() {
  clear_has_extension();
  ::sync_pb::ExtensionSpecifics* temp = extension_;
  extension_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_extension(::sync_pb::ExtensionSpecifics* extension) {
  delete extension_;
  extension_ = extension;
  if (extension) {
    set_has_extension();
  } else {
    clear_has_extension();
  }
}

// optional .sync_pb.AppSpecifics app = 48364;
inline bool EntitySpecifics::has_app() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void EntitySpecifics::set_has_app() {
  _has_bits_[0] |= 0x00000400u;
}
inline void EntitySpecifics::clear_has_app() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void EntitySpecifics::clear_app() {
  if (app_ != NULL) app_->::sync_pb::AppSpecifics::Clear();
  clear_has_app();
}
inline const ::sync_pb::AppSpecifics& EntitySpecifics::app() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return app_ != NULL ? *app_ : *default_instance().app_;
#else
  return app_ != NULL ? *app_ : *default_instance_->app_;
#endif
}
inline ::sync_pb::AppSpecifics* EntitySpecifics::mutable_app() {
  set_has_app();
  if (app_ == NULL) app_ = new ::sync_pb::AppSpecifics;
  return app_;
}
inline ::sync_pb::AppSpecifics* EntitySpecifics::release_app() {
  clear_has_app();
  ::sync_pb::AppSpecifics* temp = app_;
  app_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_app(::sync_pb::AppSpecifics* app) {
  delete app_;
  app_ = app;
  if (app) {
    set_has_app();
  } else {
    clear_has_app();
  }
}

// optional .sync_pb.SessionSpecifics session = 50119;
inline bool EntitySpecifics::has_session() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void EntitySpecifics::set_has_session() {
  _has_bits_[0] |= 0x00000800u;
}
inline void EntitySpecifics::clear_has_session() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void EntitySpecifics::clear_session() {
  if (session_ != NULL) session_->::sync_pb::SessionSpecifics::Clear();
  clear_has_session();
}
inline const ::sync_pb::SessionSpecifics& EntitySpecifics::session() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return session_ != NULL ? *session_ : *default_instance().session_;
#else
  return session_ != NULL ? *session_ : *default_instance_->session_;
#endif
}
inline ::sync_pb::SessionSpecifics* EntitySpecifics::mutable_session() {
  set_has_session();
  if (session_ == NULL) session_ = new ::sync_pb::SessionSpecifics;
  return session_;
}
inline ::sync_pb::SessionSpecifics* EntitySpecifics::release_session() {
  clear_has_session();
  ::sync_pb::SessionSpecifics* temp = session_;
  session_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_session(::sync_pb::SessionSpecifics* session) {
  delete session_;
  session_ = session;
  if (session) {
    set_has_session();
  } else {
    clear_has_session();
  }
}

// optional .sync_pb.AutofillProfileSpecifics autofill_profile = 63951;
inline bool EntitySpecifics::has_autofill_profile() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void EntitySpecifics::set_has_autofill_profile() {
  _has_bits_[0] |= 0x00001000u;
}
inline void EntitySpecifics::clear_has_autofill_profile() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void EntitySpecifics::clear_autofill_profile() {
  if (autofill_profile_ != NULL) autofill_profile_->::sync_pb::AutofillProfileSpecifics::Clear();
  clear_has_autofill_profile();
}
inline const ::sync_pb::AutofillProfileSpecifics& EntitySpecifics::autofill_profile() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return autofill_profile_ != NULL ? *autofill_profile_ : *default_instance().autofill_profile_;
#else
  return autofill_profile_ != NULL ? *autofill_profile_ : *default_instance_->autofill_profile_;
#endif
}
inline ::sync_pb::AutofillProfileSpecifics* EntitySpecifics::mutable_autofill_profile() {
  set_has_autofill_profile();
  if (autofill_profile_ == NULL) autofill_profile_ = new ::sync_pb::AutofillProfileSpecifics;
  return autofill_profile_;
}
inline ::sync_pb::AutofillProfileSpecifics* EntitySpecifics::release_autofill_profile() {
  clear_has_autofill_profile();
  ::sync_pb::AutofillProfileSpecifics* temp = autofill_profile_;
  autofill_profile_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_autofill_profile(::sync_pb::AutofillProfileSpecifics* autofill_profile) {
  delete autofill_profile_;
  autofill_profile_ = autofill_profile;
  if (autofill_profile) {
    set_has_autofill_profile();
  } else {
    clear_has_autofill_profile();
  }
}

// optional .sync_pb.SearchEngineSpecifics search_engine = 88610;
inline bool EntitySpecifics::has_search_engine() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void EntitySpecifics::set_has_search_engine() {
  _has_bits_[0] |= 0x00002000u;
}
inline void EntitySpecifics::clear_has_search_engine() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void EntitySpecifics::clear_search_engine() {
  if (search_engine_ != NULL) search_engine_->::sync_pb::SearchEngineSpecifics::Clear();
  clear_has_search_engine();
}
inline const ::sync_pb::SearchEngineSpecifics& EntitySpecifics::search_engine() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return search_engine_ != NULL ? *search_engine_ : *default_instance().search_engine_;
#else
  return search_engine_ != NULL ? *search_engine_ : *default_instance_->search_engine_;
#endif
}
inline ::sync_pb::SearchEngineSpecifics* EntitySpecifics::mutable_search_engine() {
  set_has_search_engine();
  if (search_engine_ == NULL) search_engine_ = new ::sync_pb::SearchEngineSpecifics;
  return search_engine_;
}
inline ::sync_pb::SearchEngineSpecifics* EntitySpecifics::release_search_engine() {
  clear_has_search_engine();
  ::sync_pb::SearchEngineSpecifics* temp = search_engine_;
  search_engine_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_search_engine(::sync_pb::SearchEngineSpecifics* search_engine) {
  delete search_engine_;
  search_engine_ = search_engine;
  if (search_engine) {
    set_has_search_engine();
  } else {
    clear_has_search_engine();
  }
}

// optional .sync_pb.ExtensionSettingSpecifics extension_setting = 96159;
inline bool EntitySpecifics::has_extension_setting() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void EntitySpecifics::set_has_extension_setting() {
  _has_bits_[0] |= 0x00004000u;
}
inline void EntitySpecifics::clear_has_extension_setting() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void EntitySpecifics::clear_extension_setting() {
  if (extension_setting_ != NULL) extension_setting_->::sync_pb::ExtensionSettingSpecifics::Clear();
  clear_has_extension_setting();
}
inline const ::sync_pb::ExtensionSettingSpecifics& EntitySpecifics::extension_setting() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return extension_setting_ != NULL ? *extension_setting_ : *default_instance().extension_setting_;
#else
  return extension_setting_ != NULL ? *extension_setting_ : *default_instance_->extension_setting_;
#endif
}
inline ::sync_pb::ExtensionSettingSpecifics* EntitySpecifics::mutable_extension_setting() {
  set_has_extension_setting();
  if (extension_setting_ == NULL) extension_setting_ = new ::sync_pb::ExtensionSettingSpecifics;
  return extension_setting_;
}
inline ::sync_pb::ExtensionSettingSpecifics* EntitySpecifics::release_extension_setting() {
  clear_has_extension_setting();
  ::sync_pb::ExtensionSettingSpecifics* temp = extension_setting_;
  extension_setting_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_extension_setting(::sync_pb::ExtensionSettingSpecifics* extension_setting) {
  delete extension_setting_;
  extension_setting_ = extension_setting;
  if (extension_setting) {
    set_has_extension_setting();
  } else {
    clear_has_extension_setting();
  }
}

// optional .sync_pb.AppSettingSpecifics app_setting = 103656;
inline bool EntitySpecifics::has_app_setting() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void EntitySpecifics::set_has_app_setting() {
  _has_bits_[0] |= 0x00008000u;
}
inline void EntitySpecifics::clear_has_app_setting() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void EntitySpecifics::clear_app_setting() {
  if (app_setting_ != NULL) app_setting_->::sync_pb::AppSettingSpecifics::Clear();
  clear_has_app_setting();
}
inline const ::sync_pb::AppSettingSpecifics& EntitySpecifics::app_setting() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return app_setting_ != NULL ? *app_setting_ : *default_instance().app_setting_;
#else
  return app_setting_ != NULL ? *app_setting_ : *default_instance_->app_setting_;
#endif
}
inline ::sync_pb::AppSettingSpecifics* EntitySpecifics::mutable_app_setting() {
  set_has_app_setting();
  if (app_setting_ == NULL) app_setting_ = new ::sync_pb::AppSettingSpecifics;
  return app_setting_;
}
inline ::sync_pb::AppSettingSpecifics* EntitySpecifics::release_app_setting() {
  clear_has_app_setting();
  ::sync_pb::AppSettingSpecifics* temp = app_setting_;
  app_setting_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_app_setting(::sync_pb::AppSettingSpecifics* app_setting) {
  delete app_setting_;
  app_setting_ = app_setting;
  if (app_setting) {
    set_has_app_setting();
  } else {
    clear_has_app_setting();
  }
}

// optional .sync_pb.HistoryDeleteDirectiveSpecifics history_delete_directive = 150251;
inline bool EntitySpecifics::has_history_delete_directive() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void EntitySpecifics::set_has_history_delete_directive() {
  _has_bits_[0] |= 0x00010000u;
}
inline void EntitySpecifics::clear_has_history_delete_directive() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void EntitySpecifics::clear_history_delete_directive() {
  if (history_delete_directive_ != NULL) history_delete_directive_->::sync_pb::HistoryDeleteDirectiveSpecifics::Clear();
  clear_has_history_delete_directive();
}
inline const ::sync_pb::HistoryDeleteDirectiveSpecifics& EntitySpecifics::history_delete_directive() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return history_delete_directive_ != NULL ? *history_delete_directive_ : *default_instance().history_delete_directive_;
#else
  return history_delete_directive_ != NULL ? *history_delete_directive_ : *default_instance_->history_delete_directive_;
#endif
}
inline ::sync_pb::HistoryDeleteDirectiveSpecifics* EntitySpecifics::mutable_history_delete_directive() {
  set_has_history_delete_directive();
  if (history_delete_directive_ == NULL) history_delete_directive_ = new ::sync_pb::HistoryDeleteDirectiveSpecifics;
  return history_delete_directive_;
}
inline ::sync_pb::HistoryDeleteDirectiveSpecifics* EntitySpecifics::release_history_delete_directive() {
  clear_has_history_delete_directive();
  ::sync_pb::HistoryDeleteDirectiveSpecifics* temp = history_delete_directive_;
  history_delete_directive_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_history_delete_directive(::sync_pb::HistoryDeleteDirectiveSpecifics* history_delete_directive) {
  delete history_delete_directive_;
  history_delete_directive_ = history_delete_directive;
  if (history_delete_directive) {
    set_has_history_delete_directive();
  } else {
    clear_has_history_delete_directive();
  }
}

// optional .sync_pb.SyncedNotificationSpecifics synced_notification = 153108;
inline bool EntitySpecifics::has_synced_notification() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void EntitySpecifics::set_has_synced_notification() {
  _has_bits_[0] |= 0x00020000u;
}
inline void EntitySpecifics::clear_has_synced_notification() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void EntitySpecifics::clear_synced_notification() {
  if (synced_notification_ != NULL) synced_notification_->::sync_pb::SyncedNotificationSpecifics::Clear();
  clear_has_synced_notification();
}
inline const ::sync_pb::SyncedNotificationSpecifics& EntitySpecifics::synced_notification() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return synced_notification_ != NULL ? *synced_notification_ : *default_instance().synced_notification_;
#else
  return synced_notification_ != NULL ? *synced_notification_ : *default_instance_->synced_notification_;
#endif
}
inline ::sync_pb::SyncedNotificationSpecifics* EntitySpecifics::mutable_synced_notification() {
  set_has_synced_notification();
  if (synced_notification_ == NULL) synced_notification_ = new ::sync_pb::SyncedNotificationSpecifics;
  return synced_notification_;
}
inline ::sync_pb::SyncedNotificationSpecifics* EntitySpecifics::release_synced_notification() {
  clear_has_synced_notification();
  ::sync_pb::SyncedNotificationSpecifics* temp = synced_notification_;
  synced_notification_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_synced_notification(::sync_pb::SyncedNotificationSpecifics* synced_notification) {
  delete synced_notification_;
  synced_notification_ = synced_notification;
  if (synced_notification) {
    set_has_synced_notification();
  } else {
    clear_has_synced_notification();
  }
}

// optional .sync_pb.SyncedNotificationAppInfoSpecifics synced_notification_app_info = 235816;
inline bool EntitySpecifics::has_synced_notification_app_info() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void EntitySpecifics::set_has_synced_notification_app_info() {
  _has_bits_[0] |= 0x00040000u;
}
inline void EntitySpecifics::clear_has_synced_notification_app_info() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void EntitySpecifics::clear_synced_notification_app_info() {
  if (synced_notification_app_info_ != NULL) synced_notification_app_info_->::sync_pb::SyncedNotificationAppInfoSpecifics::Clear();
  clear_has_synced_notification_app_info();
}
inline const ::sync_pb::SyncedNotificationAppInfoSpecifics& EntitySpecifics::synced_notification_app_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return synced_notification_app_info_ != NULL ? *synced_notification_app_info_ : *default_instance().synced_notification_app_info_;
#else
  return synced_notification_app_info_ != NULL ? *synced_notification_app_info_ : *default_instance_->synced_notification_app_info_;
#endif
}
inline ::sync_pb::SyncedNotificationAppInfoSpecifics* EntitySpecifics::mutable_synced_notification_app_info() {
  set_has_synced_notification_app_info();
  if (synced_notification_app_info_ == NULL) synced_notification_app_info_ = new ::sync_pb::SyncedNotificationAppInfoSpecifics;
  return synced_notification_app_info_;
}
inline ::sync_pb::SyncedNotificationAppInfoSpecifics* EntitySpecifics::release_synced_notification_app_info() {
  clear_has_synced_notification_app_info();
  ::sync_pb::SyncedNotificationAppInfoSpecifics* temp = synced_notification_app_info_;
  synced_notification_app_info_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_synced_notification_app_info(::sync_pb::SyncedNotificationAppInfoSpecifics* synced_notification_app_info) {
  delete synced_notification_app_info_;
  synced_notification_app_info_ = synced_notification_app_info;
  if (synced_notification_app_info) {
    set_has_synced_notification_app_info();
  } else {
    clear_has_synced_notification_app_info();
  }
}

// optional .sync_pb.DeviceInfoSpecifics device_info = 154522;
inline bool EntitySpecifics::has_device_info() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void EntitySpecifics::set_has_device_info() {
  _has_bits_[0] |= 0x00080000u;
}
inline void EntitySpecifics::clear_has_device_info() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void EntitySpecifics::clear_device_info() {
  if (device_info_ != NULL) device_info_->::sync_pb::DeviceInfoSpecifics::Clear();
  clear_has_device_info();
}
inline const ::sync_pb::DeviceInfoSpecifics& EntitySpecifics::device_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return device_info_ != NULL ? *device_info_ : *default_instance().device_info_;
#else
  return device_info_ != NULL ? *device_info_ : *default_instance_->device_info_;
#endif
}
inline ::sync_pb::DeviceInfoSpecifics* EntitySpecifics::mutable_device_info() {
  set_has_device_info();
  if (device_info_ == NULL) device_info_ = new ::sync_pb::DeviceInfoSpecifics;
  return device_info_;
}
inline ::sync_pb::DeviceInfoSpecifics* EntitySpecifics::release_device_info() {
  clear_has_device_info();
  ::sync_pb::DeviceInfoSpecifics* temp = device_info_;
  device_info_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_device_info(::sync_pb::DeviceInfoSpecifics* device_info) {
  delete device_info_;
  device_info_ = device_info;
  if (device_info) {
    set_has_device_info();
  } else {
    clear_has_device_info();
  }
}

// optional .sync_pb.ExperimentsSpecifics experiments = 161496;
inline bool EntitySpecifics::has_experiments() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void EntitySpecifics::set_has_experiments() {
  _has_bits_[0] |= 0x00100000u;
}
inline void EntitySpecifics::clear_has_experiments() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void EntitySpecifics::clear_experiments() {
  if (experiments_ != NULL) experiments_->::sync_pb::ExperimentsSpecifics::Clear();
  clear_has_experiments();
}
inline const ::sync_pb::ExperimentsSpecifics& EntitySpecifics::experiments() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return experiments_ != NULL ? *experiments_ : *default_instance().experiments_;
#else
  return experiments_ != NULL ? *experiments_ : *default_instance_->experiments_;
#endif
}
inline ::sync_pb::ExperimentsSpecifics* EntitySpecifics::mutable_experiments() {
  set_has_experiments();
  if (experiments_ == NULL) experiments_ = new ::sync_pb::ExperimentsSpecifics;
  return experiments_;
}
inline ::sync_pb::ExperimentsSpecifics* EntitySpecifics::release_experiments() {
  clear_has_experiments();
  ::sync_pb::ExperimentsSpecifics* temp = experiments_;
  experiments_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_experiments(::sync_pb::ExperimentsSpecifics* experiments) {
  delete experiments_;
  experiments_ = experiments;
  if (experiments) {
    set_has_experiments();
  } else {
    clear_has_experiments();
  }
}

// optional .sync_pb.PriorityPreferenceSpecifics priority_preference = 163425;
inline bool EntitySpecifics::has_priority_preference() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void EntitySpecifics::set_has_priority_preference() {
  _has_bits_[0] |= 0x00200000u;
}
inline void EntitySpecifics::clear_has_priority_preference() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void EntitySpecifics::clear_priority_preference() {
  if (priority_preference_ != NULL) priority_preference_->::sync_pb::PriorityPreferenceSpecifics::Clear();
  clear_has_priority_preference();
}
inline const ::sync_pb::PriorityPreferenceSpecifics& EntitySpecifics::priority_preference() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return priority_preference_ != NULL ? *priority_preference_ : *default_instance().priority_preference_;
#else
  return priority_preference_ != NULL ? *priority_preference_ : *default_instance_->priority_preference_;
#endif
}
inline ::sync_pb::PriorityPreferenceSpecifics* EntitySpecifics::mutable_priority_preference() {
  set_has_priority_preference();
  if (priority_preference_ == NULL) priority_preference_ = new ::sync_pb::PriorityPreferenceSpecifics;
  return priority_preference_;
}
inline ::sync_pb::PriorityPreferenceSpecifics* EntitySpecifics::release_priority_preference() {
  clear_has_priority_preference();
  ::sync_pb::PriorityPreferenceSpecifics* temp = priority_preference_;
  priority_preference_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_priority_preference(::sync_pb::PriorityPreferenceSpecifics* priority_preference) {
  delete priority_preference_;
  priority_preference_ = priority_preference;
  if (priority_preference) {
    set_has_priority_preference();
  } else {
    clear_has_priority_preference();
  }
}

// optional .sync_pb.DictionarySpecifics dictionary = 170540;
inline bool EntitySpecifics::has_dictionary() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void EntitySpecifics::set_has_dictionary() {
  _has_bits_[0] |= 0x00400000u;
}
inline void EntitySpecifics::clear_has_dictionary() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void EntitySpecifics::clear_dictionary() {
  if (dictionary_ != NULL) dictionary_->::sync_pb::DictionarySpecifics::Clear();
  clear_has_dictionary();
}
inline const ::sync_pb::DictionarySpecifics& EntitySpecifics::dictionary() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return dictionary_ != NULL ? *dictionary_ : *default_instance().dictionary_;
#else
  return dictionary_ != NULL ? *dictionary_ : *default_instance_->dictionary_;
#endif
}
inline ::sync_pb::DictionarySpecifics* EntitySpecifics::mutable_dictionary() {
  set_has_dictionary();
  if (dictionary_ == NULL) dictionary_ = new ::sync_pb::DictionarySpecifics;
  return dictionary_;
}
inline ::sync_pb::DictionarySpecifics* EntitySpecifics::release_dictionary() {
  clear_has_dictionary();
  ::sync_pb::DictionarySpecifics* temp = dictionary_;
  dictionary_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_dictionary(::sync_pb::DictionarySpecifics* dictionary) {
  delete dictionary_;
  dictionary_ = dictionary;
  if (dictionary) {
    set_has_dictionary();
  } else {
    clear_has_dictionary();
  }
}

// optional .sync_pb.FaviconTrackingSpecifics favicon_tracking = 181534;
inline bool EntitySpecifics::has_favicon_tracking() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void EntitySpecifics::set_has_favicon_tracking() {
  _has_bits_[0] |= 0x00800000u;
}
inline void EntitySpecifics::clear_has_favicon_tracking() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void EntitySpecifics::clear_favicon_tracking() {
  if (favicon_tracking_ != NULL) favicon_tracking_->::sync_pb::FaviconTrackingSpecifics::Clear();
  clear_has_favicon_tracking();
}
inline const ::sync_pb::FaviconTrackingSpecifics& EntitySpecifics::favicon_tracking() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return favicon_tracking_ != NULL ? *favicon_tracking_ : *default_instance().favicon_tracking_;
#else
  return favicon_tracking_ != NULL ? *favicon_tracking_ : *default_instance_->favicon_tracking_;
#endif
}
inline ::sync_pb::FaviconTrackingSpecifics* EntitySpecifics::mutable_favicon_tracking() {
  set_has_favicon_tracking();
  if (favicon_tracking_ == NULL) favicon_tracking_ = new ::sync_pb::FaviconTrackingSpecifics;
  return favicon_tracking_;
}
inline ::sync_pb::FaviconTrackingSpecifics* EntitySpecifics::release_favicon_tracking() {
  clear_has_favicon_tracking();
  ::sync_pb::FaviconTrackingSpecifics* temp = favicon_tracking_;
  favicon_tracking_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_favicon_tracking(::sync_pb::FaviconTrackingSpecifics* favicon_tracking) {
  delete favicon_tracking_;
  favicon_tracking_ = favicon_tracking;
  if (favicon_tracking) {
    set_has_favicon_tracking();
  } else {
    clear_has_favicon_tracking();
  }
}

// optional .sync_pb.FaviconImageSpecifics favicon_image = 182019;
inline bool EntitySpecifics::has_favicon_image() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void EntitySpecifics::set_has_favicon_image() {
  _has_bits_[0] |= 0x01000000u;
}
inline void EntitySpecifics::clear_has_favicon_image() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void EntitySpecifics::clear_favicon_image() {
  if (favicon_image_ != NULL) favicon_image_->::sync_pb::FaviconImageSpecifics::Clear();
  clear_has_favicon_image();
}
inline const ::sync_pb::FaviconImageSpecifics& EntitySpecifics::favicon_image() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return favicon_image_ != NULL ? *favicon_image_ : *default_instance().favicon_image_;
#else
  return favicon_image_ != NULL ? *favicon_image_ : *default_instance_->favicon_image_;
#endif
}
inline ::sync_pb::FaviconImageSpecifics* EntitySpecifics::mutable_favicon_image() {
  set_has_favicon_image();
  if (favicon_image_ == NULL) favicon_image_ = new ::sync_pb::FaviconImageSpecifics;
  return favicon_image_;
}
inline ::sync_pb::FaviconImageSpecifics* EntitySpecifics::release_favicon_image() {
  clear_has_favicon_image();
  ::sync_pb::FaviconImageSpecifics* temp = favicon_image_;
  favicon_image_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_favicon_image(::sync_pb::FaviconImageSpecifics* favicon_image) {
  delete favicon_image_;
  favicon_image_ = favicon_image;
  if (favicon_image) {
    set_has_favicon_image();
  } else {
    clear_has_favicon_image();
  }
}

// optional .sync_pb.ManagedUserSettingSpecifics managed_user_setting = 186662;
inline bool EntitySpecifics::has_managed_user_setting() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void EntitySpecifics::set_has_managed_user_setting() {
  _has_bits_[0] |= 0x02000000u;
}
inline void EntitySpecifics::clear_has_managed_user_setting() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void EntitySpecifics::clear_managed_user_setting() {
  if (managed_user_setting_ != NULL) managed_user_setting_->::sync_pb::ManagedUserSettingSpecifics::Clear();
  clear_has_managed_user_setting();
}
inline const ::sync_pb::ManagedUserSettingSpecifics& EntitySpecifics::managed_user_setting() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return managed_user_setting_ != NULL ? *managed_user_setting_ : *default_instance().managed_user_setting_;
#else
  return managed_user_setting_ != NULL ? *managed_user_setting_ : *default_instance_->managed_user_setting_;
#endif
}
inline ::sync_pb::ManagedUserSettingSpecifics* EntitySpecifics::mutable_managed_user_setting() {
  set_has_managed_user_setting();
  if (managed_user_setting_ == NULL) managed_user_setting_ = new ::sync_pb::ManagedUserSettingSpecifics;
  return managed_user_setting_;
}
inline ::sync_pb::ManagedUserSettingSpecifics* EntitySpecifics::release_managed_user_setting() {
  clear_has_managed_user_setting();
  ::sync_pb::ManagedUserSettingSpecifics* temp = managed_user_setting_;
  managed_user_setting_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_managed_user_setting(::sync_pb::ManagedUserSettingSpecifics* managed_user_setting) {
  delete managed_user_setting_;
  managed_user_setting_ = managed_user_setting;
  if (managed_user_setting) {
    set_has_managed_user_setting();
  } else {
    clear_has_managed_user_setting();
  }
}

// optional .sync_pb.ManagedUserSpecifics managed_user = 194582;
inline bool EntitySpecifics::has_managed_user() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void EntitySpecifics::set_has_managed_user() {
  _has_bits_[0] |= 0x04000000u;
}
inline void EntitySpecifics::clear_has_managed_user() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void EntitySpecifics::clear_managed_user() {
  if (managed_user_ != NULL) managed_user_->::sync_pb::ManagedUserSpecifics::Clear();
  clear_has_managed_user();
}
inline const ::sync_pb::ManagedUserSpecifics& EntitySpecifics::managed_user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return managed_user_ != NULL ? *managed_user_ : *default_instance().managed_user_;
#else
  return managed_user_ != NULL ? *managed_user_ : *default_instance_->managed_user_;
#endif
}
inline ::sync_pb::ManagedUserSpecifics* EntitySpecifics::mutable_managed_user() {
  set_has_managed_user();
  if (managed_user_ == NULL) managed_user_ = new ::sync_pb::ManagedUserSpecifics;
  return managed_user_;
}
inline ::sync_pb::ManagedUserSpecifics* EntitySpecifics::release_managed_user() {
  clear_has_managed_user();
  ::sync_pb::ManagedUserSpecifics* temp = managed_user_;
  managed_user_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_managed_user(::sync_pb::ManagedUserSpecifics* managed_user) {
  delete managed_user_;
  managed_user_ = managed_user;
  if (managed_user) {
    set_has_managed_user();
  } else {
    clear_has_managed_user();
  }
}

// optional .sync_pb.ManagedUserSharedSettingSpecifics managed_user_shared_setting = 202026;
inline bool EntitySpecifics::has_managed_user_shared_setting() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void EntitySpecifics::set_has_managed_user_shared_setting() {
  _has_bits_[0] |= 0x08000000u;
}
inline void EntitySpecifics::clear_has_managed_user_shared_setting() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void EntitySpecifics::clear_managed_user_shared_setting() {
  if (managed_user_shared_setting_ != NULL) managed_user_shared_setting_->::sync_pb::ManagedUserSharedSettingSpecifics::Clear();
  clear_has_managed_user_shared_setting();
}
inline const ::sync_pb::ManagedUserSharedSettingSpecifics& EntitySpecifics::managed_user_shared_setting() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return managed_user_shared_setting_ != NULL ? *managed_user_shared_setting_ : *default_instance().managed_user_shared_setting_;
#else
  return managed_user_shared_setting_ != NULL ? *managed_user_shared_setting_ : *default_instance_->managed_user_shared_setting_;
#endif
}
inline ::sync_pb::ManagedUserSharedSettingSpecifics* EntitySpecifics::mutable_managed_user_shared_setting() {
  set_has_managed_user_shared_setting();
  if (managed_user_shared_setting_ == NULL) managed_user_shared_setting_ = new ::sync_pb::ManagedUserSharedSettingSpecifics;
  return managed_user_shared_setting_;
}
inline ::sync_pb::ManagedUserSharedSettingSpecifics* EntitySpecifics::release_managed_user_shared_setting() {
  clear_has_managed_user_shared_setting();
  ::sync_pb::ManagedUserSharedSettingSpecifics* temp = managed_user_shared_setting_;
  managed_user_shared_setting_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_managed_user_shared_setting(::sync_pb::ManagedUserSharedSettingSpecifics* managed_user_shared_setting) {
  delete managed_user_shared_setting_;
  managed_user_shared_setting_ = managed_user_shared_setting;
  if (managed_user_shared_setting) {
    set_has_managed_user_shared_setting();
  } else {
    clear_has_managed_user_shared_setting();
  }
}

// optional .sync_pb.ArticleSpecifics article = 223759;
inline bool EntitySpecifics::has_article() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void EntitySpecifics::set_has_article() {
  _has_bits_[0] |= 0x10000000u;
}
inline void EntitySpecifics::clear_has_article() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void EntitySpecifics::clear_article() {
  if (article_ != NULL) article_->::sync_pb::ArticleSpecifics::Clear();
  clear_has_article();
}
inline const ::sync_pb::ArticleSpecifics& EntitySpecifics::article() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return article_ != NULL ? *article_ : *default_instance().article_;
#else
  return article_ != NULL ? *article_ : *default_instance_->article_;
#endif
}
inline ::sync_pb::ArticleSpecifics* EntitySpecifics::mutable_article() {
  set_has_article();
  if (article_ == NULL) article_ = new ::sync_pb::ArticleSpecifics;
  return article_;
}
inline ::sync_pb::ArticleSpecifics* EntitySpecifics::release_article() {
  clear_has_article();
  ::sync_pb::ArticleSpecifics* temp = article_;
  article_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_article(::sync_pb::ArticleSpecifics* article) {
  delete article_;
  article_ = article;
  if (article) {
    set_has_article();
  } else {
    clear_has_article();
  }
}

// optional .sync_pb.AppListSpecifics app_list = 229170;
inline bool EntitySpecifics::has_app_list() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void EntitySpecifics::set_has_app_list() {
  _has_bits_[0] |= 0x20000000u;
}
inline void EntitySpecifics::clear_has_app_list() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void EntitySpecifics::clear_app_list() {
  if (app_list_ != NULL) app_list_->::sync_pb::AppListSpecifics::Clear();
  clear_has_app_list();
}
inline const ::sync_pb::AppListSpecifics& EntitySpecifics::app_list() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return app_list_ != NULL ? *app_list_ : *default_instance().app_list_;
#else
  return app_list_ != NULL ? *app_list_ : *default_instance_->app_list_;
#endif
}
inline ::sync_pb::AppListSpecifics* EntitySpecifics::mutable_app_list() {
  set_has_app_list();
  if (app_list_ == NULL) app_list_ = new ::sync_pb::AppListSpecifics;
  return app_list_;
}
inline ::sync_pb::AppListSpecifics* EntitySpecifics::release_app_list() {
  clear_has_app_list();
  ::sync_pb::AppListSpecifics* temp = app_list_;
  app_list_ = NULL;
  return temp;
}
inline void EntitySpecifics::set_allocated_app_list(::sync_pb::AppListSpecifics* app_list) {
  delete app_list_;
  app_list_ = app_list;
  if (app_list) {
    set_has_app_list();
  } else {
    clear_has_app_list();
  }
}

// -------------------------------------------------------------------

// SyncEntity_BookmarkData

// required bool bookmark_folder = 12;
inline bool SyncEntity_BookmarkData::has_bookmark_folder() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncEntity_BookmarkData::set_has_bookmark_folder() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncEntity_BookmarkData::clear_has_bookmark_folder() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncEntity_BookmarkData::clear_bookmark_folder() {
  bookmark_folder_ = false;
  clear_has_bookmark_folder();
}
inline bool SyncEntity_BookmarkData::bookmark_folder() const {
  return bookmark_folder_;
}
inline void SyncEntity_BookmarkData::set_bookmark_folder(bool value) {
  set_has_bookmark_folder();
  bookmark_folder_ = value;
}

// optional string bookmark_url = 13;
inline bool SyncEntity_BookmarkData::has_bookmark_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncEntity_BookmarkData::set_has_bookmark_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncEntity_BookmarkData::clear_has_bookmark_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncEntity_BookmarkData::clear_bookmark_url() {
  if (bookmark_url_ != &::google::protobuf::internal::GetEmptyString()) {
    bookmark_url_->clear();
  }
  clear_has_bookmark_url();
}
inline const ::std::string& SyncEntity_BookmarkData::bookmark_url() const {
  return *bookmark_url_;
}
inline void SyncEntity_BookmarkData::set_bookmark_url(const ::std::string& value) {
  set_has_bookmark_url();
  if (bookmark_url_ == &::google::protobuf::internal::GetEmptyString()) {
    bookmark_url_ = new ::std::string;
  }
  bookmark_url_->assign(value);
}
inline void SyncEntity_BookmarkData::set_bookmark_url(const char* value) {
  set_has_bookmark_url();
  if (bookmark_url_ == &::google::protobuf::internal::GetEmptyString()) {
    bookmark_url_ = new ::std::string;
  }
  bookmark_url_->assign(value);
}
inline void SyncEntity_BookmarkData::set_bookmark_url(const char* value, size_t size) {
  set_has_bookmark_url();
  if (bookmark_url_ == &::google::protobuf::internal::GetEmptyString()) {
    bookmark_url_ = new ::std::string;
  }
  bookmark_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity_BookmarkData::mutable_bookmark_url() {
  set_has_bookmark_url();
  if (bookmark_url_ == &::google::protobuf::internal::GetEmptyString()) {
    bookmark_url_ = new ::std::string;
  }
  return bookmark_url_;
}
inline ::std::string* SyncEntity_BookmarkData::release_bookmark_url() {
  clear_has_bookmark_url();
  if (bookmark_url_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = bookmark_url_;
    bookmark_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity_BookmarkData::set_allocated_bookmark_url(::std::string* bookmark_url) {
  if (bookmark_url_ != &::google::protobuf::internal::GetEmptyString()) {
    delete bookmark_url_;
  }
  if (bookmark_url) {
    set_has_bookmark_url();
    bookmark_url_ = bookmark_url;
  } else {
    clear_has_bookmark_url();
    bookmark_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes bookmark_favicon = 14;
inline bool SyncEntity_BookmarkData::has_bookmark_favicon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncEntity_BookmarkData::set_has_bookmark_favicon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncEntity_BookmarkData::clear_has_bookmark_favicon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncEntity_BookmarkData::clear_bookmark_favicon() {
  if (bookmark_favicon_ != &::google::protobuf::internal::GetEmptyString()) {
    bookmark_favicon_->clear();
  }
  clear_has_bookmark_favicon();
}
inline const ::std::string& SyncEntity_BookmarkData::bookmark_favicon() const {
  return *bookmark_favicon_;
}
inline void SyncEntity_BookmarkData::set_bookmark_favicon(const ::std::string& value) {
  set_has_bookmark_favicon();
  if (bookmark_favicon_ == &::google::protobuf::internal::GetEmptyString()) {
    bookmark_favicon_ = new ::std::string;
  }
  bookmark_favicon_->assign(value);
}
inline void SyncEntity_BookmarkData::set_bookmark_favicon(const char* value) {
  set_has_bookmark_favicon();
  if (bookmark_favicon_ == &::google::protobuf::internal::GetEmptyString()) {
    bookmark_favicon_ = new ::std::string;
  }
  bookmark_favicon_->assign(value);
}
inline void SyncEntity_BookmarkData::set_bookmark_favicon(const void* value, size_t size) {
  set_has_bookmark_favicon();
  if (bookmark_favicon_ == &::google::protobuf::internal::GetEmptyString()) {
    bookmark_favicon_ = new ::std::string;
  }
  bookmark_favicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity_BookmarkData::mutable_bookmark_favicon() {
  set_has_bookmark_favicon();
  if (bookmark_favicon_ == &::google::protobuf::internal::GetEmptyString()) {
    bookmark_favicon_ = new ::std::string;
  }
  return bookmark_favicon_;
}
inline ::std::string* SyncEntity_BookmarkData::release_bookmark_favicon() {
  clear_has_bookmark_favicon();
  if (bookmark_favicon_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = bookmark_favicon_;
    bookmark_favicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity_BookmarkData::set_allocated_bookmark_favicon(::std::string* bookmark_favicon) {
  if (bookmark_favicon_ != &::google::protobuf::internal::GetEmptyString()) {
    delete bookmark_favicon_;
  }
  if (bookmark_favicon) {
    set_has_bookmark_favicon();
    bookmark_favicon_ = bookmark_favicon;
  } else {
    clear_has_bookmark_favicon();
    bookmark_favicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// SyncEntity

// optional string id_string = 1;
inline bool SyncEntity::has_id_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncEntity::set_has_id_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncEntity::clear_has_id_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncEntity::clear_id_string() {
  if (id_string_ != &::google::protobuf::internal::GetEmptyString()) {
    id_string_->clear();
  }
  clear_has_id_string();
}
inline const ::std::string& SyncEntity::id_string() const {
  return *id_string_;
}
inline void SyncEntity::set_id_string(const ::std::string& value) {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    id_string_ = new ::std::string;
  }
  id_string_->assign(value);
}
inline void SyncEntity::set_id_string(const char* value) {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    id_string_ = new ::std::string;
  }
  id_string_->assign(value);
}
inline void SyncEntity::set_id_string(const char* value, size_t size) {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    id_string_ = new ::std::string;
  }
  id_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_id_string() {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    id_string_ = new ::std::string;
  }
  return id_string_;
}
inline ::std::string* SyncEntity::release_id_string() {
  clear_has_id_string();
  if (id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = id_string_;
    id_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_id_string(::std::string* id_string) {
  if (id_string_ != &::google::protobuf::internal::GetEmptyString()) {
    delete id_string_;
  }
  if (id_string) {
    set_has_id_string();
    id_string_ = id_string;
  } else {
    clear_has_id_string();
    id_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string parent_id_string = 2;
inline bool SyncEntity::has_parent_id_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncEntity::set_has_parent_id_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncEntity::clear_has_parent_id_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncEntity::clear_parent_id_string() {
  if (parent_id_string_ != &::google::protobuf::internal::GetEmptyString()) {
    parent_id_string_->clear();
  }
  clear_has_parent_id_string();
}
inline const ::std::string& SyncEntity::parent_id_string() const {
  return *parent_id_string_;
}
inline void SyncEntity::set_parent_id_string(const ::std::string& value) {
  set_has_parent_id_string();
  if (parent_id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    parent_id_string_ = new ::std::string;
  }
  parent_id_string_->assign(value);
}
inline void SyncEntity::set_parent_id_string(const char* value) {
  set_has_parent_id_string();
  if (parent_id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    parent_id_string_ = new ::std::string;
  }
  parent_id_string_->assign(value);
}
inline void SyncEntity::set_parent_id_string(const char* value, size_t size) {
  set_has_parent_id_string();
  if (parent_id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    parent_id_string_ = new ::std::string;
  }
  parent_id_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_parent_id_string() {
  set_has_parent_id_string();
  if (parent_id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    parent_id_string_ = new ::std::string;
  }
  return parent_id_string_;
}
inline ::std::string* SyncEntity::release_parent_id_string() {
  clear_has_parent_id_string();
  if (parent_id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = parent_id_string_;
    parent_id_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_parent_id_string(::std::string* parent_id_string) {
  if (parent_id_string_ != &::google::protobuf::internal::GetEmptyString()) {
    delete parent_id_string_;
  }
  if (parent_id_string) {
    set_has_parent_id_string();
    parent_id_string_ = parent_id_string;
  } else {
    clear_has_parent_id_string();
    parent_id_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string old_parent_id = 3;
inline bool SyncEntity::has_old_parent_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncEntity::set_has_old_parent_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncEntity::clear_has_old_parent_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncEntity::clear_old_parent_id() {
  if (old_parent_id_ != &::google::protobuf::internal::GetEmptyString()) {
    old_parent_id_->clear();
  }
  clear_has_old_parent_id();
}
inline const ::std::string& SyncEntity::old_parent_id() const {
  return *old_parent_id_;
}
inline void SyncEntity::set_old_parent_id(const ::std::string& value) {
  set_has_old_parent_id();
  if (old_parent_id_ == &::google::protobuf::internal::GetEmptyString()) {
    old_parent_id_ = new ::std::string;
  }
  old_parent_id_->assign(value);
}
inline void SyncEntity::set_old_parent_id(const char* value) {
  set_has_old_parent_id();
  if (old_parent_id_ == &::google::protobuf::internal::GetEmptyString()) {
    old_parent_id_ = new ::std::string;
  }
  old_parent_id_->assign(value);
}
inline void SyncEntity::set_old_parent_id(const char* value, size_t size) {
  set_has_old_parent_id();
  if (old_parent_id_ == &::google::protobuf::internal::GetEmptyString()) {
    old_parent_id_ = new ::std::string;
  }
  old_parent_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_old_parent_id() {
  set_has_old_parent_id();
  if (old_parent_id_ == &::google::protobuf::internal::GetEmptyString()) {
    old_parent_id_ = new ::std::string;
  }
  return old_parent_id_;
}
inline ::std::string* SyncEntity::release_old_parent_id() {
  clear_has_old_parent_id();
  if (old_parent_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = old_parent_id_;
    old_parent_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_old_parent_id(::std::string* old_parent_id) {
  if (old_parent_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete old_parent_id_;
  }
  if (old_parent_id) {
    set_has_old_parent_id();
    old_parent_id_ = old_parent_id;
  } else {
    clear_has_old_parent_id();
    old_parent_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// required int64 version = 4;
inline bool SyncEntity::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncEntity::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncEntity::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncEntity::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::int64 SyncEntity::version() const {
  return version_;
}
inline void SyncEntity::set_version(::google::protobuf::int64 value) {
  set_has_version();
  version_ = value;
}

// optional int64 mtime = 5;
inline bool SyncEntity::has_mtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SyncEntity::set_has_mtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SyncEntity::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SyncEntity::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  clear_has_mtime();
}
inline ::google::protobuf::int64 SyncEntity::mtime() const {
  return mtime_;
}
inline void SyncEntity::set_mtime(::google::protobuf::int64 value) {
  set_has_mtime();
  mtime_ = value;
}

// optional int64 ctime = 6;
inline bool SyncEntity::has_ctime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SyncEntity::set_has_ctime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SyncEntity::clear_has_ctime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SyncEntity::clear_ctime() {
  ctime_ = GOOGLE_LONGLONG(0);
  clear_has_ctime();
}
inline ::google::protobuf::int64 SyncEntity::ctime() const {
  return ctime_;
}
inline void SyncEntity::set_ctime(::google::protobuf::int64 value) {
  set_has_ctime();
  ctime_ = value;
}

// required string name = 7;
inline bool SyncEntity::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SyncEntity::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SyncEntity::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SyncEntity::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SyncEntity::name() const {
  return *name_;
}
inline void SyncEntity::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SyncEntity::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SyncEntity::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SyncEntity::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string non_unique_name = 8;
inline bool SyncEntity::has_non_unique_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SyncEntity::set_has_non_unique_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SyncEntity::clear_has_non_unique_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SyncEntity::clear_non_unique_name() {
  if (non_unique_name_ != &::google::protobuf::internal::GetEmptyString()) {
    non_unique_name_->clear();
  }
  clear_has_non_unique_name();
}
inline const ::std::string& SyncEntity::non_unique_name() const {
  return *non_unique_name_;
}
inline void SyncEntity::set_non_unique_name(const ::std::string& value) {
  set_has_non_unique_name();
  if (non_unique_name_ == &::google::protobuf::internal::GetEmptyString()) {
    non_unique_name_ = new ::std::string;
  }
  non_unique_name_->assign(value);
}
inline void SyncEntity::set_non_unique_name(const char* value) {
  set_has_non_unique_name();
  if (non_unique_name_ == &::google::protobuf::internal::GetEmptyString()) {
    non_unique_name_ = new ::std::string;
  }
  non_unique_name_->assign(value);
}
inline void SyncEntity::set_non_unique_name(const char* value, size_t size) {
  set_has_non_unique_name();
  if (non_unique_name_ == &::google::protobuf::internal::GetEmptyString()) {
    non_unique_name_ = new ::std::string;
  }
  non_unique_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_non_unique_name() {
  set_has_non_unique_name();
  if (non_unique_name_ == &::google::protobuf::internal::GetEmptyString()) {
    non_unique_name_ = new ::std::string;
  }
  return non_unique_name_;
}
inline ::std::string* SyncEntity::release_non_unique_name() {
  clear_has_non_unique_name();
  if (non_unique_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = non_unique_name_;
    non_unique_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_non_unique_name(::std::string* non_unique_name) {
  if (non_unique_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete non_unique_name_;
  }
  if (non_unique_name) {
    set_has_non_unique_name();
    non_unique_name_ = non_unique_name;
  } else {
    clear_has_non_unique_name();
    non_unique_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int64 sync_timestamp = 9;
inline bool SyncEntity::has_sync_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SyncEntity::set_has_sync_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SyncEntity::clear_has_sync_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SyncEntity::clear_sync_timestamp() {
  sync_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_sync_timestamp();
}
inline ::google::protobuf::int64 SyncEntity::sync_timestamp() const {
  return sync_timestamp_;
}
inline void SyncEntity::set_sync_timestamp(::google::protobuf::int64 value) {
  set_has_sync_timestamp();
  sync_timestamp_ = value;
}

// optional string server_defined_unique_tag = 10;
inline bool SyncEntity::has_server_defined_unique_tag() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SyncEntity::set_has_server_defined_unique_tag() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SyncEntity::clear_has_server_defined_unique_tag() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SyncEntity::clear_server_defined_unique_tag() {
  if (server_defined_unique_tag_ != &::google::protobuf::internal::GetEmptyString()) {
    server_defined_unique_tag_->clear();
  }
  clear_has_server_defined_unique_tag();
}
inline const ::std::string& SyncEntity::server_defined_unique_tag() const {
  return *server_defined_unique_tag_;
}
inline void SyncEntity::set_server_defined_unique_tag(const ::std::string& value) {
  set_has_server_defined_unique_tag();
  if (server_defined_unique_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    server_defined_unique_tag_ = new ::std::string;
  }
  server_defined_unique_tag_->assign(value);
}
inline void SyncEntity::set_server_defined_unique_tag(const char* value) {
  set_has_server_defined_unique_tag();
  if (server_defined_unique_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    server_defined_unique_tag_ = new ::std::string;
  }
  server_defined_unique_tag_->assign(value);
}
inline void SyncEntity::set_server_defined_unique_tag(const char* value, size_t size) {
  set_has_server_defined_unique_tag();
  if (server_defined_unique_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    server_defined_unique_tag_ = new ::std::string;
  }
  server_defined_unique_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_server_defined_unique_tag() {
  set_has_server_defined_unique_tag();
  if (server_defined_unique_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    server_defined_unique_tag_ = new ::std::string;
  }
  return server_defined_unique_tag_;
}
inline ::std::string* SyncEntity::release_server_defined_unique_tag() {
  clear_has_server_defined_unique_tag();
  if (server_defined_unique_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = server_defined_unique_tag_;
    server_defined_unique_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_server_defined_unique_tag(::std::string* server_defined_unique_tag) {
  if (server_defined_unique_tag_ != &::google::protobuf::internal::GetEmptyString()) {
    delete server_defined_unique_tag_;
  }
  if (server_defined_unique_tag) {
    set_has_server_defined_unique_tag();
    server_defined_unique_tag_ = server_defined_unique_tag;
  } else {
    clear_has_server_defined_unique_tag();
    server_defined_unique_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional group BookmarkData = 11 {
inline bool SyncEntity::has_bookmarkdata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SyncEntity::set_has_bookmarkdata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SyncEntity::clear_has_bookmarkdata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SyncEntity::clear_bookmarkdata() {
  if (bookmarkdata_ != NULL) bookmarkdata_->::sync_pb::SyncEntity_BookmarkData::Clear();
  clear_has_bookmarkdata();
}
inline const ::sync_pb::SyncEntity_BookmarkData& SyncEntity::bookmarkdata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bookmarkdata_ != NULL ? *bookmarkdata_ : *default_instance().bookmarkdata_;
#else
  return bookmarkdata_ != NULL ? *bookmarkdata_ : *default_instance_->bookmarkdata_;
#endif
}
inline ::sync_pb::SyncEntity_BookmarkData* SyncEntity::mutable_bookmarkdata() {
  set_has_bookmarkdata();
  if (bookmarkdata_ == NULL) bookmarkdata_ = new ::sync_pb::SyncEntity_BookmarkData;
  return bookmarkdata_;
}
inline ::sync_pb::SyncEntity_BookmarkData* SyncEntity::release_bookmarkdata() {
  clear_has_bookmarkdata();
  ::sync_pb::SyncEntity_BookmarkData* temp = bookmarkdata_;
  bookmarkdata_ = NULL;
  return temp;
}
inline void SyncEntity::set_allocated_bookmarkdata(::sync_pb::SyncEntity_BookmarkData* bookmarkdata) {
  delete bookmarkdata_;
  bookmarkdata_ = bookmarkdata;
  if (bookmarkdata) {
    set_has_bookmarkdata();
  } else {
    clear_has_bookmarkdata();
  }
}

// optional int64 position_in_parent = 15;
inline bool SyncEntity::has_position_in_parent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SyncEntity::set_has_position_in_parent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SyncEntity::clear_has_position_in_parent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SyncEntity::clear_position_in_parent() {
  position_in_parent_ = GOOGLE_LONGLONG(0);
  clear_has_position_in_parent();
}
inline ::google::protobuf::int64 SyncEntity::position_in_parent() const {
  return position_in_parent_;
}
inline void SyncEntity::set_position_in_parent(::google::protobuf::int64 value) {
  set_has_position_in_parent();
  position_in_parent_ = value;
}

// optional string insert_after_item_id = 16;
inline bool SyncEntity::has_insert_after_item_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SyncEntity::set_has_insert_after_item_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SyncEntity::clear_has_insert_after_item_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SyncEntity::clear_insert_after_item_id() {
  if (insert_after_item_id_ != &::google::protobuf::internal::GetEmptyString()) {
    insert_after_item_id_->clear();
  }
  clear_has_insert_after_item_id();
}
inline const ::std::string& SyncEntity::insert_after_item_id() const {
  return *insert_after_item_id_;
}
inline void SyncEntity::set_insert_after_item_id(const ::std::string& value) {
  set_has_insert_after_item_id();
  if (insert_after_item_id_ == &::google::protobuf::internal::GetEmptyString()) {
    insert_after_item_id_ = new ::std::string;
  }
  insert_after_item_id_->assign(value);
}
inline void SyncEntity::set_insert_after_item_id(const char* value) {
  set_has_insert_after_item_id();
  if (insert_after_item_id_ == &::google::protobuf::internal::GetEmptyString()) {
    insert_after_item_id_ = new ::std::string;
  }
  insert_after_item_id_->assign(value);
}
inline void SyncEntity::set_insert_after_item_id(const char* value, size_t size) {
  set_has_insert_after_item_id();
  if (insert_after_item_id_ == &::google::protobuf::internal::GetEmptyString()) {
    insert_after_item_id_ = new ::std::string;
  }
  insert_after_item_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_insert_after_item_id() {
  set_has_insert_after_item_id();
  if (insert_after_item_id_ == &::google::protobuf::internal::GetEmptyString()) {
    insert_after_item_id_ = new ::std::string;
  }
  return insert_after_item_id_;
}
inline ::std::string* SyncEntity::release_insert_after_item_id() {
  clear_has_insert_after_item_id();
  if (insert_after_item_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = insert_after_item_id_;
    insert_after_item_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_insert_after_item_id(::std::string* insert_after_item_id) {
  if (insert_after_item_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete insert_after_item_id_;
  }
  if (insert_after_item_id) {
    set_has_insert_after_item_id();
    insert_after_item_id_ = insert_after_item_id;
  } else {
    clear_has_insert_after_item_id();
    insert_after_item_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bool deleted = 18 [default = false];
inline bool SyncEntity::has_deleted() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SyncEntity::set_has_deleted() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SyncEntity::clear_has_deleted() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SyncEntity::clear_deleted() {
  deleted_ = false;
  clear_has_deleted();
}
inline bool SyncEntity::deleted() const {
  return deleted_;
}
inline void SyncEntity::set_deleted(bool value) {
  set_has_deleted();
  deleted_ = value;
}

// optional string originator_cache_guid = 19;
inline bool SyncEntity::has_originator_cache_guid() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SyncEntity::set_has_originator_cache_guid() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SyncEntity::clear_has_originator_cache_guid() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SyncEntity::clear_originator_cache_guid() {
  if (originator_cache_guid_ != &::google::protobuf::internal::GetEmptyString()) {
    originator_cache_guid_->clear();
  }
  clear_has_originator_cache_guid();
}
inline const ::std::string& SyncEntity::originator_cache_guid() const {
  return *originator_cache_guid_;
}
inline void SyncEntity::set_originator_cache_guid(const ::std::string& value) {
  set_has_originator_cache_guid();
  if (originator_cache_guid_ == &::google::protobuf::internal::GetEmptyString()) {
    originator_cache_guid_ = new ::std::string;
  }
  originator_cache_guid_->assign(value);
}
inline void SyncEntity::set_originator_cache_guid(const char* value) {
  set_has_originator_cache_guid();
  if (originator_cache_guid_ == &::google::protobuf::internal::GetEmptyString()) {
    originator_cache_guid_ = new ::std::string;
  }
  originator_cache_guid_->assign(value);
}
inline void SyncEntity::set_originator_cache_guid(const char* value, size_t size) {
  set_has_originator_cache_guid();
  if (originator_cache_guid_ == &::google::protobuf::internal::GetEmptyString()) {
    originator_cache_guid_ = new ::std::string;
  }
  originator_cache_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_originator_cache_guid() {
  set_has_originator_cache_guid();
  if (originator_cache_guid_ == &::google::protobuf::internal::GetEmptyString()) {
    originator_cache_guid_ = new ::std::string;
  }
  return originator_cache_guid_;
}
inline ::std::string* SyncEntity::release_originator_cache_guid() {
  clear_has_originator_cache_guid();
  if (originator_cache_guid_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = originator_cache_guid_;
    originator_cache_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_originator_cache_guid(::std::string* originator_cache_guid) {
  if (originator_cache_guid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete originator_cache_guid_;
  }
  if (originator_cache_guid) {
    set_has_originator_cache_guid();
    originator_cache_guid_ = originator_cache_guid;
  } else {
    clear_has_originator_cache_guid();
    originator_cache_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string originator_client_item_id = 20;
inline bool SyncEntity::has_originator_client_item_id() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SyncEntity::set_has_originator_client_item_id() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SyncEntity::clear_has_originator_client_item_id() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SyncEntity::clear_originator_client_item_id() {
  if (originator_client_item_id_ != &::google::protobuf::internal::GetEmptyString()) {
    originator_client_item_id_->clear();
  }
  clear_has_originator_client_item_id();
}
inline const ::std::string& SyncEntity::originator_client_item_id() const {
  return *originator_client_item_id_;
}
inline void SyncEntity::set_originator_client_item_id(const ::std::string& value) {
  set_has_originator_client_item_id();
  if (originator_client_item_id_ == &::google::protobuf::internal::GetEmptyString()) {
    originator_client_item_id_ = new ::std::string;
  }
  originator_client_item_id_->assign(value);
}
inline void SyncEntity::set_originator_client_item_id(const char* value) {
  set_has_originator_client_item_id();
  if (originator_client_item_id_ == &::google::protobuf::internal::GetEmptyString()) {
    originator_client_item_id_ = new ::std::string;
  }
  originator_client_item_id_->assign(value);
}
inline void SyncEntity::set_originator_client_item_id(const char* value, size_t size) {
  set_has_originator_client_item_id();
  if (originator_client_item_id_ == &::google::protobuf::internal::GetEmptyString()) {
    originator_client_item_id_ = new ::std::string;
  }
  originator_client_item_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_originator_client_item_id() {
  set_has_originator_client_item_id();
  if (originator_client_item_id_ == &::google::protobuf::internal::GetEmptyString()) {
    originator_client_item_id_ = new ::std::string;
  }
  return originator_client_item_id_;
}
inline ::std::string* SyncEntity::release_originator_client_item_id() {
  clear_has_originator_client_item_id();
  if (originator_client_item_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = originator_client_item_id_;
    originator_client_item_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_originator_client_item_id(::std::string* originator_client_item_id) {
  if (originator_client_item_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete originator_client_item_id_;
  }
  if (originator_client_item_id) {
    set_has_originator_client_item_id();
    originator_client_item_id_ = originator_client_item_id;
  } else {
    clear_has_originator_client_item_id();
    originator_client_item_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.EntitySpecifics specifics = 21;
inline bool SyncEntity::has_specifics() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SyncEntity::set_has_specifics() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SyncEntity::clear_has_specifics() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SyncEntity::clear_specifics() {
  if (specifics_ != NULL) specifics_->::sync_pb::EntitySpecifics::Clear();
  clear_has_specifics();
}
inline const ::sync_pb::EntitySpecifics& SyncEntity::specifics() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return specifics_ != NULL ? *specifics_ : *default_instance().specifics_;
#else
  return specifics_ != NULL ? *specifics_ : *default_instance_->specifics_;
#endif
}
inline ::sync_pb::EntitySpecifics* SyncEntity::mutable_specifics() {
  set_has_specifics();
  if (specifics_ == NULL) specifics_ = new ::sync_pb::EntitySpecifics;
  return specifics_;
}
inline ::sync_pb::EntitySpecifics* SyncEntity::release_specifics() {
  clear_has_specifics();
  ::sync_pb::EntitySpecifics* temp = specifics_;
  specifics_ = NULL;
  return temp;
}
inline void SyncEntity::set_allocated_specifics(::sync_pb::EntitySpecifics* specifics) {
  delete specifics_;
  specifics_ = specifics;
  if (specifics) {
    set_has_specifics();
  } else {
    clear_has_specifics();
  }
}

// optional bool folder = 22 [default = false];
inline bool SyncEntity::has_folder() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SyncEntity::set_has_folder() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SyncEntity::clear_has_folder() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SyncEntity::clear_folder() {
  folder_ = false;
  clear_has_folder();
}
inline bool SyncEntity::folder() const {
  return folder_;
}
inline void SyncEntity::set_folder(bool value) {
  set_has_folder();
  folder_ = value;
}

// optional string client_defined_unique_tag = 23;
inline bool SyncEntity::has_client_defined_unique_tag() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SyncEntity::set_has_client_defined_unique_tag() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SyncEntity::clear_has_client_defined_unique_tag() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SyncEntity::clear_client_defined_unique_tag() {
  if (client_defined_unique_tag_ != &::google::protobuf::internal::GetEmptyString()) {
    client_defined_unique_tag_->clear();
  }
  clear_has_client_defined_unique_tag();
}
inline const ::std::string& SyncEntity::client_defined_unique_tag() const {
  return *client_defined_unique_tag_;
}
inline void SyncEntity::set_client_defined_unique_tag(const ::std::string& value) {
  set_has_client_defined_unique_tag();
  if (client_defined_unique_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    client_defined_unique_tag_ = new ::std::string;
  }
  client_defined_unique_tag_->assign(value);
}
inline void SyncEntity::set_client_defined_unique_tag(const char* value) {
  set_has_client_defined_unique_tag();
  if (client_defined_unique_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    client_defined_unique_tag_ = new ::std::string;
  }
  client_defined_unique_tag_->assign(value);
}
inline void SyncEntity::set_client_defined_unique_tag(const char* value, size_t size) {
  set_has_client_defined_unique_tag();
  if (client_defined_unique_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    client_defined_unique_tag_ = new ::std::string;
  }
  client_defined_unique_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_client_defined_unique_tag() {
  set_has_client_defined_unique_tag();
  if (client_defined_unique_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    client_defined_unique_tag_ = new ::std::string;
  }
  return client_defined_unique_tag_;
}
inline ::std::string* SyncEntity::release_client_defined_unique_tag() {
  clear_has_client_defined_unique_tag();
  if (client_defined_unique_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = client_defined_unique_tag_;
    client_defined_unique_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_client_defined_unique_tag(::std::string* client_defined_unique_tag) {
  if (client_defined_unique_tag_ != &::google::protobuf::internal::GetEmptyString()) {
    delete client_defined_unique_tag_;
  }
  if (client_defined_unique_tag) {
    set_has_client_defined_unique_tag();
    client_defined_unique_tag_ = client_defined_unique_tag;
  } else {
    clear_has_client_defined_unique_tag();
    client_defined_unique_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes ordinal_in_parent = 24;
inline bool SyncEntity::has_ordinal_in_parent() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SyncEntity::set_has_ordinal_in_parent() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SyncEntity::clear_has_ordinal_in_parent() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SyncEntity::clear_ordinal_in_parent() {
  if (ordinal_in_parent_ != &::google::protobuf::internal::GetEmptyString()) {
    ordinal_in_parent_->clear();
  }
  clear_has_ordinal_in_parent();
}
inline const ::std::string& SyncEntity::ordinal_in_parent() const {
  return *ordinal_in_parent_;
}
inline void SyncEntity::set_ordinal_in_parent(const ::std::string& value) {
  set_has_ordinal_in_parent();
  if (ordinal_in_parent_ == &::google::protobuf::internal::GetEmptyString()) {
    ordinal_in_parent_ = new ::std::string;
  }
  ordinal_in_parent_->assign(value);
}
inline void SyncEntity::set_ordinal_in_parent(const char* value) {
  set_has_ordinal_in_parent();
  if (ordinal_in_parent_ == &::google::protobuf::internal::GetEmptyString()) {
    ordinal_in_parent_ = new ::std::string;
  }
  ordinal_in_parent_->assign(value);
}
inline void SyncEntity::set_ordinal_in_parent(const void* value, size_t size) {
  set_has_ordinal_in_parent();
  if (ordinal_in_parent_ == &::google::protobuf::internal::GetEmptyString()) {
    ordinal_in_parent_ = new ::std::string;
  }
  ordinal_in_parent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncEntity::mutable_ordinal_in_parent() {
  set_has_ordinal_in_parent();
  if (ordinal_in_parent_ == &::google::protobuf::internal::GetEmptyString()) {
    ordinal_in_parent_ = new ::std::string;
  }
  return ordinal_in_parent_;
}
inline ::std::string* SyncEntity::release_ordinal_in_parent() {
  clear_has_ordinal_in_parent();
  if (ordinal_in_parent_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = ordinal_in_parent_;
    ordinal_in_parent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncEntity::set_allocated_ordinal_in_parent(::std::string* ordinal_in_parent) {
  if (ordinal_in_parent_ != &::google::protobuf::internal::GetEmptyString()) {
    delete ordinal_in_parent_;
  }
  if (ordinal_in_parent) {
    set_has_ordinal_in_parent();
    ordinal_in_parent_ = ordinal_in_parent;
  } else {
    clear_has_ordinal_in_parent();
    ordinal_in_parent_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.UniquePosition unique_position = 25;
inline bool SyncEntity::has_unique_position() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SyncEntity::set_has_unique_position() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SyncEntity::clear_has_unique_position() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SyncEntity::clear_unique_position() {
  if (unique_position_ != NULL) unique_position_->::sync_pb::UniquePosition::Clear();
  clear_has_unique_position();
}
inline const ::sync_pb::UniquePosition& SyncEntity::unique_position() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return unique_position_ != NULL ? *unique_position_ : *default_instance().unique_position_;
#else
  return unique_position_ != NULL ? *unique_position_ : *default_instance_->unique_position_;
#endif
}
inline ::sync_pb::UniquePosition* SyncEntity::mutable_unique_position() {
  set_has_unique_position();
  if (unique_position_ == NULL) unique_position_ = new ::sync_pb::UniquePosition;
  return unique_position_;
}
inline ::sync_pb::UniquePosition* SyncEntity::release_unique_position() {
  clear_has_unique_position();
  ::sync_pb::UniquePosition* temp = unique_position_;
  unique_position_ = NULL;
  return temp;
}
inline void SyncEntity::set_allocated_unique_position(::sync_pb::UniquePosition* unique_position) {
  delete unique_position_;
  unique_position_ = unique_position;
  if (unique_position) {
    set_has_unique_position();
  } else {
    clear_has_unique_position();
  }
}

// -------------------------------------------------------------------

// ChromiumExtensionsActivity

// optional string extension_id = 1;
inline bool ChromiumExtensionsActivity::has_extension_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChromiumExtensionsActivity::set_has_extension_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChromiumExtensionsActivity::clear_has_extension_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChromiumExtensionsActivity::clear_extension_id() {
  if (extension_id_ != &::google::protobuf::internal::GetEmptyString()) {
    extension_id_->clear();
  }
  clear_has_extension_id();
}
inline const ::std::string& ChromiumExtensionsActivity::extension_id() const {
  return *extension_id_;
}
inline void ChromiumExtensionsActivity::set_extension_id(const ::std::string& value) {
  set_has_extension_id();
  if (extension_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_id_ = new ::std::string;
  }
  extension_id_->assign(value);
}
inline void ChromiumExtensionsActivity::set_extension_id(const char* value) {
  set_has_extension_id();
  if (extension_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_id_ = new ::std::string;
  }
  extension_id_->assign(value);
}
inline void ChromiumExtensionsActivity::set_extension_id(const char* value, size_t size) {
  set_has_extension_id();
  if (extension_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_id_ = new ::std::string;
  }
  extension_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChromiumExtensionsActivity::mutable_extension_id() {
  set_has_extension_id();
  if (extension_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_id_ = new ::std::string;
  }
  return extension_id_;
}
inline ::std::string* ChromiumExtensionsActivity::release_extension_id() {
  clear_has_extension_id();
  if (extension_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = extension_id_;
    extension_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ChromiumExtensionsActivity::set_allocated_extension_id(::std::string* extension_id) {
  if (extension_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete extension_id_;
  }
  if (extension_id) {
    set_has_extension_id();
    extension_id_ = extension_id;
  } else {
    clear_has_extension_id();
    extension_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional uint32 bookmark_writes_since_last_commit = 2;
inline bool ChromiumExtensionsActivity::has_bookmark_writes_since_last_commit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChromiumExtensionsActivity::set_has_bookmark_writes_since_last_commit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChromiumExtensionsActivity::clear_has_bookmark_writes_since_last_commit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChromiumExtensionsActivity::clear_bookmark_writes_since_last_commit() {
  bookmark_writes_since_last_commit_ = 0u;
  clear_has_bookmark_writes_since_last_commit();
}
inline ::google::protobuf::uint32 ChromiumExtensionsActivity::bookmark_writes_since_last_commit() const {
  return bookmark_writes_since_last_commit_;
}
inline void ChromiumExtensionsActivity::set_bookmark_writes_since_last_commit(::google::protobuf::uint32 value) {
  set_has_bookmark_writes_since_last_commit();
  bookmark_writes_since_last_commit_ = value;
}

// -------------------------------------------------------------------

// ClientConfigParams

// repeated int32 enabled_type_ids = 1;
inline int ClientConfigParams::enabled_type_ids_size() const {
  return enabled_type_ids_.size();
}
inline void ClientConfigParams::clear_enabled_type_ids() {
  enabled_type_ids_.Clear();
}
inline ::google::protobuf::int32 ClientConfigParams::enabled_type_ids(int index) const {
  return enabled_type_ids_.Get(index);
}
inline void ClientConfigParams::set_enabled_type_ids(int index, ::google::protobuf::int32 value) {
  enabled_type_ids_.Set(index, value);
}
inline void ClientConfigParams::add_enabled_type_ids(::google::protobuf::int32 value) {
  enabled_type_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ClientConfigParams::enabled_type_ids() const {
  return enabled_type_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ClientConfigParams::mutable_enabled_type_ids() {
  return &enabled_type_ids_;
}

// optional bool tabs_datatype_enabled = 2;
inline bool ClientConfigParams::has_tabs_datatype_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientConfigParams::set_has_tabs_datatype_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientConfigParams::clear_has_tabs_datatype_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientConfigParams::clear_tabs_datatype_enabled() {
  tabs_datatype_enabled_ = false;
  clear_has_tabs_datatype_enabled();
}
inline bool ClientConfigParams::tabs_datatype_enabled() const {
  return tabs_datatype_enabled_;
}
inline void ClientConfigParams::set_tabs_datatype_enabled(bool value) {
  set_has_tabs_datatype_enabled();
  tabs_datatype_enabled_ = value;
}

// -------------------------------------------------------------------

// CommitMessage

// repeated .sync_pb.SyncEntity entries = 1;
inline int CommitMessage::entries_size() const {
  return entries_.size();
}
inline void CommitMessage::clear_entries() {
  entries_.Clear();
}
inline const ::sync_pb::SyncEntity& CommitMessage::entries(int index) const {
  return entries_.Get(index);
}
inline ::sync_pb::SyncEntity* CommitMessage::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::sync_pb::SyncEntity* CommitMessage::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >&
CommitMessage::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >*
CommitMessage::mutable_entries() {
  return &entries_;
}

// optional string cache_guid = 2;
inline bool CommitMessage::has_cache_guid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitMessage::set_has_cache_guid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitMessage::clear_has_cache_guid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitMessage::clear_cache_guid() {
  if (cache_guid_ != &::google::protobuf::internal::GetEmptyString()) {
    cache_guid_->clear();
  }
  clear_has_cache_guid();
}
inline const ::std::string& CommitMessage::cache_guid() const {
  return *cache_guid_;
}
inline void CommitMessage::set_cache_guid(const ::std::string& value) {
  set_has_cache_guid();
  if (cache_guid_ == &::google::protobuf::internal::GetEmptyString()) {
    cache_guid_ = new ::std::string;
  }
  cache_guid_->assign(value);
}
inline void CommitMessage::set_cache_guid(const char* value) {
  set_has_cache_guid();
  if (cache_guid_ == &::google::protobuf::internal::GetEmptyString()) {
    cache_guid_ = new ::std::string;
  }
  cache_guid_->assign(value);
}
inline void CommitMessage::set_cache_guid(const char* value, size_t size) {
  set_has_cache_guid();
  if (cache_guid_ == &::google::protobuf::internal::GetEmptyString()) {
    cache_guid_ = new ::std::string;
  }
  cache_guid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommitMessage::mutable_cache_guid() {
  set_has_cache_guid();
  if (cache_guid_ == &::google::protobuf::internal::GetEmptyString()) {
    cache_guid_ = new ::std::string;
  }
  return cache_guid_;
}
inline ::std::string* CommitMessage::release_cache_guid() {
  clear_has_cache_guid();
  if (cache_guid_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = cache_guid_;
    cache_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CommitMessage::set_allocated_cache_guid(::std::string* cache_guid) {
  if (cache_guid_ != &::google::protobuf::internal::GetEmptyString()) {
    delete cache_guid_;
  }
  if (cache_guid) {
    set_has_cache_guid();
    cache_guid_ = cache_guid;
  } else {
    clear_has_cache_guid();
    cache_guid_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .sync_pb.ChromiumExtensionsActivity extensions_activity = 3;
inline int CommitMessage::extensions_activity_size() const {
  return extensions_activity_.size();
}
inline void CommitMessage::clear_extensions_activity() {
  extensions_activity_.Clear();
}
inline const ::sync_pb::ChromiumExtensionsActivity& CommitMessage::extensions_activity(int index) const {
  return extensions_activity_.Get(index);
}
inline ::sync_pb::ChromiumExtensionsActivity* CommitMessage::mutable_extensions_activity(int index) {
  return extensions_activity_.Mutable(index);
}
inline ::sync_pb::ChromiumExtensionsActivity* CommitMessage::add_extensions_activity() {
  return extensions_activity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::ChromiumExtensionsActivity >&
CommitMessage::extensions_activity() const {
  return extensions_activity_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::ChromiumExtensionsActivity >*
CommitMessage::mutable_extensions_activity() {
  return &extensions_activity_;
}

// optional .sync_pb.ClientConfigParams config_params = 4;
inline bool CommitMessage::has_config_params() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommitMessage::set_has_config_params() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommitMessage::clear_has_config_params() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommitMessage::clear_config_params() {
  if (config_params_ != NULL) config_params_->::sync_pb::ClientConfigParams::Clear();
  clear_has_config_params();
}
inline const ::sync_pb::ClientConfigParams& CommitMessage::config_params() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return config_params_ != NULL ? *config_params_ : *default_instance().config_params_;
#else
  return config_params_ != NULL ? *config_params_ : *default_instance_->config_params_;
#endif
}
inline ::sync_pb::ClientConfigParams* CommitMessage::mutable_config_params() {
  set_has_config_params();
  if (config_params_ == NULL) config_params_ = new ::sync_pb::ClientConfigParams;
  return config_params_;
}
inline ::sync_pb::ClientConfigParams* CommitMessage::release_config_params() {
  clear_has_config_params();
  ::sync_pb::ClientConfigParams* temp = config_params_;
  config_params_ = NULL;
  return temp;
}
inline void CommitMessage::set_allocated_config_params(::sync_pb::ClientConfigParams* config_params) {
  delete config_params_;
  config_params_ = config_params;
  if (config_params) {
    set_has_config_params();
  } else {
    clear_has_config_params();
  }
}

// -------------------------------------------------------------------

// GetUpdateTriggers

// repeated string notification_hint = 1;
inline int GetUpdateTriggers::notification_hint_size() const {
  return notification_hint_.size();
}
inline void GetUpdateTriggers::clear_notification_hint() {
  notification_hint_.Clear();
}
inline const ::std::string& GetUpdateTriggers::notification_hint(int index) const {
  return notification_hint_.Get(index);
}
inline ::std::string* GetUpdateTriggers::mutable_notification_hint(int index) {
  return notification_hint_.Mutable(index);
}
inline void GetUpdateTriggers::set_notification_hint(int index, const ::std::string& value) {
  notification_hint_.Mutable(index)->assign(value);
}
inline void GetUpdateTriggers::set_notification_hint(int index, const char* value) {
  notification_hint_.Mutable(index)->assign(value);
}
inline void GetUpdateTriggers::set_notification_hint(int index, const char* value, size_t size) {
  notification_hint_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUpdateTriggers::add_notification_hint() {
  return notification_hint_.Add();
}
inline void GetUpdateTriggers::add_notification_hint(const ::std::string& value) {
  notification_hint_.Add()->assign(value);
}
inline void GetUpdateTriggers::add_notification_hint(const char* value) {
  notification_hint_.Add()->assign(value);
}
inline void GetUpdateTriggers::add_notification_hint(const char* value, size_t size) {
  notification_hint_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetUpdateTriggers::notification_hint() const {
  return notification_hint_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetUpdateTriggers::mutable_notification_hint() {
  return &notification_hint_;
}

// optional bool client_dropped_hints = 2;
inline bool GetUpdateTriggers::has_client_dropped_hints() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUpdateTriggers::set_has_client_dropped_hints() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUpdateTriggers::clear_has_client_dropped_hints() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUpdateTriggers::clear_client_dropped_hints() {
  client_dropped_hints_ = false;
  clear_has_client_dropped_hints();
}
inline bool GetUpdateTriggers::client_dropped_hints() const {
  return client_dropped_hints_;
}
inline void GetUpdateTriggers::set_client_dropped_hints(bool value) {
  set_has_client_dropped_hints();
  client_dropped_hints_ = value;
}

// optional bool invalidations_out_of_sync = 3;
inline bool GetUpdateTriggers::has_invalidations_out_of_sync() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUpdateTriggers::set_has_invalidations_out_of_sync() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUpdateTriggers::clear_has_invalidations_out_of_sync() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUpdateTriggers::clear_invalidations_out_of_sync() {
  invalidations_out_of_sync_ = false;
  clear_has_invalidations_out_of_sync();
}
inline bool GetUpdateTriggers::invalidations_out_of_sync() const {
  return invalidations_out_of_sync_;
}
inline void GetUpdateTriggers::set_invalidations_out_of_sync(bool value) {
  set_has_invalidations_out_of_sync();
  invalidations_out_of_sync_ = value;
}

// optional int64 local_modification_nudges = 4;
inline bool GetUpdateTriggers::has_local_modification_nudges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetUpdateTriggers::set_has_local_modification_nudges() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetUpdateTriggers::clear_has_local_modification_nudges() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetUpdateTriggers::clear_local_modification_nudges() {
  local_modification_nudges_ = GOOGLE_LONGLONG(0);
  clear_has_local_modification_nudges();
}
inline ::google::protobuf::int64 GetUpdateTriggers::local_modification_nudges() const {
  return local_modification_nudges_;
}
inline void GetUpdateTriggers::set_local_modification_nudges(::google::protobuf::int64 value) {
  set_has_local_modification_nudges();
  local_modification_nudges_ = value;
}

// optional int64 datatype_refresh_nudges = 5;
inline bool GetUpdateTriggers::has_datatype_refresh_nudges() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetUpdateTriggers::set_has_datatype_refresh_nudges() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetUpdateTriggers::clear_has_datatype_refresh_nudges() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetUpdateTriggers::clear_datatype_refresh_nudges() {
  datatype_refresh_nudges_ = GOOGLE_LONGLONG(0);
  clear_has_datatype_refresh_nudges();
}
inline ::google::protobuf::int64 GetUpdateTriggers::datatype_refresh_nudges() const {
  return datatype_refresh_nudges_;
}
inline void GetUpdateTriggers::set_datatype_refresh_nudges(::google::protobuf::int64 value) {
  set_has_datatype_refresh_nudges();
  datatype_refresh_nudges_ = value;
}

// optional bool server_dropped_hints = 6;
inline bool GetUpdateTriggers::has_server_dropped_hints() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GetUpdateTriggers::set_has_server_dropped_hints() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GetUpdateTriggers::clear_has_server_dropped_hints() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GetUpdateTriggers::clear_server_dropped_hints() {
  server_dropped_hints_ = false;
  clear_has_server_dropped_hints();
}
inline bool GetUpdateTriggers::server_dropped_hints() const {
  return server_dropped_hints_;
}
inline void GetUpdateTriggers::set_server_dropped_hints(bool value) {
  set_has_server_dropped_hints();
  server_dropped_hints_ = value;
}

// -------------------------------------------------------------------

// GarbageCollectionDirective

// optional .sync_pb.GarbageCollectionDirective.Type type = 1 [default = UNKNOWN];
inline bool GarbageCollectionDirective::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GarbageCollectionDirective::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GarbageCollectionDirective::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GarbageCollectionDirective::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::sync_pb::GarbageCollectionDirective_Type GarbageCollectionDirective::type() const {
  return static_cast< ::sync_pb::GarbageCollectionDirective_Type >(type_);
}
inline void GarbageCollectionDirective::set_type(::sync_pb::GarbageCollectionDirective_Type value) {
  assert(::sync_pb::GarbageCollectionDirective_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int64 version_watermark = 2;
inline bool GarbageCollectionDirective::has_version_watermark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GarbageCollectionDirective::set_has_version_watermark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GarbageCollectionDirective::clear_has_version_watermark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GarbageCollectionDirective::clear_version_watermark() {
  version_watermark_ = GOOGLE_LONGLONG(0);
  clear_has_version_watermark();
}
inline ::google::protobuf::int64 GarbageCollectionDirective::version_watermark() const {
  return version_watermark_;
}
inline void GarbageCollectionDirective::set_version_watermark(::google::protobuf::int64 value) {
  set_has_version_watermark();
  version_watermark_ = value;
}

// optional int32 age_watermark_in_days = 3;
inline bool GarbageCollectionDirective::has_age_watermark_in_days() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GarbageCollectionDirective::set_has_age_watermark_in_days() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GarbageCollectionDirective::clear_has_age_watermark_in_days() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GarbageCollectionDirective::clear_age_watermark_in_days() {
  age_watermark_in_days_ = 0;
  clear_has_age_watermark_in_days();
}
inline ::google::protobuf::int32 GarbageCollectionDirective::age_watermark_in_days() const {
  return age_watermark_in_days_;
}
inline void GarbageCollectionDirective::set_age_watermark_in_days(::google::protobuf::int32 value) {
  set_has_age_watermark_in_days();
  age_watermark_in_days_ = value;
}

// optional int32 max_number_of_items = 4;
inline bool GarbageCollectionDirective::has_max_number_of_items() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GarbageCollectionDirective::set_has_max_number_of_items() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GarbageCollectionDirective::clear_has_max_number_of_items() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GarbageCollectionDirective::clear_max_number_of_items() {
  max_number_of_items_ = 0;
  clear_has_max_number_of_items();
}
inline ::google::protobuf::int32 GarbageCollectionDirective::max_number_of_items() const {
  return max_number_of_items_;
}
inline void GarbageCollectionDirective::set_max_number_of_items(::google::protobuf::int32 value) {
  set_has_max_number_of_items();
  max_number_of_items_ = value;
}

// -------------------------------------------------------------------

// DataTypeProgressMarker

// optional int32 data_type_id = 1;
inline bool DataTypeProgressMarker::has_data_type_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DataTypeProgressMarker::set_has_data_type_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DataTypeProgressMarker::clear_has_data_type_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DataTypeProgressMarker::clear_data_type_id() {
  data_type_id_ = 0;
  clear_has_data_type_id();
}
inline ::google::protobuf::int32 DataTypeProgressMarker::data_type_id() const {
  return data_type_id_;
}
inline void DataTypeProgressMarker::set_data_type_id(::google::protobuf::int32 value) {
  set_has_data_type_id();
  data_type_id_ = value;
}

// optional bytes token = 2;
inline bool DataTypeProgressMarker::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DataTypeProgressMarker::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DataTypeProgressMarker::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DataTypeProgressMarker::clear_token() {
  if (token_ != &::google::protobuf::internal::GetEmptyString()) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& DataTypeProgressMarker::token() const {
  return *token_;
}
inline void DataTypeProgressMarker::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyString()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void DataTypeProgressMarker::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyString()) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void DataTypeProgressMarker::set_token(const void* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyString()) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataTypeProgressMarker::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyString()) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* DataTypeProgressMarker::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataTypeProgressMarker::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::GetEmptyString()) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int64 timestamp_token_for_migration = 3;
inline bool DataTypeProgressMarker::has_timestamp_token_for_migration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DataTypeProgressMarker::set_has_timestamp_token_for_migration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DataTypeProgressMarker::clear_has_timestamp_token_for_migration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DataTypeProgressMarker::clear_timestamp_token_for_migration() {
  timestamp_token_for_migration_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp_token_for_migration();
}
inline ::google::protobuf::int64 DataTypeProgressMarker::timestamp_token_for_migration() const {
  return timestamp_token_for_migration_;
}
inline void DataTypeProgressMarker::set_timestamp_token_for_migration(::google::protobuf::int64 value) {
  set_has_timestamp_token_for_migration();
  timestamp_token_for_migration_ = value;
}

// optional string notification_hint = 4;
inline bool DataTypeProgressMarker::has_notification_hint() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DataTypeProgressMarker::set_has_notification_hint() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DataTypeProgressMarker::clear_has_notification_hint() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DataTypeProgressMarker::clear_notification_hint() {
  if (notification_hint_ != &::google::protobuf::internal::GetEmptyString()) {
    notification_hint_->clear();
  }
  clear_has_notification_hint();
}
inline const ::std::string& DataTypeProgressMarker::notification_hint() const {
  return *notification_hint_;
}
inline void DataTypeProgressMarker::set_notification_hint(const ::std::string& value) {
  set_has_notification_hint();
  if (notification_hint_ == &::google::protobuf::internal::GetEmptyString()) {
    notification_hint_ = new ::std::string;
  }
  notification_hint_->assign(value);
}
inline void DataTypeProgressMarker::set_notification_hint(const char* value) {
  set_has_notification_hint();
  if (notification_hint_ == &::google::protobuf::internal::GetEmptyString()) {
    notification_hint_ = new ::std::string;
  }
  notification_hint_->assign(value);
}
inline void DataTypeProgressMarker::set_notification_hint(const char* value, size_t size) {
  set_has_notification_hint();
  if (notification_hint_ == &::google::protobuf::internal::GetEmptyString()) {
    notification_hint_ = new ::std::string;
  }
  notification_hint_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DataTypeProgressMarker::mutable_notification_hint() {
  set_has_notification_hint();
  if (notification_hint_ == &::google::protobuf::internal::GetEmptyString()) {
    notification_hint_ = new ::std::string;
  }
  return notification_hint_;
}
inline ::std::string* DataTypeProgressMarker::release_notification_hint() {
  clear_has_notification_hint();
  if (notification_hint_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = notification_hint_;
    notification_hint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void DataTypeProgressMarker::set_allocated_notification_hint(::std::string* notification_hint) {
  if (notification_hint_ != &::google::protobuf::internal::GetEmptyString()) {
    delete notification_hint_;
  }
  if (notification_hint) {
    set_has_notification_hint();
    notification_hint_ = notification_hint;
  } else {
    clear_has_notification_hint();
    notification_hint_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.GetUpdateTriggers get_update_triggers = 5;
inline bool DataTypeProgressMarker::has_get_update_triggers() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DataTypeProgressMarker::set_has_get_update_triggers() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DataTypeProgressMarker::clear_has_get_update_triggers() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DataTypeProgressMarker::clear_get_update_triggers() {
  if (get_update_triggers_ != NULL) get_update_triggers_->::sync_pb::GetUpdateTriggers::Clear();
  clear_has_get_update_triggers();
}
inline const ::sync_pb::GetUpdateTriggers& DataTypeProgressMarker::get_update_triggers() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return get_update_triggers_ != NULL ? *get_update_triggers_ : *default_instance().get_update_triggers_;
#else
  return get_update_triggers_ != NULL ? *get_update_triggers_ : *default_instance_->get_update_triggers_;
#endif
}
inline ::sync_pb::GetUpdateTriggers* DataTypeProgressMarker::mutable_get_update_triggers() {
  set_has_get_update_triggers();
  if (get_update_triggers_ == NULL) get_update_triggers_ = new ::sync_pb::GetUpdateTriggers;
  return get_update_triggers_;
}
inline ::sync_pb::GetUpdateTriggers* DataTypeProgressMarker::release_get_update_triggers() {
  clear_has_get_update_triggers();
  ::sync_pb::GetUpdateTriggers* temp = get_update_triggers_;
  get_update_triggers_ = NULL;
  return temp;
}
inline void DataTypeProgressMarker::set_allocated_get_update_triggers(::sync_pb::GetUpdateTriggers* get_update_triggers) {
  delete get_update_triggers_;
  get_update_triggers_ = get_update_triggers;
  if (get_update_triggers) {
    set_has_get_update_triggers();
  } else {
    clear_has_get_update_triggers();
  }
}

// optional .sync_pb.GarbageCollectionDirective gc_directive = 6;
inline bool DataTypeProgressMarker::has_gc_directive() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DataTypeProgressMarker::set_has_gc_directive() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DataTypeProgressMarker::clear_has_gc_directive() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DataTypeProgressMarker::clear_gc_directive() {
  if (gc_directive_ != NULL) gc_directive_->::sync_pb::GarbageCollectionDirective::Clear();
  clear_has_gc_directive();
}
inline const ::sync_pb::GarbageCollectionDirective& DataTypeProgressMarker::gc_directive() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gc_directive_ != NULL ? *gc_directive_ : *default_instance().gc_directive_;
#else
  return gc_directive_ != NULL ? *gc_directive_ : *default_instance_->gc_directive_;
#endif
}
inline ::sync_pb::GarbageCollectionDirective* DataTypeProgressMarker::mutable_gc_directive() {
  set_has_gc_directive();
  if (gc_directive_ == NULL) gc_directive_ = new ::sync_pb::GarbageCollectionDirective;
  return gc_directive_;
}
inline ::sync_pb::GarbageCollectionDirective* DataTypeProgressMarker::release_gc_directive() {
  clear_has_gc_directive();
  ::sync_pb::GarbageCollectionDirective* temp = gc_directive_;
  gc_directive_ = NULL;
  return temp;
}
inline void DataTypeProgressMarker::set_allocated_gc_directive(::sync_pb::GarbageCollectionDirective* gc_directive) {
  delete gc_directive_;
  gc_directive_ = gc_directive;
  if (gc_directive) {
    set_has_gc_directive();
  } else {
    clear_has_gc_directive();
  }
}

// -------------------------------------------------------------------

// GetUpdatesMessage

// optional int64 from_timestamp = 1;
inline bool GetUpdatesMessage::has_from_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUpdatesMessage::set_has_from_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUpdatesMessage::clear_has_from_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUpdatesMessage::clear_from_timestamp() {
  from_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_from_timestamp();
}
inline ::google::protobuf::int64 GetUpdatesMessage::from_timestamp() const {
  return from_timestamp_;
}
inline void GetUpdatesMessage::set_from_timestamp(::google::protobuf::int64 value) {
  set_has_from_timestamp();
  from_timestamp_ = value;
}

// optional .sync_pb.GetUpdatesCallerInfo caller_info = 2;
inline bool GetUpdatesMessage::has_caller_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUpdatesMessage::set_has_caller_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUpdatesMessage::clear_has_caller_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUpdatesMessage::clear_caller_info() {
  if (caller_info_ != NULL) caller_info_->::sync_pb::GetUpdatesCallerInfo::Clear();
  clear_has_caller_info();
}
inline const ::sync_pb::GetUpdatesCallerInfo& GetUpdatesMessage::caller_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return caller_info_ != NULL ? *caller_info_ : *default_instance().caller_info_;
#else
  return caller_info_ != NULL ? *caller_info_ : *default_instance_->caller_info_;
#endif
}
inline ::sync_pb::GetUpdatesCallerInfo* GetUpdatesMessage::mutable_caller_info() {
  set_has_caller_info();
  if (caller_info_ == NULL) caller_info_ = new ::sync_pb::GetUpdatesCallerInfo;
  return caller_info_;
}
inline ::sync_pb::GetUpdatesCallerInfo* GetUpdatesMessage::release_caller_info() {
  clear_has_caller_info();
  ::sync_pb::GetUpdatesCallerInfo* temp = caller_info_;
  caller_info_ = NULL;
  return temp;
}
inline void GetUpdatesMessage::set_allocated_caller_info(::sync_pb::GetUpdatesCallerInfo* caller_info) {
  delete caller_info_;
  caller_info_ = caller_info;
  if (caller_info) {
    set_has_caller_info();
  } else {
    clear_has_caller_info();
  }
}

// optional bool fetch_folders = 3 [default = true];
inline bool GetUpdatesMessage::has_fetch_folders() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUpdatesMessage::set_has_fetch_folders() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUpdatesMessage::clear_has_fetch_folders() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUpdatesMessage::clear_fetch_folders() {
  fetch_folders_ = true;
  clear_has_fetch_folders();
}
inline bool GetUpdatesMessage::fetch_folders() const {
  return fetch_folders_;
}
inline void GetUpdatesMessage::set_fetch_folders(bool value) {
  set_has_fetch_folders();
  fetch_folders_ = value;
}

// optional .sync_pb.EntitySpecifics requested_types = 4;
inline bool GetUpdatesMessage::has_requested_types() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetUpdatesMessage::set_has_requested_types() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetUpdatesMessage::clear_has_requested_types() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetUpdatesMessage::clear_requested_types() {
  if (requested_types_ != NULL) requested_types_->::sync_pb::EntitySpecifics::Clear();
  clear_has_requested_types();
}
inline const ::sync_pb::EntitySpecifics& GetUpdatesMessage::requested_types() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return requested_types_ != NULL ? *requested_types_ : *default_instance().requested_types_;
#else
  return requested_types_ != NULL ? *requested_types_ : *default_instance_->requested_types_;
#endif
}
inline ::sync_pb::EntitySpecifics* GetUpdatesMessage::mutable_requested_types() {
  set_has_requested_types();
  if (requested_types_ == NULL) requested_types_ = new ::sync_pb::EntitySpecifics;
  return requested_types_;
}
inline ::sync_pb::EntitySpecifics* GetUpdatesMessage::release_requested_types() {
  clear_has_requested_types();
  ::sync_pb::EntitySpecifics* temp = requested_types_;
  requested_types_ = NULL;
  return temp;
}
inline void GetUpdatesMessage::set_allocated_requested_types(::sync_pb::EntitySpecifics* requested_types) {
  delete requested_types_;
  requested_types_ = requested_types;
  if (requested_types) {
    set_has_requested_types();
  } else {
    clear_has_requested_types();
  }
}

// optional int32 batch_size = 5;
inline bool GetUpdatesMessage::has_batch_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetUpdatesMessage::set_has_batch_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetUpdatesMessage::clear_has_batch_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetUpdatesMessage::clear_batch_size() {
  batch_size_ = 0;
  clear_has_batch_size();
}
inline ::google::protobuf::int32 GetUpdatesMessage::batch_size() const {
  return batch_size_;
}
inline void GetUpdatesMessage::set_batch_size(::google::protobuf::int32 value) {
  set_has_batch_size();
  batch_size_ = value;
}

// repeated .sync_pb.DataTypeProgressMarker from_progress_marker = 6;
inline int GetUpdatesMessage::from_progress_marker_size() const {
  return from_progress_marker_.size();
}
inline void GetUpdatesMessage::clear_from_progress_marker() {
  from_progress_marker_.Clear();
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesMessage::from_progress_marker(int index) const {
  return from_progress_marker_.Get(index);
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesMessage::mutable_from_progress_marker(int index) {
  return from_progress_marker_.Mutable(index);
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesMessage::add_from_progress_marker() {
  return from_progress_marker_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >&
GetUpdatesMessage::from_progress_marker() const {
  return from_progress_marker_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >*
GetUpdatesMessage::mutable_from_progress_marker() {
  return &from_progress_marker_;
}

// optional bool streaming = 7 [default = false];
inline bool GetUpdatesMessage::has_streaming() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GetUpdatesMessage::set_has_streaming() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GetUpdatesMessage::clear_has_streaming() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GetUpdatesMessage::clear_streaming() {
  streaming_ = false;
  clear_has_streaming();
}
inline bool GetUpdatesMessage::streaming() const {
  return streaming_;
}
inline void GetUpdatesMessage::set_streaming(bool value) {
  set_has_streaming();
  streaming_ = value;
}

// optional bool need_encryption_key = 8 [default = false];
inline bool GetUpdatesMessage::has_need_encryption_key() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GetUpdatesMessage::set_has_need_encryption_key() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GetUpdatesMessage::clear_has_need_encryption_key() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GetUpdatesMessage::clear_need_encryption_key() {
  need_encryption_key_ = false;
  clear_has_need_encryption_key();
}
inline bool GetUpdatesMessage::need_encryption_key() const {
  return need_encryption_key_;
}
inline void GetUpdatesMessage::set_need_encryption_key(bool value) {
  set_has_need_encryption_key();
  need_encryption_key_ = value;
}

// optional bool create_mobile_bookmarks_folder = 1000 [default = false];
inline bool GetUpdatesMessage::has_create_mobile_bookmarks_folder() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GetUpdatesMessage::set_has_create_mobile_bookmarks_folder() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GetUpdatesMessage::clear_has_create_mobile_bookmarks_folder() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GetUpdatesMessage::clear_create_mobile_bookmarks_folder() {
  create_mobile_bookmarks_folder_ = false;
  clear_has_create_mobile_bookmarks_folder();
}
inline bool GetUpdatesMessage::create_mobile_bookmarks_folder() const {
  return create_mobile_bookmarks_folder_;
}
inline void GetUpdatesMessage::set_create_mobile_bookmarks_folder(bool value) {
  set_has_create_mobile_bookmarks_folder();
  create_mobile_bookmarks_folder_ = value;
}

// optional .sync_pb.SyncEnums.GetUpdatesOrigin get_updates_origin = 9;
inline bool GetUpdatesMessage::has_get_updates_origin() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GetUpdatesMessage::set_has_get_updates_origin() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GetUpdatesMessage::clear_has_get_updates_origin() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GetUpdatesMessage::clear_get_updates_origin() {
  get_updates_origin_ = 0;
  clear_has_get_updates_origin();
}
inline ::sync_pb::SyncEnums_GetUpdatesOrigin GetUpdatesMessage::get_updates_origin() const {
  return static_cast< ::sync_pb::SyncEnums_GetUpdatesOrigin >(get_updates_origin_);
}
inline void GetUpdatesMessage::set_get_updates_origin(::sync_pb::SyncEnums_GetUpdatesOrigin value) {
  assert(::sync_pb::SyncEnums_GetUpdatesOrigin_IsValid(value));
  set_has_get_updates_origin();
  get_updates_origin_ = value;
}

// optional bool is_retry = 10 [default = false];
inline bool GetUpdatesMessage::has_is_retry() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GetUpdatesMessage::set_has_is_retry() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GetUpdatesMessage::clear_has_is_retry() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GetUpdatesMessage::clear_is_retry() {
  is_retry_ = false;
  clear_has_is_retry();
}
inline bool GetUpdatesMessage::is_retry() const {
  return is_retry_;
}
inline void GetUpdatesMessage::set_is_retry(bool value) {
  set_has_is_retry();
  is_retry_ = value;
}

// -------------------------------------------------------------------

// AuthenticateMessage

// required string auth_token = 1;
inline bool AuthenticateMessage::has_auth_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateMessage::set_has_auth_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateMessage::clear_has_auth_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateMessage::clear_auth_token() {
  if (auth_token_ != &::google::protobuf::internal::GetEmptyString()) {
    auth_token_->clear();
  }
  clear_has_auth_token();
}
inline const ::std::string& AuthenticateMessage::auth_token() const {
  return *auth_token_;
}
inline void AuthenticateMessage::set_auth_token(const ::std::string& value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::GetEmptyString()) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void AuthenticateMessage::set_auth_token(const char* value) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::GetEmptyString()) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(value);
}
inline void AuthenticateMessage::set_auth_token(const char* value, size_t size) {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::GetEmptyString()) {
    auth_token_ = new ::std::string;
  }
  auth_token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthenticateMessage::mutable_auth_token() {
  set_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::GetEmptyString()) {
    auth_token_ = new ::std::string;
  }
  return auth_token_;
}
inline ::std::string* AuthenticateMessage::release_auth_token() {
  clear_has_auth_token();
  if (auth_token_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = auth_token_;
    auth_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void AuthenticateMessage::set_allocated_auth_token(::std::string* auth_token) {
  if (auth_token_ != &::google::protobuf::internal::GetEmptyString()) {
    delete auth_token_;
  }
  if (auth_token) {
    set_has_auth_token();
    auth_token_ = auth_token;
  } else {
    clear_has_auth_token();
    auth_token_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ClearUserDataMessage

// -------------------------------------------------------------------

// ClearUserDataResponse

// -------------------------------------------------------------------

// ChipBag

// optional bytes server_chips = 1;
inline bool ChipBag::has_server_chips() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChipBag::set_has_server_chips() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChipBag::clear_has_server_chips() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChipBag::clear_server_chips() {
  if (server_chips_ != &::google::protobuf::internal::GetEmptyString()) {
    server_chips_->clear();
  }
  clear_has_server_chips();
}
inline const ::std::string& ChipBag::server_chips() const {
  return *server_chips_;
}
inline void ChipBag::set_server_chips(const ::std::string& value) {
  set_has_server_chips();
  if (server_chips_ == &::google::protobuf::internal::GetEmptyString()) {
    server_chips_ = new ::std::string;
  }
  server_chips_->assign(value);
}
inline void ChipBag::set_server_chips(const char* value) {
  set_has_server_chips();
  if (server_chips_ == &::google::protobuf::internal::GetEmptyString()) {
    server_chips_ = new ::std::string;
  }
  server_chips_->assign(value);
}
inline void ChipBag::set_server_chips(const void* value, size_t size) {
  set_has_server_chips();
  if (server_chips_ == &::google::protobuf::internal::GetEmptyString()) {
    server_chips_ = new ::std::string;
  }
  server_chips_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ChipBag::mutable_server_chips() {
  set_has_server_chips();
  if (server_chips_ == &::google::protobuf::internal::GetEmptyString()) {
    server_chips_ = new ::std::string;
  }
  return server_chips_;
}
inline ::std::string* ChipBag::release_server_chips() {
  clear_has_server_chips();
  if (server_chips_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = server_chips_;
    server_chips_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ChipBag::set_allocated_server_chips(::std::string* server_chips) {
  if (server_chips_ != &::google::protobuf::internal::GetEmptyString()) {
    delete server_chips_;
  }
  if (server_chips) {
    set_has_server_chips();
    server_chips_ = server_chips;
  } else {
    clear_has_server_chips();
    server_chips_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// ClientStatus

// optional bool hierarchy_conflict_detected = 1;
inline bool ClientStatus::has_hierarchy_conflict_detected() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientStatus::set_has_hierarchy_conflict_detected() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientStatus::clear_has_hierarchy_conflict_detected() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientStatus::clear_hierarchy_conflict_detected() {
  hierarchy_conflict_detected_ = false;
  clear_has_hierarchy_conflict_detected();
}
inline bool ClientStatus::hierarchy_conflict_detected() const {
  return hierarchy_conflict_detected_;
}
inline void ClientStatus::set_hierarchy_conflict_detected(bool value) {
  set_has_hierarchy_conflict_detected();
  hierarchy_conflict_detected_ = value;
}

// -------------------------------------------------------------------

// ClientToServerMessage

// required string share = 1;
inline bool ClientToServerMessage::has_share() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerMessage::set_has_share() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerMessage::clear_has_share() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerMessage::clear_share() {
  if (share_ != &::google::protobuf::internal::GetEmptyString()) {
    share_->clear();
  }
  clear_has_share();
}
inline const ::std::string& ClientToServerMessage::share() const {
  return *share_;
}
inline void ClientToServerMessage::set_share(const ::std::string& value) {
  set_has_share();
  if (share_ == &::google::protobuf::internal::GetEmptyString()) {
    share_ = new ::std::string;
  }
  share_->assign(value);
}
inline void ClientToServerMessage::set_share(const char* value) {
  set_has_share();
  if (share_ == &::google::protobuf::internal::GetEmptyString()) {
    share_ = new ::std::string;
  }
  share_->assign(value);
}
inline void ClientToServerMessage::set_share(const char* value, size_t size) {
  set_has_share();
  if (share_ == &::google::protobuf::internal::GetEmptyString()) {
    share_ = new ::std::string;
  }
  share_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToServerMessage::mutable_share() {
  set_has_share();
  if (share_ == &::google::protobuf::internal::GetEmptyString()) {
    share_ = new ::std::string;
  }
  return share_;
}
inline ::std::string* ClientToServerMessage::release_share() {
  clear_has_share();
  if (share_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = share_;
    share_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClientToServerMessage::set_allocated_share(::std::string* share) {
  if (share_ != &::google::protobuf::internal::GetEmptyString()) {
    delete share_;
  }
  if (share) {
    set_has_share();
    share_ = share;
  } else {
    clear_has_share();
    share_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int32 protocol_version = 2 [default = 31];
inline bool ClientToServerMessage::has_protocol_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToServerMessage::set_has_protocol_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToServerMessage::clear_has_protocol_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToServerMessage::clear_protocol_version() {
  protocol_version_ = 31;
  clear_has_protocol_version();
}
inline ::google::protobuf::int32 ClientToServerMessage::protocol_version() const {
  return protocol_version_;
}
inline void ClientToServerMessage::set_protocol_version(::google::protobuf::int32 value) {
  set_has_protocol_version();
  protocol_version_ = value;
}

// required .sync_pb.ClientToServerMessage.Contents message_contents = 3;
inline bool ClientToServerMessage::has_message_contents() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientToServerMessage::set_has_message_contents() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientToServerMessage::clear_has_message_contents() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientToServerMessage::clear_message_contents() {
  message_contents_ = 1;
  clear_has_message_contents();
}
inline ::sync_pb::ClientToServerMessage_Contents ClientToServerMessage::message_contents() const {
  return static_cast< ::sync_pb::ClientToServerMessage_Contents >(message_contents_);
}
inline void ClientToServerMessage::set_message_contents(::sync_pb::ClientToServerMessage_Contents value) {
  assert(::sync_pb::ClientToServerMessage_Contents_IsValid(value));
  set_has_message_contents();
  message_contents_ = value;
}

// optional .sync_pb.CommitMessage commit = 4;
inline bool ClientToServerMessage::has_commit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientToServerMessage::set_has_commit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientToServerMessage::clear_has_commit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientToServerMessage::clear_commit() {
  if (commit_ != NULL) commit_->::sync_pb::CommitMessage::Clear();
  clear_has_commit();
}
inline const ::sync_pb::CommitMessage& ClientToServerMessage::commit() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return commit_ != NULL ? *commit_ : *default_instance().commit_;
#else
  return commit_ != NULL ? *commit_ : *default_instance_->commit_;
#endif
}
inline ::sync_pb::CommitMessage* ClientToServerMessage::mutable_commit() {
  set_has_commit();
  if (commit_ == NULL) commit_ = new ::sync_pb::CommitMessage;
  return commit_;
}
inline ::sync_pb::CommitMessage* ClientToServerMessage::release_commit() {
  clear_has_commit();
  ::sync_pb::CommitMessage* temp = commit_;
  commit_ = NULL;
  return temp;
}
inline void ClientToServerMessage::set_allocated_commit(::sync_pb::CommitMessage* commit) {
  delete commit_;
  commit_ = commit;
  if (commit) {
    set_has_commit();
  } else {
    clear_has_commit();
  }
}

// optional .sync_pb.GetUpdatesMessage get_updates = 5;
inline bool ClientToServerMessage::has_get_updates() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientToServerMessage::set_has_get_updates() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientToServerMessage::clear_has_get_updates() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientToServerMessage::clear_get_updates() {
  if (get_updates_ != NULL) get_updates_->::sync_pb::GetUpdatesMessage::Clear();
  clear_has_get_updates();
}
inline const ::sync_pb::GetUpdatesMessage& ClientToServerMessage::get_updates() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return get_updates_ != NULL ? *get_updates_ : *default_instance().get_updates_;
#else
  return get_updates_ != NULL ? *get_updates_ : *default_instance_->get_updates_;
#endif
}
inline ::sync_pb::GetUpdatesMessage* ClientToServerMessage::mutable_get_updates() {
  set_has_get_updates();
  if (get_updates_ == NULL) get_updates_ = new ::sync_pb::GetUpdatesMessage;
  return get_updates_;
}
inline ::sync_pb::GetUpdatesMessage* ClientToServerMessage::release_get_updates() {
  clear_has_get_updates();
  ::sync_pb::GetUpdatesMessage* temp = get_updates_;
  get_updates_ = NULL;
  return temp;
}
inline void ClientToServerMessage::set_allocated_get_updates(::sync_pb::GetUpdatesMessage* get_updates) {
  delete get_updates_;
  get_updates_ = get_updates;
  if (get_updates) {
    set_has_get_updates();
  } else {
    clear_has_get_updates();
  }
}

// optional .sync_pb.AuthenticateMessage authenticate = 6;
inline bool ClientToServerMessage::has_authenticate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientToServerMessage::set_has_authenticate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientToServerMessage::clear_has_authenticate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientToServerMessage::clear_authenticate() {
  if (authenticate_ != NULL) authenticate_->::sync_pb::AuthenticateMessage::Clear();
  clear_has_authenticate();
}
inline const ::sync_pb::AuthenticateMessage& ClientToServerMessage::authenticate() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return authenticate_ != NULL ? *authenticate_ : *default_instance().authenticate_;
#else
  return authenticate_ != NULL ? *authenticate_ : *default_instance_->authenticate_;
#endif
}
inline ::sync_pb::AuthenticateMessage* ClientToServerMessage::mutable_authenticate() {
  set_has_authenticate();
  if (authenticate_ == NULL) authenticate_ = new ::sync_pb::AuthenticateMessage;
  return authenticate_;
}
inline ::sync_pb::AuthenticateMessage* ClientToServerMessage::release_authenticate() {
  clear_has_authenticate();
  ::sync_pb::AuthenticateMessage* temp = authenticate_;
  authenticate_ = NULL;
  return temp;
}
inline void ClientToServerMessage::set_allocated_authenticate(::sync_pb::AuthenticateMessage* authenticate) {
  delete authenticate_;
  authenticate_ = authenticate;
  if (authenticate) {
    set_has_authenticate();
  } else {
    clear_has_authenticate();
  }
}

// optional .sync_pb.ClearUserDataMessage clear_user_data = 9;
inline bool ClientToServerMessage::has_clear_user_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientToServerMessage::set_has_clear_user_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientToServerMessage::clear_has_clear_user_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientToServerMessage::clear_clear_user_data() {
  if (clear_user_data_ != NULL) clear_user_data_->::sync_pb::ClearUserDataMessage::Clear();
  clear_has_clear_user_data();
}
inline const ::sync_pb::ClearUserDataMessage& ClientToServerMessage::clear_user_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clear_user_data_ != NULL ? *clear_user_data_ : *default_instance().clear_user_data_;
#else
  return clear_user_data_ != NULL ? *clear_user_data_ : *default_instance_->clear_user_data_;
#endif
}
inline ::sync_pb::ClearUserDataMessage* ClientToServerMessage::mutable_clear_user_data() {
  set_has_clear_user_data();
  if (clear_user_data_ == NULL) clear_user_data_ = new ::sync_pb::ClearUserDataMessage;
  return clear_user_data_;
}
inline ::sync_pb::ClearUserDataMessage* ClientToServerMessage::release_clear_user_data() {
  clear_has_clear_user_data();
  ::sync_pb::ClearUserDataMessage* temp = clear_user_data_;
  clear_user_data_ = NULL;
  return temp;
}
inline void ClientToServerMessage::set_allocated_clear_user_data(::sync_pb::ClearUserDataMessage* clear_user_data) {
  delete clear_user_data_;
  clear_user_data_ = clear_user_data;
  if (clear_user_data) {
    set_has_clear_user_data();
  } else {
    clear_has_clear_user_data();
  }
}

// optional string store_birthday = 7;
inline bool ClientToServerMessage::has_store_birthday() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientToServerMessage::set_has_store_birthday() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientToServerMessage::clear_has_store_birthday() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientToServerMessage::clear_store_birthday() {
  if (store_birthday_ != &::google::protobuf::internal::GetEmptyString()) {
    store_birthday_->clear();
  }
  clear_has_store_birthday();
}
inline const ::std::string& ClientToServerMessage::store_birthday() const {
  return *store_birthday_;
}
inline void ClientToServerMessage::set_store_birthday(const ::std::string& value) {
  set_has_store_birthday();
  if (store_birthday_ == &::google::protobuf::internal::GetEmptyString()) {
    store_birthday_ = new ::std::string;
  }
  store_birthday_->assign(value);
}
inline void ClientToServerMessage::set_store_birthday(const char* value) {
  set_has_store_birthday();
  if (store_birthday_ == &::google::protobuf::internal::GetEmptyString()) {
    store_birthday_ = new ::std::string;
  }
  store_birthday_->assign(value);
}
inline void ClientToServerMessage::set_store_birthday(const char* value, size_t size) {
  set_has_store_birthday();
  if (store_birthday_ == &::google::protobuf::internal::GetEmptyString()) {
    store_birthday_ = new ::std::string;
  }
  store_birthday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToServerMessage::mutable_store_birthday() {
  set_has_store_birthday();
  if (store_birthday_ == &::google::protobuf::internal::GetEmptyString()) {
    store_birthday_ = new ::std::string;
  }
  return store_birthday_;
}
inline ::std::string* ClientToServerMessage::release_store_birthday() {
  clear_has_store_birthday();
  if (store_birthday_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = store_birthday_;
    store_birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClientToServerMessage::set_allocated_store_birthday(::std::string* store_birthday) {
  if (store_birthday_ != &::google::protobuf::internal::GetEmptyString()) {
    delete store_birthday_;
  }
  if (store_birthday) {
    set_has_store_birthday();
    store_birthday_ = store_birthday;
  } else {
    clear_has_store_birthday();
    store_birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bool sync_problem_detected = 8 [default = false];
inline bool ClientToServerMessage::has_sync_problem_detected() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientToServerMessage::set_has_sync_problem_detected() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientToServerMessage::clear_has_sync_problem_detected() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientToServerMessage::clear_sync_problem_detected() {
  sync_problem_detected_ = false;
  clear_has_sync_problem_detected();
}
inline bool ClientToServerMessage::sync_problem_detected() const {
  return sync_problem_detected_;
}
inline void ClientToServerMessage::set_sync_problem_detected(bool value) {
  set_has_sync_problem_detected();
  sync_problem_detected_ = value;
}

// optional .sync_pb.DebugInfo debug_info = 10;
inline bool ClientToServerMessage::has_debug_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientToServerMessage::set_has_debug_info() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientToServerMessage::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientToServerMessage::clear_debug_info() {
  if (debug_info_ != NULL) debug_info_->::sync_pb::DebugInfo::Clear();
  clear_has_debug_info();
}
inline const ::sync_pb::DebugInfo& ClientToServerMessage::debug_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return debug_info_ != NULL ? *debug_info_ : *default_instance().debug_info_;
#else
  return debug_info_ != NULL ? *debug_info_ : *default_instance_->debug_info_;
#endif
}
inline ::sync_pb::DebugInfo* ClientToServerMessage::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == NULL) debug_info_ = new ::sync_pb::DebugInfo;
  return debug_info_;
}
inline ::sync_pb::DebugInfo* ClientToServerMessage::release_debug_info() {
  clear_has_debug_info();
  ::sync_pb::DebugInfo* temp = debug_info_;
  debug_info_ = NULL;
  return temp;
}
inline void ClientToServerMessage::set_allocated_debug_info(::sync_pb::DebugInfo* debug_info) {
  delete debug_info_;
  debug_info_ = debug_info;
  if (debug_info) {
    set_has_debug_info();
  } else {
    clear_has_debug_info();
  }
}

// optional .sync_pb.ChipBag bag_of_chips = 11;
inline bool ClientToServerMessage::has_bag_of_chips() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientToServerMessage::set_has_bag_of_chips() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientToServerMessage::clear_has_bag_of_chips() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientToServerMessage::clear_bag_of_chips() {
  if (bag_of_chips_ != NULL) bag_of_chips_->::sync_pb::ChipBag::Clear();
  clear_has_bag_of_chips();
}
inline const ::sync_pb::ChipBag& ClientToServerMessage::bag_of_chips() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bag_of_chips_ != NULL ? *bag_of_chips_ : *default_instance().bag_of_chips_;
#else
  return bag_of_chips_ != NULL ? *bag_of_chips_ : *default_instance_->bag_of_chips_;
#endif
}
inline ::sync_pb::ChipBag* ClientToServerMessage::mutable_bag_of_chips() {
  set_has_bag_of_chips();
  if (bag_of_chips_ == NULL) bag_of_chips_ = new ::sync_pb::ChipBag;
  return bag_of_chips_;
}
inline ::sync_pb::ChipBag* ClientToServerMessage::release_bag_of_chips() {
  clear_has_bag_of_chips();
  ::sync_pb::ChipBag* temp = bag_of_chips_;
  bag_of_chips_ = NULL;
  return temp;
}
inline void ClientToServerMessage::set_allocated_bag_of_chips(::sync_pb::ChipBag* bag_of_chips) {
  delete bag_of_chips_;
  bag_of_chips_ = bag_of_chips;
  if (bag_of_chips) {
    set_has_bag_of_chips();
  } else {
    clear_has_bag_of_chips();
  }
}

// optional string api_key = 12;
inline bool ClientToServerMessage::has_api_key() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClientToServerMessage::set_has_api_key() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClientToServerMessage::clear_has_api_key() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClientToServerMessage::clear_api_key() {
  if (api_key_ != &::google::protobuf::internal::GetEmptyString()) {
    api_key_->clear();
  }
  clear_has_api_key();
}
inline const ::std::string& ClientToServerMessage::api_key() const {
  return *api_key_;
}
inline void ClientToServerMessage::set_api_key(const ::std::string& value) {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::GetEmptyString()) {
    api_key_ = new ::std::string;
  }
  api_key_->assign(value);
}
inline void ClientToServerMessage::set_api_key(const char* value) {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::GetEmptyString()) {
    api_key_ = new ::std::string;
  }
  api_key_->assign(value);
}
inline void ClientToServerMessage::set_api_key(const char* value, size_t size) {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::GetEmptyString()) {
    api_key_ = new ::std::string;
  }
  api_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToServerMessage::mutable_api_key() {
  set_has_api_key();
  if (api_key_ == &::google::protobuf::internal::GetEmptyString()) {
    api_key_ = new ::std::string;
  }
  return api_key_;
}
inline ::std::string* ClientToServerMessage::release_api_key() {
  clear_has_api_key();
  if (api_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = api_key_;
    api_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClientToServerMessage::set_allocated_api_key(::std::string* api_key) {
  if (api_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete api_key_;
  }
  if (api_key) {
    set_has_api_key();
    api_key_ = api_key;
  } else {
    clear_has_api_key();
    api_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.ClientStatus client_status = 13;
inline bool ClientToServerMessage::has_client_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClientToServerMessage::set_has_client_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClientToServerMessage::clear_has_client_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClientToServerMessage::clear_client_status() {
  if (client_status_ != NULL) client_status_->::sync_pb::ClientStatus::Clear();
  clear_has_client_status();
}
inline const ::sync_pb::ClientStatus& ClientToServerMessage::client_status() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return client_status_ != NULL ? *client_status_ : *default_instance().client_status_;
#else
  return client_status_ != NULL ? *client_status_ : *default_instance_->client_status_;
#endif
}
inline ::sync_pb::ClientStatus* ClientToServerMessage::mutable_client_status() {
  set_has_client_status();
  if (client_status_ == NULL) client_status_ = new ::sync_pb::ClientStatus;
  return client_status_;
}
inline ::sync_pb::ClientStatus* ClientToServerMessage::release_client_status() {
  clear_has_client_status();
  ::sync_pb::ClientStatus* temp = client_status_;
  client_status_ = NULL;
  return temp;
}
inline void ClientToServerMessage::set_allocated_client_status(::sync_pb::ClientStatus* client_status) {
  delete client_status_;
  client_status_ = client_status;
  if (client_status) {
    set_has_client_status();
  } else {
    clear_has_client_status();
  }
}

// optional string invalidator_client_id = 14;
inline bool ClientToServerMessage::has_invalidator_client_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ClientToServerMessage::set_has_invalidator_client_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ClientToServerMessage::clear_has_invalidator_client_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ClientToServerMessage::clear_invalidator_client_id() {
  if (invalidator_client_id_ != &::google::protobuf::internal::GetEmptyString()) {
    invalidator_client_id_->clear();
  }
  clear_has_invalidator_client_id();
}
inline const ::std::string& ClientToServerMessage::invalidator_client_id() const {
  return *invalidator_client_id_;
}
inline void ClientToServerMessage::set_invalidator_client_id(const ::std::string& value) {
  set_has_invalidator_client_id();
  if (invalidator_client_id_ == &::google::protobuf::internal::GetEmptyString()) {
    invalidator_client_id_ = new ::std::string;
  }
  invalidator_client_id_->assign(value);
}
inline void ClientToServerMessage::set_invalidator_client_id(const char* value) {
  set_has_invalidator_client_id();
  if (invalidator_client_id_ == &::google::protobuf::internal::GetEmptyString()) {
    invalidator_client_id_ = new ::std::string;
  }
  invalidator_client_id_->assign(value);
}
inline void ClientToServerMessage::set_invalidator_client_id(const char* value, size_t size) {
  set_has_invalidator_client_id();
  if (invalidator_client_id_ == &::google::protobuf::internal::GetEmptyString()) {
    invalidator_client_id_ = new ::std::string;
  }
  invalidator_client_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToServerMessage::mutable_invalidator_client_id() {
  set_has_invalidator_client_id();
  if (invalidator_client_id_ == &::google::protobuf::internal::GetEmptyString()) {
    invalidator_client_id_ = new ::std::string;
  }
  return invalidator_client_id_;
}
inline ::std::string* ClientToServerMessage::release_invalidator_client_id() {
  clear_has_invalidator_client_id();
  if (invalidator_client_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = invalidator_client_id_;
    invalidator_client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClientToServerMessage::set_allocated_invalidator_client_id(::std::string* invalidator_client_id) {
  if (invalidator_client_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete invalidator_client_id_;
  }
  if (invalidator_client_id) {
    set_has_invalidator_client_id();
    invalidator_client_id_ = invalidator_client_id;
  } else {
    clear_has_invalidator_client_id();
    invalidator_client_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// GetCrashInfoRequest

// optional string crash_id = 1;
inline bool GetCrashInfoRequest::has_crash_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCrashInfoRequest::set_has_crash_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCrashInfoRequest::clear_has_crash_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCrashInfoRequest::clear_crash_id() {
  if (crash_id_ != &::google::protobuf::internal::GetEmptyString()) {
    crash_id_->clear();
  }
  clear_has_crash_id();
}
inline const ::std::string& GetCrashInfoRequest::crash_id() const {
  return *crash_id_;
}
inline void GetCrashInfoRequest::set_crash_id(const ::std::string& value) {
  set_has_crash_id();
  if (crash_id_ == &::google::protobuf::internal::GetEmptyString()) {
    crash_id_ = new ::std::string;
  }
  crash_id_->assign(value);
}
inline void GetCrashInfoRequest::set_crash_id(const char* value) {
  set_has_crash_id();
  if (crash_id_ == &::google::protobuf::internal::GetEmptyString()) {
    crash_id_ = new ::std::string;
  }
  crash_id_->assign(value);
}
inline void GetCrashInfoRequest::set_crash_id(const char* value, size_t size) {
  set_has_crash_id();
  if (crash_id_ == &::google::protobuf::internal::GetEmptyString()) {
    crash_id_ = new ::std::string;
  }
  crash_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetCrashInfoRequest::mutable_crash_id() {
  set_has_crash_id();
  if (crash_id_ == &::google::protobuf::internal::GetEmptyString()) {
    crash_id_ = new ::std::string;
  }
  return crash_id_;
}
inline ::std::string* GetCrashInfoRequest::release_crash_id() {
  clear_has_crash_id();
  if (crash_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = crash_id_;
    crash_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GetCrashInfoRequest::set_allocated_crash_id(::std::string* crash_id) {
  if (crash_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete crash_id_;
  }
  if (crash_id) {
    set_has_crash_id();
    crash_id_ = crash_id;
  } else {
    clear_has_crash_id();
    crash_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int64 crash_time_millis = 2;
inline bool GetCrashInfoRequest::has_crash_time_millis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCrashInfoRequest::set_has_crash_time_millis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCrashInfoRequest::clear_has_crash_time_millis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCrashInfoRequest::clear_crash_time_millis() {
  crash_time_millis_ = GOOGLE_LONGLONG(0);
  clear_has_crash_time_millis();
}
inline ::google::protobuf::int64 GetCrashInfoRequest::crash_time_millis() const {
  return crash_time_millis_;
}
inline void GetCrashInfoRequest::set_crash_time_millis(::google::protobuf::int64 value) {
  set_has_crash_time_millis();
  crash_time_millis_ = value;
}

// -------------------------------------------------------------------

// GetCrashInfoResponse

// optional string stack_id = 1;
inline bool GetCrashInfoResponse::has_stack_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetCrashInfoResponse::set_has_stack_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetCrashInfoResponse::clear_has_stack_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetCrashInfoResponse::clear_stack_id() {
  if (stack_id_ != &::google::protobuf::internal::GetEmptyString()) {
    stack_id_->clear();
  }
  clear_has_stack_id();
}
inline const ::std::string& GetCrashInfoResponse::stack_id() const {
  return *stack_id_;
}
inline void GetCrashInfoResponse::set_stack_id(const ::std::string& value) {
  set_has_stack_id();
  if (stack_id_ == &::google::protobuf::internal::GetEmptyString()) {
    stack_id_ = new ::std::string;
  }
  stack_id_->assign(value);
}
inline void GetCrashInfoResponse::set_stack_id(const char* value) {
  set_has_stack_id();
  if (stack_id_ == &::google::protobuf::internal::GetEmptyString()) {
    stack_id_ = new ::std::string;
  }
  stack_id_->assign(value);
}
inline void GetCrashInfoResponse::set_stack_id(const char* value, size_t size) {
  set_has_stack_id();
  if (stack_id_ == &::google::protobuf::internal::GetEmptyString()) {
    stack_id_ = new ::std::string;
  }
  stack_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetCrashInfoResponse::mutable_stack_id() {
  set_has_stack_id();
  if (stack_id_ == &::google::protobuf::internal::GetEmptyString()) {
    stack_id_ = new ::std::string;
  }
  return stack_id_;
}
inline ::std::string* GetCrashInfoResponse::release_stack_id() {
  clear_has_stack_id();
  if (stack_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = stack_id_;
    stack_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void GetCrashInfoResponse::set_allocated_stack_id(::std::string* stack_id) {
  if (stack_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete stack_id_;
  }
  if (stack_id) {
    set_has_stack_id();
    stack_id_ = stack_id;
  } else {
    clear_has_stack_id();
    stack_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int64 crash_time_millis = 2;
inline bool GetCrashInfoResponse::has_crash_time_millis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetCrashInfoResponse::set_has_crash_time_millis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetCrashInfoResponse::clear_has_crash_time_millis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetCrashInfoResponse::clear_crash_time_millis() {
  crash_time_millis_ = GOOGLE_LONGLONG(0);
  clear_has_crash_time_millis();
}
inline ::google::protobuf::int64 GetCrashInfoResponse::crash_time_millis() const {
  return crash_time_millis_;
}
inline void GetCrashInfoResponse::set_crash_time_millis(::google::protobuf::int64 value) {
  set_has_crash_time_millis();
  crash_time_millis_ = value;
}

// -------------------------------------------------------------------

// CommitResponse_EntryResponse

// required .sync_pb.CommitResponse.ResponseType response_type = 2;
inline bool CommitResponse_EntryResponse::has_response_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CommitResponse_EntryResponse::set_has_response_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CommitResponse_EntryResponse::clear_has_response_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CommitResponse_EntryResponse::clear_response_type() {
  response_type_ = 1;
  clear_has_response_type();
}
inline ::sync_pb::CommitResponse_ResponseType CommitResponse_EntryResponse::response_type() const {
  return static_cast< ::sync_pb::CommitResponse_ResponseType >(response_type_);
}
inline void CommitResponse_EntryResponse::set_response_type(::sync_pb::CommitResponse_ResponseType value) {
  assert(::sync_pb::CommitResponse_ResponseType_IsValid(value));
  set_has_response_type();
  response_type_ = value;
}

// optional string id_string = 3;
inline bool CommitResponse_EntryResponse::has_id_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CommitResponse_EntryResponse::set_has_id_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CommitResponse_EntryResponse::clear_has_id_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CommitResponse_EntryResponse::clear_id_string() {
  if (id_string_ != &::google::protobuf::internal::GetEmptyString()) {
    id_string_->clear();
  }
  clear_has_id_string();
}
inline const ::std::string& CommitResponse_EntryResponse::id_string() const {
  return *id_string_;
}
inline void CommitResponse_EntryResponse::set_id_string(const ::std::string& value) {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    id_string_ = new ::std::string;
  }
  id_string_->assign(value);
}
inline void CommitResponse_EntryResponse::set_id_string(const char* value) {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    id_string_ = new ::std::string;
  }
  id_string_->assign(value);
}
inline void CommitResponse_EntryResponse::set_id_string(const char* value, size_t size) {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    id_string_ = new ::std::string;
  }
  id_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommitResponse_EntryResponse::mutable_id_string() {
  set_has_id_string();
  if (id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    id_string_ = new ::std::string;
  }
  return id_string_;
}
inline ::std::string* CommitResponse_EntryResponse::release_id_string() {
  clear_has_id_string();
  if (id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = id_string_;
    id_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CommitResponse_EntryResponse::set_allocated_id_string(::std::string* id_string) {
  if (id_string_ != &::google::protobuf::internal::GetEmptyString()) {
    delete id_string_;
  }
  if (id_string) {
    set_has_id_string();
    id_string_ = id_string;
  } else {
    clear_has_id_string();
    id_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string parent_id_string = 4;
inline bool CommitResponse_EntryResponse::has_parent_id_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CommitResponse_EntryResponse::set_has_parent_id_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CommitResponse_EntryResponse::clear_has_parent_id_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CommitResponse_EntryResponse::clear_parent_id_string() {
  if (parent_id_string_ != &::google::protobuf::internal::GetEmptyString()) {
    parent_id_string_->clear();
  }
  clear_has_parent_id_string();
}
inline const ::std::string& CommitResponse_EntryResponse::parent_id_string() const {
  return *parent_id_string_;
}
inline void CommitResponse_EntryResponse::set_parent_id_string(const ::std::string& value) {
  set_has_parent_id_string();
  if (parent_id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    parent_id_string_ = new ::std::string;
  }
  parent_id_string_->assign(value);
}
inline void CommitResponse_EntryResponse::set_parent_id_string(const char* value) {
  set_has_parent_id_string();
  if (parent_id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    parent_id_string_ = new ::std::string;
  }
  parent_id_string_->assign(value);
}
inline void CommitResponse_EntryResponse::set_parent_id_string(const char* value, size_t size) {
  set_has_parent_id_string();
  if (parent_id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    parent_id_string_ = new ::std::string;
  }
  parent_id_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommitResponse_EntryResponse::mutable_parent_id_string() {
  set_has_parent_id_string();
  if (parent_id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    parent_id_string_ = new ::std::string;
  }
  return parent_id_string_;
}
inline ::std::string* CommitResponse_EntryResponse::release_parent_id_string() {
  clear_has_parent_id_string();
  if (parent_id_string_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = parent_id_string_;
    parent_id_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CommitResponse_EntryResponse::set_allocated_parent_id_string(::std::string* parent_id_string) {
  if (parent_id_string_ != &::google::protobuf::internal::GetEmptyString()) {
    delete parent_id_string_;
  }
  if (parent_id_string) {
    set_has_parent_id_string();
    parent_id_string_ = parent_id_string;
  } else {
    clear_has_parent_id_string();
    parent_id_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int64 position_in_parent = 5;
inline bool CommitResponse_EntryResponse::has_position_in_parent() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CommitResponse_EntryResponse::set_has_position_in_parent() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CommitResponse_EntryResponse::clear_has_position_in_parent() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CommitResponse_EntryResponse::clear_position_in_parent() {
  position_in_parent_ = GOOGLE_LONGLONG(0);
  clear_has_position_in_parent();
}
inline ::google::protobuf::int64 CommitResponse_EntryResponse::position_in_parent() const {
  return position_in_parent_;
}
inline void CommitResponse_EntryResponse::set_position_in_parent(::google::protobuf::int64 value) {
  set_has_position_in_parent();
  position_in_parent_ = value;
}

// optional int64 version = 6;
inline bool CommitResponse_EntryResponse::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CommitResponse_EntryResponse::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CommitResponse_EntryResponse::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CommitResponse_EntryResponse::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::int64 CommitResponse_EntryResponse::version() const {
  return version_;
}
inline void CommitResponse_EntryResponse::set_version(::google::protobuf::int64 value) {
  set_has_version();
  version_ = value;
}

// optional string name = 7;
inline bool CommitResponse_EntryResponse::has_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CommitResponse_EntryResponse::set_has_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CommitResponse_EntryResponse::clear_has_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CommitResponse_EntryResponse::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CommitResponse_EntryResponse::name() const {
  return *name_;
}
inline void CommitResponse_EntryResponse::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CommitResponse_EntryResponse::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CommitResponse_EntryResponse::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommitResponse_EntryResponse::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CommitResponse_EntryResponse::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CommitResponse_EntryResponse::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string non_unique_name = 8;
inline bool CommitResponse_EntryResponse::has_non_unique_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CommitResponse_EntryResponse::set_has_non_unique_name() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CommitResponse_EntryResponse::clear_has_non_unique_name() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CommitResponse_EntryResponse::clear_non_unique_name() {
  if (non_unique_name_ != &::google::protobuf::internal::GetEmptyString()) {
    non_unique_name_->clear();
  }
  clear_has_non_unique_name();
}
inline const ::std::string& CommitResponse_EntryResponse::non_unique_name() const {
  return *non_unique_name_;
}
inline void CommitResponse_EntryResponse::set_non_unique_name(const ::std::string& value) {
  set_has_non_unique_name();
  if (non_unique_name_ == &::google::protobuf::internal::GetEmptyString()) {
    non_unique_name_ = new ::std::string;
  }
  non_unique_name_->assign(value);
}
inline void CommitResponse_EntryResponse::set_non_unique_name(const char* value) {
  set_has_non_unique_name();
  if (non_unique_name_ == &::google::protobuf::internal::GetEmptyString()) {
    non_unique_name_ = new ::std::string;
  }
  non_unique_name_->assign(value);
}
inline void CommitResponse_EntryResponse::set_non_unique_name(const char* value, size_t size) {
  set_has_non_unique_name();
  if (non_unique_name_ == &::google::protobuf::internal::GetEmptyString()) {
    non_unique_name_ = new ::std::string;
  }
  non_unique_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommitResponse_EntryResponse::mutable_non_unique_name() {
  set_has_non_unique_name();
  if (non_unique_name_ == &::google::protobuf::internal::GetEmptyString()) {
    non_unique_name_ = new ::std::string;
  }
  return non_unique_name_;
}
inline ::std::string* CommitResponse_EntryResponse::release_non_unique_name() {
  clear_has_non_unique_name();
  if (non_unique_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = non_unique_name_;
    non_unique_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CommitResponse_EntryResponse::set_allocated_non_unique_name(::std::string* non_unique_name) {
  if (non_unique_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete non_unique_name_;
  }
  if (non_unique_name) {
    set_has_non_unique_name();
    non_unique_name_ = non_unique_name;
  } else {
    clear_has_non_unique_name();
    non_unique_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string error_message = 9;
inline bool CommitResponse_EntryResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CommitResponse_EntryResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CommitResponse_EntryResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CommitResponse_EntryResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::GetEmptyString()) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& CommitResponse_EntryResponse::error_message() const {
  return *error_message_;
}
inline void CommitResponse_EntryResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyString()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void CommitResponse_EntryResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyString()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void CommitResponse_EntryResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyString()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CommitResponse_EntryResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyString()) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* CommitResponse_EntryResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CommitResponse_EntryResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::GetEmptyString()) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional int64 mtime = 10;
inline bool CommitResponse_EntryResponse::has_mtime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CommitResponse_EntryResponse::set_has_mtime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CommitResponse_EntryResponse::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CommitResponse_EntryResponse::clear_mtime() {
  mtime_ = GOOGLE_LONGLONG(0);
  clear_has_mtime();
}
inline ::google::protobuf::int64 CommitResponse_EntryResponse::mtime() const {
  return mtime_;
}
inline void CommitResponse_EntryResponse::set_mtime(::google::protobuf::int64 value) {
  set_has_mtime();
  mtime_ = value;
}

// -------------------------------------------------------------------

// CommitResponse

// repeated group EntryResponse = 1 {
inline int CommitResponse::entryresponse_size() const {
  return entryresponse_.size();
}
inline void CommitResponse::clear_entryresponse() {
  entryresponse_.Clear();
}
inline const ::sync_pb::CommitResponse_EntryResponse& CommitResponse::entryresponse(int index) const {
  return entryresponse_.Get(index);
}
inline ::sync_pb::CommitResponse_EntryResponse* CommitResponse::mutable_entryresponse(int index) {
  return entryresponse_.Mutable(index);
}
inline ::sync_pb::CommitResponse_EntryResponse* CommitResponse::add_entryresponse() {
  return entryresponse_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::CommitResponse_EntryResponse >&
CommitResponse::entryresponse() const {
  return entryresponse_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::CommitResponse_EntryResponse >*
CommitResponse::mutable_entryresponse() {
  return &entryresponse_;
}

// -------------------------------------------------------------------

// GetUpdatesResponse

// repeated .sync_pb.SyncEntity entries = 1;
inline int GetUpdatesResponse::entries_size() const {
  return entries_.size();
}
inline void GetUpdatesResponse::clear_entries() {
  entries_.Clear();
}
inline const ::sync_pb::SyncEntity& GetUpdatesResponse::entries(int index) const {
  return entries_.Get(index);
}
inline ::sync_pb::SyncEntity* GetUpdatesResponse::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::sync_pb::SyncEntity* GetUpdatesResponse::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >&
GetUpdatesResponse::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >*
GetUpdatesResponse::mutable_entries() {
  return &entries_;
}

// optional int64 new_timestamp = 2;
inline bool GetUpdatesResponse::has_new_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetUpdatesResponse::set_has_new_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetUpdatesResponse::clear_has_new_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetUpdatesResponse::clear_new_timestamp() {
  new_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_new_timestamp();
}
inline ::google::protobuf::int64 GetUpdatesResponse::new_timestamp() const {
  return new_timestamp_;
}
inline void GetUpdatesResponse::set_new_timestamp(::google::protobuf::int64 value) {
  set_has_new_timestamp();
  new_timestamp_ = value;
}

// optional int64 deprecated_newest_timestamp = 3;
inline bool GetUpdatesResponse::has_deprecated_newest_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetUpdatesResponse::set_has_deprecated_newest_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetUpdatesResponse::clear_has_deprecated_newest_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetUpdatesResponse::clear_deprecated_newest_timestamp() {
  deprecated_newest_timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_deprecated_newest_timestamp();
}
inline ::google::protobuf::int64 GetUpdatesResponse::deprecated_newest_timestamp() const {
  return deprecated_newest_timestamp_;
}
inline void GetUpdatesResponse::set_deprecated_newest_timestamp(::google::protobuf::int64 value) {
  set_has_deprecated_newest_timestamp();
  deprecated_newest_timestamp_ = value;
}

// optional int64 changes_remaining = 4;
inline bool GetUpdatesResponse::has_changes_remaining() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetUpdatesResponse::set_has_changes_remaining() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetUpdatesResponse::clear_has_changes_remaining() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetUpdatesResponse::clear_changes_remaining() {
  changes_remaining_ = GOOGLE_LONGLONG(0);
  clear_has_changes_remaining();
}
inline ::google::protobuf::int64 GetUpdatesResponse::changes_remaining() const {
  return changes_remaining_;
}
inline void GetUpdatesResponse::set_changes_remaining(::google::protobuf::int64 value) {
  set_has_changes_remaining();
  changes_remaining_ = value;
}

// repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 5;
inline int GetUpdatesResponse::new_progress_marker_size() const {
  return new_progress_marker_.size();
}
inline void GetUpdatesResponse::clear_new_progress_marker() {
  new_progress_marker_.Clear();
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesResponse::new_progress_marker(int index) const {
  return new_progress_marker_.Get(index);
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesResponse::mutable_new_progress_marker(int index) {
  return new_progress_marker_.Mutable(index);
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesResponse::add_new_progress_marker() {
  return new_progress_marker_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >&
GetUpdatesResponse::new_progress_marker() const {
  return new_progress_marker_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >*
GetUpdatesResponse::mutable_new_progress_marker() {
  return &new_progress_marker_;
}

// repeated bytes encryption_keys = 6;
inline int GetUpdatesResponse::encryption_keys_size() const {
  return encryption_keys_.size();
}
inline void GetUpdatesResponse::clear_encryption_keys() {
  encryption_keys_.Clear();
}
inline const ::std::string& GetUpdatesResponse::encryption_keys(int index) const {
  return encryption_keys_.Get(index);
}
inline ::std::string* GetUpdatesResponse::mutable_encryption_keys(int index) {
  return encryption_keys_.Mutable(index);
}
inline void GetUpdatesResponse::set_encryption_keys(int index, const ::std::string& value) {
  encryption_keys_.Mutable(index)->assign(value);
}
inline void GetUpdatesResponse::set_encryption_keys(int index, const char* value) {
  encryption_keys_.Mutable(index)->assign(value);
}
inline void GetUpdatesResponse::set_encryption_keys(int index, const void* value, size_t size) {
  encryption_keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GetUpdatesResponse::add_encryption_keys() {
  return encryption_keys_.Add();
}
inline void GetUpdatesResponse::add_encryption_keys(const ::std::string& value) {
  encryption_keys_.Add()->assign(value);
}
inline void GetUpdatesResponse::add_encryption_keys(const char* value) {
  encryption_keys_.Add()->assign(value);
}
inline void GetUpdatesResponse::add_encryption_keys(const void* value, size_t size) {
  encryption_keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetUpdatesResponse::encryption_keys() const {
  return encryption_keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetUpdatesResponse::mutable_encryption_keys() {
  return &encryption_keys_;
}

// -------------------------------------------------------------------

// GetUpdatesMetadataResponse

// optional int64 changes_remaining = 1;
inline bool GetUpdatesMetadataResponse::has_changes_remaining() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetUpdatesMetadataResponse::set_has_changes_remaining() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetUpdatesMetadataResponse::clear_has_changes_remaining() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetUpdatesMetadataResponse::clear_changes_remaining() {
  changes_remaining_ = GOOGLE_LONGLONG(0);
  clear_has_changes_remaining();
}
inline ::google::protobuf::int64 GetUpdatesMetadataResponse::changes_remaining() const {
  return changes_remaining_;
}
inline void GetUpdatesMetadataResponse::set_changes_remaining(::google::protobuf::int64 value) {
  set_has_changes_remaining();
  changes_remaining_ = value;
}

// repeated .sync_pb.DataTypeProgressMarker new_progress_marker = 2;
inline int GetUpdatesMetadataResponse::new_progress_marker_size() const {
  return new_progress_marker_.size();
}
inline void GetUpdatesMetadataResponse::clear_new_progress_marker() {
  new_progress_marker_.Clear();
}
inline const ::sync_pb::DataTypeProgressMarker& GetUpdatesMetadataResponse::new_progress_marker(int index) const {
  return new_progress_marker_.Get(index);
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesMetadataResponse::mutable_new_progress_marker(int index) {
  return new_progress_marker_.Mutable(index);
}
inline ::sync_pb::DataTypeProgressMarker* GetUpdatesMetadataResponse::add_new_progress_marker() {
  return new_progress_marker_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >&
GetUpdatesMetadataResponse::new_progress_marker() const {
  return new_progress_marker_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::DataTypeProgressMarker >*
GetUpdatesMetadataResponse::mutable_new_progress_marker() {
  return &new_progress_marker_;
}

// -------------------------------------------------------------------

// GetUpdatesStreamingResponse

// repeated .sync_pb.SyncEntity entries = 1;
inline int GetUpdatesStreamingResponse::entries_size() const {
  return entries_.size();
}
inline void GetUpdatesStreamingResponse::clear_entries() {
  entries_.Clear();
}
inline const ::sync_pb::SyncEntity& GetUpdatesStreamingResponse::entries(int index) const {
  return entries_.Get(index);
}
inline ::sync_pb::SyncEntity* GetUpdatesStreamingResponse::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::sync_pb::SyncEntity* GetUpdatesStreamingResponse::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >&
GetUpdatesStreamingResponse::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncEntity >*
GetUpdatesStreamingResponse::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// UserIdentification

// required string email = 1;
inline bool UserIdentification::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserIdentification::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserIdentification::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserIdentification::clear_email() {
  if (email_ != &::google::protobuf::internal::GetEmptyString()) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& UserIdentification::email() const {
  return *email_;
}
inline void UserIdentification::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyString()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserIdentification::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyString()) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void UserIdentification::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyString()) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserIdentification::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyString()) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* UserIdentification::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void UserIdentification::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::GetEmptyString()) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string display_name = 2;
inline bool UserIdentification::has_display_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserIdentification::set_has_display_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserIdentification::clear_has_display_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserIdentification::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::GetEmptyString()) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& UserIdentification::display_name() const {
  return *display_name_;
}
inline void UserIdentification::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyString()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void UserIdentification::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyString()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void UserIdentification::set_display_name(const char* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyString()) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserIdentification::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyString()) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}
inline ::std::string* UserIdentification::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void UserIdentification::set_allocated_display_name(::std::string* display_name) {
  if (display_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete display_name_;
  }
  if (display_name) {
    set_has_display_name();
    display_name_ = display_name;
  } else {
    clear_has_display_name();
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string obfuscated_id = 3;
inline bool UserIdentification::has_obfuscated_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserIdentification::set_has_obfuscated_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserIdentification::clear_has_obfuscated_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserIdentification::clear_obfuscated_id() {
  if (obfuscated_id_ != &::google::protobuf::internal::GetEmptyString()) {
    obfuscated_id_->clear();
  }
  clear_has_obfuscated_id();
}
inline const ::std::string& UserIdentification::obfuscated_id() const {
  return *obfuscated_id_;
}
inline void UserIdentification::set_obfuscated_id(const ::std::string& value) {
  set_has_obfuscated_id();
  if (obfuscated_id_ == &::google::protobuf::internal::GetEmptyString()) {
    obfuscated_id_ = new ::std::string;
  }
  obfuscated_id_->assign(value);
}
inline void UserIdentification::set_obfuscated_id(const char* value) {
  set_has_obfuscated_id();
  if (obfuscated_id_ == &::google::protobuf::internal::GetEmptyString()) {
    obfuscated_id_ = new ::std::string;
  }
  obfuscated_id_->assign(value);
}
inline void UserIdentification::set_obfuscated_id(const char* value, size_t size) {
  set_has_obfuscated_id();
  if (obfuscated_id_ == &::google::protobuf::internal::GetEmptyString()) {
    obfuscated_id_ = new ::std::string;
  }
  obfuscated_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserIdentification::mutable_obfuscated_id() {
  set_has_obfuscated_id();
  if (obfuscated_id_ == &::google::protobuf::internal::GetEmptyString()) {
    obfuscated_id_ = new ::std::string;
  }
  return obfuscated_id_;
}
inline ::std::string* UserIdentification::release_obfuscated_id() {
  clear_has_obfuscated_id();
  if (obfuscated_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = obfuscated_id_;
    obfuscated_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void UserIdentification::set_allocated_obfuscated_id(::std::string* obfuscated_id) {
  if (obfuscated_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete obfuscated_id_;
  }
  if (obfuscated_id) {
    set_has_obfuscated_id();
    obfuscated_id_ = obfuscated_id;
  } else {
    clear_has_obfuscated_id();
    obfuscated_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// AuthenticateResponse

// optional .sync_pb.UserIdentification user = 1;
inline bool AuthenticateResponse::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthenticateResponse::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthenticateResponse::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthenticateResponse::clear_user() {
  if (user_ != NULL) user_->::sync_pb::UserIdentification::Clear();
  clear_has_user();
}
inline const ::sync_pb::UserIdentification& AuthenticateResponse::user() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return user_ != NULL ? *user_ : *default_instance().user_;
#else
  return user_ != NULL ? *user_ : *default_instance_->user_;
#endif
}
inline ::sync_pb::UserIdentification* AuthenticateResponse::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::sync_pb::UserIdentification;
  return user_;
}
inline ::sync_pb::UserIdentification* AuthenticateResponse::release_user() {
  clear_has_user();
  ::sync_pb::UserIdentification* temp = user_;
  user_ = NULL;
  return temp;
}
inline void AuthenticateResponse::set_allocated_user(::sync_pb::UserIdentification* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// -------------------------------------------------------------------

// ThrottleParameters

// required int32 min_measure_payload_size = 1;
inline bool ThrottleParameters::has_min_measure_payload_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ThrottleParameters::set_has_min_measure_payload_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ThrottleParameters::clear_has_min_measure_payload_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ThrottleParameters::clear_min_measure_payload_size() {
  min_measure_payload_size_ = 0;
  clear_has_min_measure_payload_size();
}
inline ::google::protobuf::int32 ThrottleParameters::min_measure_payload_size() const {
  return min_measure_payload_size_;
}
inline void ThrottleParameters::set_min_measure_payload_size(::google::protobuf::int32 value) {
  set_has_min_measure_payload_size();
  min_measure_payload_size_ = value;
}

// required double target_utilization = 2;
inline bool ThrottleParameters::has_target_utilization() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ThrottleParameters::set_has_target_utilization() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ThrottleParameters::clear_has_target_utilization() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ThrottleParameters::clear_target_utilization() {
  target_utilization_ = 0;
  clear_has_target_utilization();
}
inline double ThrottleParameters::target_utilization() const {
  return target_utilization_;
}
inline void ThrottleParameters::set_target_utilization(double value) {
  set_has_target_utilization();
  target_utilization_ = value;
}

// required double measure_interval_max = 3;
inline bool ThrottleParameters::has_measure_interval_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ThrottleParameters::set_has_measure_interval_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ThrottleParameters::clear_has_measure_interval_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ThrottleParameters::clear_measure_interval_max() {
  measure_interval_max_ = 0;
  clear_has_measure_interval_max();
}
inline double ThrottleParameters::measure_interval_max() const {
  return measure_interval_max_;
}
inline void ThrottleParameters::set_measure_interval_max(double value) {
  set_has_measure_interval_max();
  measure_interval_max_ = value;
}

// required double measure_interval_min = 4;
inline bool ThrottleParameters::has_measure_interval_min() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ThrottleParameters::set_has_measure_interval_min() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ThrottleParameters::clear_has_measure_interval_min() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ThrottleParameters::clear_measure_interval_min() {
  measure_interval_min_ = 0;
  clear_has_measure_interval_min();
}
inline double ThrottleParameters::measure_interval_min() const {
  return measure_interval_min_;
}
inline void ThrottleParameters::set_measure_interval_min(double value) {
  set_has_measure_interval_min();
  measure_interval_min_ = value;
}

// required double observation_window = 5;
inline bool ThrottleParameters::has_observation_window() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ThrottleParameters::set_has_observation_window() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ThrottleParameters::clear_has_observation_window() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ThrottleParameters::clear_observation_window() {
  observation_window_ = 0;
  clear_has_observation_window();
}
inline double ThrottleParameters::observation_window() const {
  return observation_window_;
}
inline void ThrottleParameters::set_observation_window(double value) {
  set_has_observation_window();
  observation_window_ = value;
}

// -------------------------------------------------------------------

// ClientToServerResponse_Error

// optional .sync_pb.SyncEnums.ErrorType error_type = 1 [default = UNKNOWN];
inline bool ClientToServerResponse_Error::has_error_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerResponse_Error::set_has_error_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerResponse_Error::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerResponse_Error::clear_error_type() {
  error_type_ = 100;
  clear_has_error_type();
}
inline ::sync_pb::SyncEnums_ErrorType ClientToServerResponse_Error::error_type() const {
  return static_cast< ::sync_pb::SyncEnums_ErrorType >(error_type_);
}
inline void ClientToServerResponse_Error::set_error_type(::sync_pb::SyncEnums_ErrorType value) {
  assert(::sync_pb::SyncEnums_ErrorType_IsValid(value));
  set_has_error_type();
  error_type_ = value;
}

// optional string error_description = 2;
inline bool ClientToServerResponse_Error::has_error_description() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToServerResponse_Error::set_has_error_description() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToServerResponse_Error::clear_has_error_description() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToServerResponse_Error::clear_error_description() {
  if (error_description_ != &::google::protobuf::internal::GetEmptyString()) {
    error_description_->clear();
  }
  clear_has_error_description();
}
inline const ::std::string& ClientToServerResponse_Error::error_description() const {
  return *error_description_;
}
inline void ClientToServerResponse_Error::set_error_description(const ::std::string& value) {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::GetEmptyString()) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(value);
}
inline void ClientToServerResponse_Error::set_error_description(const char* value) {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::GetEmptyString()) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(value);
}
inline void ClientToServerResponse_Error::set_error_description(const char* value, size_t size) {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::GetEmptyString()) {
    error_description_ = new ::std::string;
  }
  error_description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToServerResponse_Error::mutable_error_description() {
  set_has_error_description();
  if (error_description_ == &::google::protobuf::internal::GetEmptyString()) {
    error_description_ = new ::std::string;
  }
  return error_description_;
}
inline ::std::string* ClientToServerResponse_Error::release_error_description() {
  clear_has_error_description();
  if (error_description_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = error_description_;
    error_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClientToServerResponse_Error::set_allocated_error_description(::std::string* error_description) {
  if (error_description_ != &::google::protobuf::internal::GetEmptyString()) {
    delete error_description_;
  }
  if (error_description) {
    set_has_error_description();
    error_description_ = error_description;
  } else {
    clear_has_error_description();
    error_description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string url = 3;
inline bool ClientToServerResponse_Error::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientToServerResponse_Error::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientToServerResponse_Error::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientToServerResponse_Error::clear_url() {
  if (url_ != &::google::protobuf::internal::GetEmptyString()) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ClientToServerResponse_Error::url() const {
  return *url_;
}
inline void ClientToServerResponse_Error::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientToServerResponse_Error::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ClientToServerResponse_Error::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToServerResponse_Error::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ClientToServerResponse_Error::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClientToServerResponse_Error::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::GetEmptyString()) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.SyncEnums.Action action = 4 [default = UNKNOWN_ACTION];
inline bool ClientToServerResponse_Error::has_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientToServerResponse_Error::set_has_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientToServerResponse_Error::clear_has_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientToServerResponse_Error::clear_action() {
  action_ = 5;
  clear_has_action();
}
inline ::sync_pb::SyncEnums_Action ClientToServerResponse_Error::action() const {
  return static_cast< ::sync_pb::SyncEnums_Action >(action_);
}
inline void ClientToServerResponse_Error::set_action(::sync_pb::SyncEnums_Action value) {
  assert(::sync_pb::SyncEnums_Action_IsValid(value));
  set_has_action();
  action_ = value;
}

// repeated int32 error_data_type_ids = 5;
inline int ClientToServerResponse_Error::error_data_type_ids_size() const {
  return error_data_type_ids_.size();
}
inline void ClientToServerResponse_Error::clear_error_data_type_ids() {
  error_data_type_ids_.Clear();
}
inline ::google::protobuf::int32 ClientToServerResponse_Error::error_data_type_ids(int index) const {
  return error_data_type_ids_.Get(index);
}
inline void ClientToServerResponse_Error::set_error_data_type_ids(int index, ::google::protobuf::int32 value) {
  error_data_type_ids_.Set(index, value);
}
inline void ClientToServerResponse_Error::add_error_data_type_ids(::google::protobuf::int32 value) {
  error_data_type_ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ClientToServerResponse_Error::error_data_type_ids() const {
  return error_data_type_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ClientToServerResponse_Error::mutable_error_data_type_ids() {
  return &error_data_type_ids_;
}

// -------------------------------------------------------------------

// ClientToServerResponse

// optional .sync_pb.CommitResponse commit = 1;
inline bool ClientToServerResponse::has_commit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientToServerResponse::set_has_commit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientToServerResponse::clear_has_commit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientToServerResponse::clear_commit() {
  if (commit_ != NULL) commit_->::sync_pb::CommitResponse::Clear();
  clear_has_commit();
}
inline const ::sync_pb::CommitResponse& ClientToServerResponse::commit() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return commit_ != NULL ? *commit_ : *default_instance().commit_;
#else
  return commit_ != NULL ? *commit_ : *default_instance_->commit_;
#endif
}
inline ::sync_pb::CommitResponse* ClientToServerResponse::mutable_commit() {
  set_has_commit();
  if (commit_ == NULL) commit_ = new ::sync_pb::CommitResponse;
  return commit_;
}
inline ::sync_pb::CommitResponse* ClientToServerResponse::release_commit() {
  clear_has_commit();
  ::sync_pb::CommitResponse* temp = commit_;
  commit_ = NULL;
  return temp;
}
inline void ClientToServerResponse::set_allocated_commit(::sync_pb::CommitResponse* commit) {
  delete commit_;
  commit_ = commit;
  if (commit) {
    set_has_commit();
  } else {
    clear_has_commit();
  }
}

// optional .sync_pb.GetUpdatesResponse get_updates = 2;
inline bool ClientToServerResponse::has_get_updates() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientToServerResponse::set_has_get_updates() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientToServerResponse::clear_has_get_updates() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientToServerResponse::clear_get_updates() {
  if (get_updates_ != NULL) get_updates_->::sync_pb::GetUpdatesResponse::Clear();
  clear_has_get_updates();
}
inline const ::sync_pb::GetUpdatesResponse& ClientToServerResponse::get_updates() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return get_updates_ != NULL ? *get_updates_ : *default_instance().get_updates_;
#else
  return get_updates_ != NULL ? *get_updates_ : *default_instance_->get_updates_;
#endif
}
inline ::sync_pb::GetUpdatesResponse* ClientToServerResponse::mutable_get_updates() {
  set_has_get_updates();
  if (get_updates_ == NULL) get_updates_ = new ::sync_pb::GetUpdatesResponse;
  return get_updates_;
}
inline ::sync_pb::GetUpdatesResponse* ClientToServerResponse::release_get_updates() {
  clear_has_get_updates();
  ::sync_pb::GetUpdatesResponse* temp = get_updates_;
  get_updates_ = NULL;
  return temp;
}
inline void ClientToServerResponse::set_allocated_get_updates(::sync_pb::GetUpdatesResponse* get_updates) {
  delete get_updates_;
  get_updates_ = get_updates;
  if (get_updates) {
    set_has_get_updates();
  } else {
    clear_has_get_updates();
  }
}

// optional .sync_pb.AuthenticateResponse authenticate = 3;
inline bool ClientToServerResponse::has_authenticate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientToServerResponse::set_has_authenticate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientToServerResponse::clear_has_authenticate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientToServerResponse::clear_authenticate() {
  if (authenticate_ != NULL) authenticate_->::sync_pb::AuthenticateResponse::Clear();
  clear_has_authenticate();
}
inline const ::sync_pb::AuthenticateResponse& ClientToServerResponse::authenticate() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return authenticate_ != NULL ? *authenticate_ : *default_instance().authenticate_;
#else
  return authenticate_ != NULL ? *authenticate_ : *default_instance_->authenticate_;
#endif
}
inline ::sync_pb::AuthenticateResponse* ClientToServerResponse::mutable_authenticate() {
  set_has_authenticate();
  if (authenticate_ == NULL) authenticate_ = new ::sync_pb::AuthenticateResponse;
  return authenticate_;
}
inline ::sync_pb::AuthenticateResponse* ClientToServerResponse::release_authenticate() {
  clear_has_authenticate();
  ::sync_pb::AuthenticateResponse* temp = authenticate_;
  authenticate_ = NULL;
  return temp;
}
inline void ClientToServerResponse::set_allocated_authenticate(::sync_pb::AuthenticateResponse* authenticate) {
  delete authenticate_;
  authenticate_ = authenticate;
  if (authenticate) {
    set_has_authenticate();
  } else {
    clear_has_authenticate();
  }
}

// optional .sync_pb.SyncEnums.ErrorType error_code = 4 [default = UNKNOWN];
inline bool ClientToServerResponse::has_error_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientToServerResponse::set_has_error_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientToServerResponse::clear_has_error_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientToServerResponse::clear_error_code() {
  error_code_ = 100;
  clear_has_error_code();
}
inline ::sync_pb::SyncEnums_ErrorType ClientToServerResponse::error_code() const {
  return static_cast< ::sync_pb::SyncEnums_ErrorType >(error_code_);
}
inline void ClientToServerResponse::set_error_code(::sync_pb::SyncEnums_ErrorType value) {
  assert(::sync_pb::SyncEnums_ErrorType_IsValid(value));
  set_has_error_code();
  error_code_ = value;
}

// optional string error_message = 5;
inline bool ClientToServerResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientToServerResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientToServerResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientToServerResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::GetEmptyString()) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& ClientToServerResponse::error_message() const {
  return *error_message_;
}
inline void ClientToServerResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyString()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ClientToServerResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyString()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void ClientToServerResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyString()) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToServerResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyString()) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* ClientToServerResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClientToServerResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::GetEmptyString()) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string store_birthday = 6;
inline bool ClientToServerResponse::has_store_birthday() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientToServerResponse::set_has_store_birthday() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientToServerResponse::clear_has_store_birthday() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientToServerResponse::clear_store_birthday() {
  if (store_birthday_ != &::google::protobuf::internal::GetEmptyString()) {
    store_birthday_->clear();
  }
  clear_has_store_birthday();
}
inline const ::std::string& ClientToServerResponse::store_birthday() const {
  return *store_birthday_;
}
inline void ClientToServerResponse::set_store_birthday(const ::std::string& value) {
  set_has_store_birthday();
  if (store_birthday_ == &::google::protobuf::internal::GetEmptyString()) {
    store_birthday_ = new ::std::string;
  }
  store_birthday_->assign(value);
}
inline void ClientToServerResponse::set_store_birthday(const char* value) {
  set_has_store_birthday();
  if (store_birthday_ == &::google::protobuf::internal::GetEmptyString()) {
    store_birthday_ = new ::std::string;
  }
  store_birthday_->assign(value);
}
inline void ClientToServerResponse::set_store_birthday(const char* value, size_t size) {
  set_has_store_birthday();
  if (store_birthday_ == &::google::protobuf::internal::GetEmptyString()) {
    store_birthday_ = new ::std::string;
  }
  store_birthday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientToServerResponse::mutable_store_birthday() {
  set_has_store_birthday();
  if (store_birthday_ == &::google::protobuf::internal::GetEmptyString()) {
    store_birthday_ = new ::std::string;
  }
  return store_birthday_;
}
inline ::std::string* ClientToServerResponse::release_store_birthday() {
  clear_has_store_birthday();
  if (store_birthday_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = store_birthday_;
    store_birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void ClientToServerResponse::set_allocated_store_birthday(::std::string* store_birthday) {
  if (store_birthday_ != &::google::protobuf::internal::GetEmptyString()) {
    delete store_birthday_;
  }
  if (store_birthday) {
    set_has_store_birthday();
    store_birthday_ = store_birthday;
  } else {
    clear_has_store_birthday();
    store_birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.ClientCommand client_command = 7;
inline bool ClientToServerResponse::has_client_command() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClientToServerResponse::set_has_client_command() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClientToServerResponse::clear_has_client_command() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClientToServerResponse::clear_client_command() {
  if (client_command_ != NULL) client_command_->::sync_pb::ClientCommand::Clear();
  clear_has_client_command();
}
inline const ::sync_pb::ClientCommand& ClientToServerResponse::client_command() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return client_command_ != NULL ? *client_command_ : *default_instance().client_command_;
#else
  return client_command_ != NULL ? *client_command_ : *default_instance_->client_command_;
#endif
}
inline ::sync_pb::ClientCommand* ClientToServerResponse::mutable_client_command() {
  set_has_client_command();
  if (client_command_ == NULL) client_command_ = new ::sync_pb::ClientCommand;
  return client_command_;
}
inline ::sync_pb::ClientCommand* ClientToServerResponse::release_client_command() {
  clear_has_client_command();
  ::sync_pb::ClientCommand* temp = client_command_;
  client_command_ = NULL;
  return temp;
}
inline void ClientToServerResponse::set_allocated_client_command(::sync_pb::ClientCommand* client_command) {
  delete client_command_;
  client_command_ = client_command;
  if (client_command) {
    set_has_client_command();
  } else {
    clear_has_client_command();
  }
}

// optional .sync_pb.ProfilingData profiling_data = 8;
inline bool ClientToServerResponse::has_profiling_data() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClientToServerResponse::set_has_profiling_data() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClientToServerResponse::clear_has_profiling_data() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClientToServerResponse::clear_profiling_data() {
  if (profiling_data_ != NULL) profiling_data_->::sync_pb::ProfilingData::Clear();
  clear_has_profiling_data();
}
inline const ::sync_pb::ProfilingData& ClientToServerResponse::profiling_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return profiling_data_ != NULL ? *profiling_data_ : *default_instance().profiling_data_;
#else
  return profiling_data_ != NULL ? *profiling_data_ : *default_instance_->profiling_data_;
#endif
}
inline ::sync_pb::ProfilingData* ClientToServerResponse::mutable_profiling_data() {
  set_has_profiling_data();
  if (profiling_data_ == NULL) profiling_data_ = new ::sync_pb::ProfilingData;
  return profiling_data_;
}
inline ::sync_pb::ProfilingData* ClientToServerResponse::release_profiling_data() {
  clear_has_profiling_data();
  ::sync_pb::ProfilingData* temp = profiling_data_;
  profiling_data_ = NULL;
  return temp;
}
inline void ClientToServerResponse::set_allocated_profiling_data(::sync_pb::ProfilingData* profiling_data) {
  delete profiling_data_;
  profiling_data_ = profiling_data;
  if (profiling_data) {
    set_has_profiling_data();
  } else {
    clear_has_profiling_data();
  }
}

// optional .sync_pb.ClearUserDataResponse clear_user_data = 9;
inline bool ClientToServerResponse::has_clear_user_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClientToServerResponse::set_has_clear_user_data() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClientToServerResponse::clear_has_clear_user_data() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClientToServerResponse::clear_clear_user_data() {
  if (clear_user_data_ != NULL) clear_user_data_->::sync_pb::ClearUserDataResponse::Clear();
  clear_has_clear_user_data();
}
inline const ::sync_pb::ClearUserDataResponse& ClientToServerResponse::clear_user_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return clear_user_data_ != NULL ? *clear_user_data_ : *default_instance().clear_user_data_;
#else
  return clear_user_data_ != NULL ? *clear_user_data_ : *default_instance_->clear_user_data_;
#endif
}
inline ::sync_pb::ClearUserDataResponse* ClientToServerResponse::mutable_clear_user_data() {
  set_has_clear_user_data();
  if (clear_user_data_ == NULL) clear_user_data_ = new ::sync_pb::ClearUserDataResponse;
  return clear_user_data_;
}
inline ::sync_pb::ClearUserDataResponse* ClientToServerResponse::release_clear_user_data() {
  clear_has_clear_user_data();
  ::sync_pb::ClearUserDataResponse* temp = clear_user_data_;
  clear_user_data_ = NULL;
  return temp;
}
inline void ClientToServerResponse::set_allocated_clear_user_data(::sync_pb::ClearUserDataResponse* clear_user_data) {
  delete clear_user_data_;
  clear_user_data_ = clear_user_data;
  if (clear_user_data) {
    set_has_clear_user_data();
  } else {
    clear_has_clear_user_data();
  }
}

// optional .sync_pb.GetUpdatesMetadataResponse stream_metadata = 10;
inline bool ClientToServerResponse::has_stream_metadata() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClientToServerResponse::set_has_stream_metadata() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClientToServerResponse::clear_has_stream_metadata() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClientToServerResponse::clear_stream_metadata() {
  if (stream_metadata_ != NULL) stream_metadata_->::sync_pb::GetUpdatesMetadataResponse::Clear();
  clear_has_stream_metadata();
}
inline const ::sync_pb::GetUpdatesMetadataResponse& ClientToServerResponse::stream_metadata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stream_metadata_ != NULL ? *stream_metadata_ : *default_instance().stream_metadata_;
#else
  return stream_metadata_ != NULL ? *stream_metadata_ : *default_instance_->stream_metadata_;
#endif
}
inline ::sync_pb::GetUpdatesMetadataResponse* ClientToServerResponse::mutable_stream_metadata() {
  set_has_stream_metadata();
  if (stream_metadata_ == NULL) stream_metadata_ = new ::sync_pb::GetUpdatesMetadataResponse;
  return stream_metadata_;
}
inline ::sync_pb::GetUpdatesMetadataResponse* ClientToServerResponse::release_stream_metadata() {
  clear_has_stream_metadata();
  ::sync_pb::GetUpdatesMetadataResponse* temp = stream_metadata_;
  stream_metadata_ = NULL;
  return temp;
}
inline void ClientToServerResponse::set_allocated_stream_metadata(::sync_pb::GetUpdatesMetadataResponse* stream_metadata) {
  delete stream_metadata_;
  stream_metadata_ = stream_metadata;
  if (stream_metadata) {
    set_has_stream_metadata();
  } else {
    clear_has_stream_metadata();
  }
}

// optional .sync_pb.GetUpdatesStreamingResponse stream_data = 11;
inline bool ClientToServerResponse::has_stream_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClientToServerResponse::set_has_stream_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClientToServerResponse::clear_has_stream_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClientToServerResponse::clear_stream_data() {
  if (stream_data_ != NULL) stream_data_->::sync_pb::GetUpdatesStreamingResponse::Clear();
  clear_has_stream_data();
}
inline const ::sync_pb::GetUpdatesStreamingResponse& ClientToServerResponse::stream_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return stream_data_ != NULL ? *stream_data_ : *default_instance().stream_data_;
#else
  return stream_data_ != NULL ? *stream_data_ : *default_instance_->stream_data_;
#endif
}
inline ::sync_pb::GetUpdatesStreamingResponse* ClientToServerResponse::mutable_stream_data() {
  set_has_stream_data();
  if (stream_data_ == NULL) stream_data_ = new ::sync_pb::GetUpdatesStreamingResponse;
  return stream_data_;
}
inline ::sync_pb::GetUpdatesStreamingResponse* ClientToServerResponse::release_stream_data() {
  clear_has_stream_data();
  ::sync_pb::GetUpdatesStreamingResponse* temp = stream_data_;
  stream_data_ = NULL;
  return temp;
}
inline void ClientToServerResponse::set_allocated_stream_data(::sync_pb::GetUpdatesStreamingResponse* stream_data) {
  delete stream_data_;
  stream_data_ = stream_data;
  if (stream_data) {
    set_has_stream_data();
  } else {
    clear_has_stream_data();
  }
}

// repeated int32 migrated_data_type_id = 12;
inline int ClientToServerResponse::migrated_data_type_id_size() const {
  return migrated_data_type_id_.size();
}
inline void ClientToServerResponse::clear_migrated_data_type_id() {
  migrated_data_type_id_.Clear();
}
inline ::google::protobuf::int32 ClientToServerResponse::migrated_data_type_id(int index) const {
  return migrated_data_type_id_.Get(index);
}
inline void ClientToServerResponse::set_migrated_data_type_id(int index, ::google::protobuf::int32 value) {
  migrated_data_type_id_.Set(index, value);
}
inline void ClientToServerResponse::add_migrated_data_type_id(::google::protobuf::int32 value) {
  migrated_data_type_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ClientToServerResponse::migrated_data_type_id() const {
  return migrated_data_type_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ClientToServerResponse::mutable_migrated_data_type_id() {
  return &migrated_data_type_id_;
}

// optional .sync_pb.ClientToServerResponse.Error error = 13;
inline bool ClientToServerResponse::has_error() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClientToServerResponse::set_has_error() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClientToServerResponse::clear_has_error() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClientToServerResponse::clear_error() {
  if (error_ != NULL) error_->::sync_pb::ClientToServerResponse_Error::Clear();
  clear_has_error();
}
inline const ::sync_pb::ClientToServerResponse_Error& ClientToServerResponse::error() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return error_ != NULL ? *error_ : *default_instance().error_;
#else
  return error_ != NULL ? *error_ : *default_instance_->error_;
#endif
}
inline ::sync_pb::ClientToServerResponse_Error* ClientToServerResponse::mutable_error() {
  set_has_error();
  if (error_ == NULL) error_ = new ::sync_pb::ClientToServerResponse_Error;
  return error_;
}
inline ::sync_pb::ClientToServerResponse_Error* ClientToServerResponse::release_error() {
  clear_has_error();
  ::sync_pb::ClientToServerResponse_Error* temp = error_;
  error_ = NULL;
  return temp;
}
inline void ClientToServerResponse::set_allocated_error(::sync_pb::ClientToServerResponse_Error* error) {
  delete error_;
  error_ = error;
  if (error) {
    set_has_error();
  } else {
    clear_has_error();
  }
}

// optional .sync_pb.ChipBag new_bag_of_chips = 14;
inline bool ClientToServerResponse::has_new_bag_of_chips() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ClientToServerResponse::set_has_new_bag_of_chips() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ClientToServerResponse::clear_has_new_bag_of_chips() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ClientToServerResponse::clear_new_bag_of_chips() {
  if (new_bag_of_chips_ != NULL) new_bag_of_chips_->::sync_pb::ChipBag::Clear();
  clear_has_new_bag_of_chips();
}
inline const ::sync_pb::ChipBag& ClientToServerResponse::new_bag_of_chips() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return new_bag_of_chips_ != NULL ? *new_bag_of_chips_ : *default_instance().new_bag_of_chips_;
#else
  return new_bag_of_chips_ != NULL ? *new_bag_of_chips_ : *default_instance_->new_bag_of_chips_;
#endif
}
inline ::sync_pb::ChipBag* ClientToServerResponse::mutable_new_bag_of_chips() {
  set_has_new_bag_of_chips();
  if (new_bag_of_chips_ == NULL) new_bag_of_chips_ = new ::sync_pb::ChipBag;
  return new_bag_of_chips_;
}
inline ::sync_pb::ChipBag* ClientToServerResponse::release_new_bag_of_chips() {
  clear_has_new_bag_of_chips();
  ::sync_pb::ChipBag* temp = new_bag_of_chips_;
  new_bag_of_chips_ = NULL;
  return temp;
}
inline void ClientToServerResponse::set_allocated_new_bag_of_chips(::sync_pb::ChipBag* new_bag_of_chips) {
  delete new_bag_of_chips_;
  new_bag_of_chips_ = new_bag_of_chips;
  if (new_bag_of_chips) {
    set_has_new_bag_of_chips();
  } else {
    clear_has_new_bag_of_chips();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sync_pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_sync_2eproto__INCLUDED
