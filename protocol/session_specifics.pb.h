// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: session_specifics.proto

#ifndef PROTOBUF_session_5fspecifics_2eproto__INCLUDED
#define PROTOBUF_session_5fspecifics_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "sync_enums.pb.h"
// @@protoc_insertion_point(includes)
#include "sync/base/sync_export.h"

namespace sync_pb {

// Internal implementation detail -- do not call these.
void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto();
void protobuf_AssignDesc_session_5fspecifics_2eproto();
void protobuf_ShutdownFile_session_5fspecifics_2eproto();

class SessionSpecifics;
class SessionHeader;
class SessionWindow;
class SessionTab;
class TabNavigation;

enum SessionWindow_BrowserType {
  SessionWindow_BrowserType_TYPE_TABBED = 1,
  SessionWindow_BrowserType_TYPE_POPUP = 2
};
SYNC_EXPORT bool SessionWindow_BrowserType_IsValid(int value);
const SessionWindow_BrowserType SessionWindow_BrowserType_BrowserType_MIN = SessionWindow_BrowserType_TYPE_TABBED;
const SessionWindow_BrowserType SessionWindow_BrowserType_BrowserType_MAX = SessionWindow_BrowserType_TYPE_POPUP;
const int SessionWindow_BrowserType_BrowserType_ARRAYSIZE = SessionWindow_BrowserType_BrowserType_MAX + 1;

enum SessionTab_FaviconType {
  SessionTab_FaviconType_TYPE_WEB_FAVICON = 1
};
SYNC_EXPORT bool SessionTab_FaviconType_IsValid(int value);
const SessionTab_FaviconType SessionTab_FaviconType_FaviconType_MIN = SessionTab_FaviconType_TYPE_WEB_FAVICON;
const SessionTab_FaviconType SessionTab_FaviconType_FaviconType_MAX = SessionTab_FaviconType_TYPE_WEB_FAVICON;
const int SessionTab_FaviconType_FaviconType_ARRAYSIZE = SessionTab_FaviconType_FaviconType_MAX + 1;

enum TabNavigation_BlockedState {
  TabNavigation_BlockedState_STATE_ALLOWED = 1,
  TabNavigation_BlockedState_STATE_BLOCKED = 2
};
SYNC_EXPORT bool TabNavigation_BlockedState_IsValid(int value);
const TabNavigation_BlockedState TabNavigation_BlockedState_BlockedState_MIN = TabNavigation_BlockedState_STATE_ALLOWED;
const TabNavigation_BlockedState TabNavigation_BlockedState_BlockedState_MAX = TabNavigation_BlockedState_STATE_BLOCKED;
const int TabNavigation_BlockedState_BlockedState_ARRAYSIZE = TabNavigation_BlockedState_BlockedState_MAX + 1;

// ===================================================================

class SYNC_EXPORT SessionSpecifics : public ::google::protobuf::MessageLite {
 public:
  SessionSpecifics();
  virtual ~SessionSpecifics();

  SessionSpecifics(const SessionSpecifics& from);

  inline SessionSpecifics& operator=(const SessionSpecifics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SessionSpecifics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SessionSpecifics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SessionSpecifics* other);

  // implements Message ----------------------------------------------

  SessionSpecifics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SessionSpecifics& from);
  void MergeFrom(const SessionSpecifics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string session_tag = 1;
  inline bool has_session_tag() const;
  inline void clear_session_tag();
  static const int kSessionTagFieldNumber = 1;
  inline const ::std::string& session_tag() const;
  inline void set_session_tag(const ::std::string& value);
  inline void set_session_tag(const char* value);
  inline void set_session_tag(const char* value, size_t size);
  inline ::std::string* mutable_session_tag();
  inline ::std::string* release_session_tag();
  inline void set_allocated_session_tag(::std::string* session_tag);

  // optional .sync_pb.SessionHeader header = 2;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 2;
  inline const ::sync_pb::SessionHeader& header() const;
  inline ::sync_pb::SessionHeader* mutable_header();
  inline ::sync_pb::SessionHeader* release_header();
  inline void set_allocated_header(::sync_pb::SessionHeader* header);

  // optional .sync_pb.SessionTab tab = 3;
  inline bool has_tab() const;
  inline void clear_tab();
  static const int kTabFieldNumber = 3;
  inline const ::sync_pb::SessionTab& tab() const;
  inline ::sync_pb::SessionTab* mutable_tab();
  inline ::sync_pb::SessionTab* release_tab();
  inline void set_allocated_tab(::sync_pb::SessionTab* tab);

  // optional int32 tab_node_id = 4 [default = -1];
  inline bool has_tab_node_id() const;
  inline void clear_tab_node_id();
  static const int kTabNodeIdFieldNumber = 4;
  inline ::google::protobuf::int32 tab_node_id() const;
  inline void set_tab_node_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sync_pb.SessionSpecifics)
 private:
  inline void set_has_session_tag();
  inline void clear_has_session_tag();
  inline void set_has_header();
  inline void clear_has_header();
  inline void set_has_tab();
  inline void clear_has_tab();
  inline void set_has_tab_node_id();
  inline void clear_has_tab_node_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* session_tag_;
  ::sync_pb::SessionHeader* header_;
  ::sync_pb::SessionTab* tab_;
  ::google::protobuf::int32 tab_node_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_session_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_session_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static SessionSpecifics* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SessionHeader : public ::google::protobuf::MessageLite {
 public:
  SessionHeader();
  virtual ~SessionHeader();

  SessionHeader(const SessionHeader& from);

  inline SessionHeader& operator=(const SessionHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SessionHeader& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SessionHeader* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SessionHeader* other);

  // implements Message ----------------------------------------------

  SessionHeader* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SessionHeader& from);
  void MergeFrom(const SessionHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sync_pb.SessionWindow window = 2;
  inline int window_size() const;
  inline void clear_window();
  static const int kWindowFieldNumber = 2;
  inline const ::sync_pb::SessionWindow& window(int index) const;
  inline ::sync_pb::SessionWindow* mutable_window(int index);
  inline ::sync_pb::SessionWindow* add_window();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SessionWindow >&
      window() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SessionWindow >*
      mutable_window();

  // optional string client_name = 3;
  inline bool has_client_name() const;
  inline void clear_client_name();
  static const int kClientNameFieldNumber = 3;
  inline const ::std::string& client_name() const;
  inline void set_client_name(const ::std::string& value);
  inline void set_client_name(const char* value);
  inline void set_client_name(const char* value, size_t size);
  inline ::std::string* mutable_client_name();
  inline ::std::string* release_client_name();
  inline void set_allocated_client_name(::std::string* client_name);

  // optional .sync_pb.SyncEnums.DeviceType device_type = 4;
  inline bool has_device_type() const;
  inline void clear_device_type();
  static const int kDeviceTypeFieldNumber = 4;
  inline ::sync_pb::SyncEnums_DeviceType device_type() const;
  inline void set_device_type(::sync_pb::SyncEnums_DeviceType value);

  // @@protoc_insertion_point(class_scope:sync_pb.SessionHeader)
 private:
  inline void set_has_client_name();
  inline void clear_has_client_name();
  inline void set_has_device_type();
  inline void clear_has_device_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sync_pb::SessionWindow > window_;
  ::std::string* client_name_;
  int device_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_session_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_session_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static SessionHeader* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SessionWindow : public ::google::protobuf::MessageLite {
 public:
  SessionWindow();
  virtual ~SessionWindow();

  SessionWindow(const SessionWindow& from);

  inline SessionWindow& operator=(const SessionWindow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SessionWindow& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SessionWindow* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SessionWindow* other);

  // implements Message ----------------------------------------------

  SessionWindow* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SessionWindow& from);
  void MergeFrom(const SessionWindow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SessionWindow_BrowserType BrowserType;
  static const BrowserType TYPE_TABBED = SessionWindow_BrowserType_TYPE_TABBED;
  static const BrowserType TYPE_POPUP = SessionWindow_BrowserType_TYPE_POPUP;
  static inline bool BrowserType_IsValid(int value) {
    return SessionWindow_BrowserType_IsValid(value);
  }
  static const BrowserType BrowserType_MIN =
    SessionWindow_BrowserType_BrowserType_MIN;
  static const BrowserType BrowserType_MAX =
    SessionWindow_BrowserType_BrowserType_MAX;
  static const int BrowserType_ARRAYSIZE =
    SessionWindow_BrowserType_BrowserType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 window_id = 1;
  inline bool has_window_id() const;
  inline void clear_window_id();
  static const int kWindowIdFieldNumber = 1;
  inline ::google::protobuf::int32 window_id() const;
  inline void set_window_id(::google::protobuf::int32 value);

  // optional int32 selected_tab_index = 2 [default = -1];
  inline bool has_selected_tab_index() const;
  inline void clear_selected_tab_index();
  static const int kSelectedTabIndexFieldNumber = 2;
  inline ::google::protobuf::int32 selected_tab_index() const;
  inline void set_selected_tab_index(::google::protobuf::int32 value);

  // optional .sync_pb.SessionWindow.BrowserType browser_type = 3 [default = TYPE_TABBED];
  inline bool has_browser_type() const;
  inline void clear_browser_type();
  static const int kBrowserTypeFieldNumber = 3;
  inline ::sync_pb::SessionWindow_BrowserType browser_type() const;
  inline void set_browser_type(::sync_pb::SessionWindow_BrowserType value);

  // repeated int32 tab = 4;
  inline int tab_size() const;
  inline void clear_tab();
  static const int kTabFieldNumber = 4;
  inline ::google::protobuf::int32 tab(int index) const;
  inline void set_tab(int index, ::google::protobuf::int32 value);
  inline void add_tab(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      tab() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_tab();

  // @@protoc_insertion_point(class_scope:sync_pb.SessionWindow)
 private:
  inline void set_has_window_id();
  inline void clear_has_window_id();
  inline void set_has_selected_tab_index();
  inline void clear_has_selected_tab_index();
  inline void set_has_browser_type();
  inline void clear_has_browser_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 window_id_;
  ::google::protobuf::int32 selected_tab_index_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > tab_;
  int browser_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_session_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_session_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static SessionWindow* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SessionTab : public ::google::protobuf::MessageLite {
 public:
  SessionTab();
  virtual ~SessionTab();

  SessionTab(const SessionTab& from);

  inline SessionTab& operator=(const SessionTab& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SessionTab& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SessionTab* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SessionTab* other);

  // implements Message ----------------------------------------------

  SessionTab* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SessionTab& from);
  void MergeFrom(const SessionTab& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef SessionTab_FaviconType FaviconType;
  static const FaviconType TYPE_WEB_FAVICON = SessionTab_FaviconType_TYPE_WEB_FAVICON;
  static inline bool FaviconType_IsValid(int value) {
    return SessionTab_FaviconType_IsValid(value);
  }
  static const FaviconType FaviconType_MIN =
    SessionTab_FaviconType_FaviconType_MIN;
  static const FaviconType FaviconType_MAX =
    SessionTab_FaviconType_FaviconType_MAX;
  static const int FaviconType_ARRAYSIZE =
    SessionTab_FaviconType_FaviconType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional int32 tab_id = 1;
  inline bool has_tab_id() const;
  inline void clear_tab_id();
  static const int kTabIdFieldNumber = 1;
  inline ::google::protobuf::int32 tab_id() const;
  inline void set_tab_id(::google::protobuf::int32 value);

  // optional int32 window_id = 2;
  inline bool has_window_id() const;
  inline void clear_window_id();
  static const int kWindowIdFieldNumber = 2;
  inline ::google::protobuf::int32 window_id() const;
  inline void set_window_id(::google::protobuf::int32 value);

  // optional int32 tab_visual_index = 3 [default = -1];
  inline bool has_tab_visual_index() const;
  inline void clear_tab_visual_index();
  static const int kTabVisualIndexFieldNumber = 3;
  inline ::google::protobuf::int32 tab_visual_index() const;
  inline void set_tab_visual_index(::google::protobuf::int32 value);

  // optional int32 current_navigation_index = 4 [default = -1];
  inline bool has_current_navigation_index() const;
  inline void clear_current_navigation_index();
  static const int kCurrentNavigationIndexFieldNumber = 4;
  inline ::google::protobuf::int32 current_navigation_index() const;
  inline void set_current_navigation_index(::google::protobuf::int32 value);

  // optional bool pinned = 5 [default = false];
  inline bool has_pinned() const;
  inline void clear_pinned();
  static const int kPinnedFieldNumber = 5;
  inline bool pinned() const;
  inline void set_pinned(bool value);

  // optional string extension_app_id = 6;
  inline bool has_extension_app_id() const;
  inline void clear_extension_app_id();
  static const int kExtensionAppIdFieldNumber = 6;
  inline const ::std::string& extension_app_id() const;
  inline void set_extension_app_id(const ::std::string& value);
  inline void set_extension_app_id(const char* value);
  inline void set_extension_app_id(const char* value, size_t size);
  inline ::std::string* mutable_extension_app_id();
  inline ::std::string* release_extension_app_id();
  inline void set_allocated_extension_app_id(::std::string* extension_app_id);

  // repeated .sync_pb.TabNavigation navigation = 7;
  inline int navigation_size() const;
  inline void clear_navigation();
  static const int kNavigationFieldNumber = 7;
  inline const ::sync_pb::TabNavigation& navigation(int index) const;
  inline ::sync_pb::TabNavigation* mutable_navigation(int index);
  inline ::sync_pb::TabNavigation* add_navigation();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::TabNavigation >&
      navigation() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::TabNavigation >*
      mutable_navigation();

  // optional bytes favicon = 8;
  inline bool has_favicon() const;
  inline void clear_favicon();
  static const int kFaviconFieldNumber = 8;
  inline const ::std::string& favicon() const;
  inline void set_favicon(const ::std::string& value);
  inline void set_favicon(const char* value);
  inline void set_favicon(const void* value, size_t size);
  inline ::std::string* mutable_favicon();
  inline ::std::string* release_favicon();
  inline void set_allocated_favicon(::std::string* favicon);

  // optional .sync_pb.SessionTab.FaviconType favicon_type = 9;
  inline bool has_favicon_type() const;
  inline void clear_favicon_type();
  static const int kFaviconTypeFieldNumber = 9;
  inline ::sync_pb::SessionTab_FaviconType favicon_type() const;
  inline void set_favicon_type(::sync_pb::SessionTab_FaviconType value);

  // optional string favicon_source = 11;
  inline bool has_favicon_source() const;
  inline void clear_favicon_source();
  static const int kFaviconSourceFieldNumber = 11;
  inline const ::std::string& favicon_source() const;
  inline void set_favicon_source(const ::std::string& value);
  inline void set_favicon_source(const char* value);
  inline void set_favicon_source(const char* value, size_t size);
  inline ::std::string* mutable_favicon_source();
  inline ::std::string* release_favicon_source();
  inline void set_allocated_favicon_source(::std::string* favicon_source);

  // @@protoc_insertion_point(class_scope:sync_pb.SessionTab)
 private:
  inline void set_has_tab_id();
  inline void clear_has_tab_id();
  inline void set_has_window_id();
  inline void clear_has_window_id();
  inline void set_has_tab_visual_index();
  inline void clear_has_tab_visual_index();
  inline void set_has_current_navigation_index();
  inline void clear_has_current_navigation_index();
  inline void set_has_pinned();
  inline void clear_has_pinned();
  inline void set_has_extension_app_id();
  inline void clear_has_extension_app_id();
  inline void set_has_favicon();
  inline void clear_has_favicon();
  inline void set_has_favicon_type();
  inline void clear_has_favicon_type();
  inline void set_has_favicon_source();
  inline void clear_has_favicon_source();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 tab_id_;
  ::google::protobuf::int32 window_id_;
  ::google::protobuf::int32 tab_visual_index_;
  ::google::protobuf::int32 current_navigation_index_;
  ::std::string* extension_app_id_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::TabNavigation > navigation_;
  bool pinned_;
  int favicon_type_;
  ::std::string* favicon_;
  ::std::string* favicon_source_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_session_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_session_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static SessionTab* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT TabNavigation : public ::google::protobuf::MessageLite {
 public:
  TabNavigation();
  virtual ~TabNavigation();

  TabNavigation(const TabNavigation& from);

  inline TabNavigation& operator=(const TabNavigation& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const TabNavigation& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TabNavigation* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TabNavigation* other);

  // implements Message ----------------------------------------------

  TabNavigation* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TabNavigation& from);
  void MergeFrom(const TabNavigation& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef TabNavigation_BlockedState BlockedState;
  static const BlockedState STATE_ALLOWED = TabNavigation_BlockedState_STATE_ALLOWED;
  static const BlockedState STATE_BLOCKED = TabNavigation_BlockedState_STATE_BLOCKED;
  static inline bool BlockedState_IsValid(int value) {
    return TabNavigation_BlockedState_IsValid(value);
  }
  static const BlockedState BlockedState_MIN =
    TabNavigation_BlockedState_BlockedState_MIN;
  static const BlockedState BlockedState_MAX =
    TabNavigation_BlockedState_BlockedState_MAX;
  static const int BlockedState_ARRAYSIZE =
    TabNavigation_BlockedState_BlockedState_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string virtual_url = 2;
  inline bool has_virtual_url() const;
  inline void clear_virtual_url();
  static const int kVirtualUrlFieldNumber = 2;
  inline const ::std::string& virtual_url() const;
  inline void set_virtual_url(const ::std::string& value);
  inline void set_virtual_url(const char* value);
  inline void set_virtual_url(const char* value, size_t size);
  inline ::std::string* mutable_virtual_url();
  inline ::std::string* release_virtual_url();
  inline void set_allocated_virtual_url(::std::string* virtual_url);

  // optional string referrer = 3;
  inline bool has_referrer() const;
  inline void clear_referrer();
  static const int kReferrerFieldNumber = 3;
  inline const ::std::string& referrer() const;
  inline void set_referrer(const ::std::string& value);
  inline void set_referrer(const char* value);
  inline void set_referrer(const char* value, size_t size);
  inline ::std::string* mutable_referrer();
  inline ::std::string* release_referrer();
  inline void set_allocated_referrer(::std::string* referrer);

  // optional string title = 4;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 4;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline const ::std::string& state() const;
  inline void set_state(const ::std::string& value);
  inline void set_state(const char* value);
  inline void set_state(const char* value, size_t size);
  inline ::std::string* mutable_state();
  inline ::std::string* release_state();
  inline void set_allocated_state(::std::string* state);

  // optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = TYPED];
  inline bool has_page_transition() const;
  inline void clear_page_transition();
  static const int kPageTransitionFieldNumber = 6;
  inline ::sync_pb::SyncEnums_PageTransition page_transition() const;
  inline void set_page_transition(::sync_pb::SyncEnums_PageTransition value);

  // optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;
  inline bool has_redirect_type() const;
  inline void clear_redirect_type();
  static const int kRedirectTypeFieldNumber = 7;
  inline ::sync_pb::SyncEnums_PageTransitionRedirectType redirect_type() const;
  inline void set_redirect_type(::sync_pb::SyncEnums_PageTransitionRedirectType value);

  // optional int32 unique_id = 8;
  inline bool has_unique_id() const;
  inline void clear_unique_id();
  static const int kUniqueIdFieldNumber = 8;
  inline ::google::protobuf::int32 unique_id() const;
  inline void set_unique_id(::google::protobuf::int32 value);

  // optional int64 timestamp_msec = 9;
  inline bool has_timestamp_msec() const;
  inline void clear_timestamp_msec();
  static const int kTimestampMsecFieldNumber = 9;
  inline ::google::protobuf::int64 timestamp_msec() const;
  inline void set_timestamp_msec(::google::protobuf::int64 value);

  // optional bool navigation_forward_back = 10;
  inline bool has_navigation_forward_back() const;
  inline void clear_navigation_forward_back();
  static const int kNavigationForwardBackFieldNumber = 10;
  inline bool navigation_forward_back() const;
  inline void set_navigation_forward_back(bool value);

  // optional bool navigation_from_address_bar = 11;
  inline bool has_navigation_from_address_bar() const;
  inline void clear_navigation_from_address_bar();
  static const int kNavigationFromAddressBarFieldNumber = 11;
  inline bool navigation_from_address_bar() const;
  inline void set_navigation_from_address_bar(bool value);

  // optional bool navigation_home_page = 12;
  inline bool has_navigation_home_page() const;
  inline void clear_navigation_home_page();
  static const int kNavigationHomePageFieldNumber = 12;
  inline bool navigation_home_page() const;
  inline void set_navigation_home_page(bool value);

  // optional bool navigation_chain_start = 13;
  inline bool has_navigation_chain_start() const;
  inline void clear_navigation_chain_start();
  static const int kNavigationChainStartFieldNumber = 13;
  inline bool navigation_chain_start() const;
  inline void set_navigation_chain_start(bool value);

  // optional bool navigation_chain_end = 14;
  inline bool has_navigation_chain_end() const;
  inline void clear_navigation_chain_end();
  static const int kNavigationChainEndFieldNumber = 14;
  inline bool navigation_chain_end() const;
  inline void set_navigation_chain_end(bool value);

  // optional int64 global_id = 15;
  inline bool has_global_id() const;
  inline void clear_global_id();
  static const int kGlobalIdFieldNumber = 15;
  inline ::google::protobuf::int64 global_id() const;
  inline void set_global_id(::google::protobuf::int64 value);

  // optional string search_terms = 16;
  inline bool has_search_terms() const;
  inline void clear_search_terms();
  static const int kSearchTermsFieldNumber = 16;
  inline const ::std::string& search_terms() const;
  inline void set_search_terms(const ::std::string& value);
  inline void set_search_terms(const char* value);
  inline void set_search_terms(const char* value, size_t size);
  inline ::std::string* mutable_search_terms();
  inline ::std::string* release_search_terms();
  inline void set_allocated_search_terms(::std::string* search_terms);

  // optional string favicon_url = 17;
  inline bool has_favicon_url() const;
  inline void clear_favicon_url();
  static const int kFaviconUrlFieldNumber = 17;
  inline const ::std::string& favicon_url() const;
  inline void set_favicon_url(const ::std::string& value);
  inline void set_favicon_url(const char* value);
  inline void set_favicon_url(const char* value, size_t size);
  inline ::std::string* mutable_favicon_url();
  inline ::std::string* release_favicon_url();
  inline void set_allocated_favicon_url(::std::string* favicon_url);

  // optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];
  inline bool has_blocked_state() const;
  inline void clear_blocked_state();
  static const int kBlockedStateFieldNumber = 18;
  inline ::sync_pb::TabNavigation_BlockedState blocked_state() const;
  inline void set_blocked_state(::sync_pb::TabNavigation_BlockedState value);

  // repeated string content_pack_categories = 19;
  inline int content_pack_categories_size() const;
  inline void clear_content_pack_categories();
  static const int kContentPackCategoriesFieldNumber = 19;
  inline const ::std::string& content_pack_categories(int index) const;
  inline ::std::string* mutable_content_pack_categories(int index);
  inline void set_content_pack_categories(int index, const ::std::string& value);
  inline void set_content_pack_categories(int index, const char* value);
  inline void set_content_pack_categories(int index, const char* value, size_t size);
  inline ::std::string* add_content_pack_categories();
  inline void add_content_pack_categories(const ::std::string& value);
  inline void add_content_pack_categories(const char* value);
  inline void add_content_pack_categories(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& content_pack_categories() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_content_pack_categories();

  // optional int32 http_status_code = 20;
  inline bool has_http_status_code() const;
  inline void clear_http_status_code();
  static const int kHttpStatusCodeFieldNumber = 20;
  inline ::google::protobuf::int32 http_status_code() const;
  inline void set_http_status_code(::google::protobuf::int32 value);

  // optional int32 referrer_policy = 21 [default = 1];
  inline bool has_referrer_policy() const;
  inline void clear_referrer_policy();
  static const int kReferrerPolicyFieldNumber = 21;
  inline ::google::protobuf::int32 referrer_policy() const;
  inline void set_referrer_policy(::google::protobuf::int32 value);

  // optional bool is_restored = 22;
  inline bool has_is_restored() const;
  inline void clear_is_restored();
  static const int kIsRestoredFieldNumber = 22;
  inline bool is_restored() const;
  inline void set_is_restored(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.TabNavigation)
 private:
  inline void set_has_virtual_url();
  inline void clear_has_virtual_url();
  inline void set_has_referrer();
  inline void clear_has_referrer();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_page_transition();
  inline void clear_has_page_transition();
  inline void set_has_redirect_type();
  inline void clear_has_redirect_type();
  inline void set_has_unique_id();
  inline void clear_has_unique_id();
  inline void set_has_timestamp_msec();
  inline void clear_has_timestamp_msec();
  inline void set_has_navigation_forward_back();
  inline void clear_has_navigation_forward_back();
  inline void set_has_navigation_from_address_bar();
  inline void clear_has_navigation_from_address_bar();
  inline void set_has_navigation_home_page();
  inline void clear_has_navigation_home_page();
  inline void set_has_navigation_chain_start();
  inline void clear_has_navigation_chain_start();
  inline void set_has_navigation_chain_end();
  inline void clear_has_navigation_chain_end();
  inline void set_has_global_id();
  inline void clear_has_global_id();
  inline void set_has_search_terms();
  inline void clear_has_search_terms();
  inline void set_has_favicon_url();
  inline void clear_has_favicon_url();
  inline void set_has_blocked_state();
  inline void clear_has_blocked_state();
  inline void set_has_http_status_code();
  inline void clear_has_http_status_code();
  inline void set_has_referrer_policy();
  inline void clear_has_referrer_policy();
  inline void set_has_is_restored();
  inline void clear_has_is_restored();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* virtual_url_;
  ::std::string* referrer_;
  ::std::string* title_;
  ::std::string* state_;
  int page_transition_;
  int redirect_type_;
  ::google::protobuf::int64 timestamp_msec_;
  ::google::protobuf::int32 unique_id_;
  bool navigation_forward_back_;
  bool navigation_from_address_bar_;
  bool navigation_home_page_;
  bool navigation_chain_start_;
  ::google::protobuf::int64 global_id_;
  ::std::string* search_terms_;
  ::std::string* favicon_url_;
  int blocked_state_;
  bool navigation_chain_end_;
  bool is_restored_;
  ::google::protobuf::RepeatedPtrField< ::std::string> content_pack_categories_;
  ::google::protobuf::int32 http_status_code_;
  ::google::protobuf::int32 referrer_policy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_session_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_session_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_session_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static TabNavigation* default_instance_;
};
// ===================================================================


// ===================================================================

// SessionSpecifics

// optional string session_tag = 1;
inline bool SessionSpecifics::has_session_tag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionSpecifics::set_has_session_tag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionSpecifics::clear_has_session_tag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionSpecifics::clear_session_tag() {
  if (session_tag_ != &::google::protobuf::internal::GetEmptyString()) {
    session_tag_->clear();
  }
  clear_has_session_tag();
}
inline const ::std::string& SessionSpecifics::session_tag() const {
  return *session_tag_;
}
inline void SessionSpecifics::set_session_tag(const ::std::string& value) {
  set_has_session_tag();
  if (session_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    session_tag_ = new ::std::string;
  }
  session_tag_->assign(value);
}
inline void SessionSpecifics::set_session_tag(const char* value) {
  set_has_session_tag();
  if (session_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    session_tag_ = new ::std::string;
  }
  session_tag_->assign(value);
}
inline void SessionSpecifics::set_session_tag(const char* value, size_t size) {
  set_has_session_tag();
  if (session_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    session_tag_ = new ::std::string;
  }
  session_tag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionSpecifics::mutable_session_tag() {
  set_has_session_tag();
  if (session_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    session_tag_ = new ::std::string;
  }
  return session_tag_;
}
inline ::std::string* SessionSpecifics::release_session_tag() {
  clear_has_session_tag();
  if (session_tag_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = session_tag_;
    session_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SessionSpecifics::set_allocated_session_tag(::std::string* session_tag) {
  if (session_tag_ != &::google::protobuf::internal::GetEmptyString()) {
    delete session_tag_;
  }
  if (session_tag) {
    set_has_session_tag();
    session_tag_ = session_tag;
  } else {
    clear_has_session_tag();
    session_tag_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.SessionHeader header = 2;
inline bool SessionSpecifics::has_header() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionSpecifics::set_has_header() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionSpecifics::clear_has_header() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionSpecifics::clear_header() {
  if (header_ != NULL) header_->::sync_pb::SessionHeader::Clear();
  clear_has_header();
}
inline const ::sync_pb::SessionHeader& SessionSpecifics::header() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return header_ != NULL ? *header_ : *default_instance().header_;
#else
  return header_ != NULL ? *header_ : *default_instance_->header_;
#endif
}
inline ::sync_pb::SessionHeader* SessionSpecifics::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::sync_pb::SessionHeader;
  return header_;
}
inline ::sync_pb::SessionHeader* SessionSpecifics::release_header() {
  clear_has_header();
  ::sync_pb::SessionHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void SessionSpecifics::set_allocated_header(::sync_pb::SessionHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
}

// optional .sync_pb.SessionTab tab = 3;
inline bool SessionSpecifics::has_tab() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionSpecifics::set_has_tab() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionSpecifics::clear_has_tab() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionSpecifics::clear_tab() {
  if (tab_ != NULL) tab_->::sync_pb::SessionTab::Clear();
  clear_has_tab();
}
inline const ::sync_pb::SessionTab& SessionSpecifics::tab() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tab_ != NULL ? *tab_ : *default_instance().tab_;
#else
  return tab_ != NULL ? *tab_ : *default_instance_->tab_;
#endif
}
inline ::sync_pb::SessionTab* SessionSpecifics::mutable_tab() {
  set_has_tab();
  if (tab_ == NULL) tab_ = new ::sync_pb::SessionTab;
  return tab_;
}
inline ::sync_pb::SessionTab* SessionSpecifics::release_tab() {
  clear_has_tab();
  ::sync_pb::SessionTab* temp = tab_;
  tab_ = NULL;
  return temp;
}
inline void SessionSpecifics::set_allocated_tab(::sync_pb::SessionTab* tab) {
  delete tab_;
  tab_ = tab;
  if (tab) {
    set_has_tab();
  } else {
    clear_has_tab();
  }
}

// optional int32 tab_node_id = 4 [default = -1];
inline bool SessionSpecifics::has_tab_node_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionSpecifics::set_has_tab_node_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionSpecifics::clear_has_tab_node_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionSpecifics::clear_tab_node_id() {
  tab_node_id_ = -1;
  clear_has_tab_node_id();
}
inline ::google::protobuf::int32 SessionSpecifics::tab_node_id() const {
  return tab_node_id_;
}
inline void SessionSpecifics::set_tab_node_id(::google::protobuf::int32 value) {
  set_has_tab_node_id();
  tab_node_id_ = value;
}

// -------------------------------------------------------------------

// SessionHeader

// repeated .sync_pb.SessionWindow window = 2;
inline int SessionHeader::window_size() const {
  return window_.size();
}
inline void SessionHeader::clear_window() {
  window_.Clear();
}
inline const ::sync_pb::SessionWindow& SessionHeader::window(int index) const {
  return window_.Get(index);
}
inline ::sync_pb::SessionWindow* SessionHeader::mutable_window(int index) {
  return window_.Mutable(index);
}
inline ::sync_pb::SessionWindow* SessionHeader::add_window() {
  return window_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SessionWindow >&
SessionHeader::window() const {
  return window_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SessionWindow >*
SessionHeader::mutable_window() {
  return &window_;
}

// optional string client_name = 3;
inline bool SessionHeader::has_client_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionHeader::set_has_client_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionHeader::clear_has_client_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionHeader::clear_client_name() {
  if (client_name_ != &::google::protobuf::internal::GetEmptyString()) {
    client_name_->clear();
  }
  clear_has_client_name();
}
inline const ::std::string& SessionHeader::client_name() const {
  return *client_name_;
}
inline void SessionHeader::set_client_name(const ::std::string& value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyString()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
}
inline void SessionHeader::set_client_name(const char* value) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyString()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(value);
}
inline void SessionHeader::set_client_name(const char* value, size_t size) {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyString()) {
    client_name_ = new ::std::string;
  }
  client_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionHeader::mutable_client_name() {
  set_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyString()) {
    client_name_ = new ::std::string;
  }
  return client_name_;
}
inline ::std::string* SessionHeader::release_client_name() {
  clear_has_client_name();
  if (client_name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = client_name_;
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SessionHeader::set_allocated_client_name(::std::string* client_name) {
  if (client_name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete client_name_;
  }
  if (client_name) {
    set_has_client_name();
    client_name_ = client_name;
  } else {
    clear_has_client_name();
    client_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.SyncEnums.DeviceType device_type = 4;
inline bool SessionHeader::has_device_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionHeader::set_has_device_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionHeader::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionHeader::clear_device_type() {
  device_type_ = 1;
  clear_has_device_type();
}
inline ::sync_pb::SyncEnums_DeviceType SessionHeader::device_type() const {
  return static_cast< ::sync_pb::SyncEnums_DeviceType >(device_type_);
}
inline void SessionHeader::set_device_type(::sync_pb::SyncEnums_DeviceType value) {
  assert(::sync_pb::SyncEnums_DeviceType_IsValid(value));
  set_has_device_type();
  device_type_ = value;
}

// -------------------------------------------------------------------

// SessionWindow

// optional int32 window_id = 1;
inline bool SessionWindow::has_window_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionWindow::set_has_window_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionWindow::clear_has_window_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionWindow::clear_window_id() {
  window_id_ = 0;
  clear_has_window_id();
}
inline ::google::protobuf::int32 SessionWindow::window_id() const {
  return window_id_;
}
inline void SessionWindow::set_window_id(::google::protobuf::int32 value) {
  set_has_window_id();
  window_id_ = value;
}

// optional int32 selected_tab_index = 2 [default = -1];
inline bool SessionWindow::has_selected_tab_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionWindow::set_has_selected_tab_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionWindow::clear_has_selected_tab_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionWindow::clear_selected_tab_index() {
  selected_tab_index_ = -1;
  clear_has_selected_tab_index();
}
inline ::google::protobuf::int32 SessionWindow::selected_tab_index() const {
  return selected_tab_index_;
}
inline void SessionWindow::set_selected_tab_index(::google::protobuf::int32 value) {
  set_has_selected_tab_index();
  selected_tab_index_ = value;
}

// optional .sync_pb.SessionWindow.BrowserType browser_type = 3 [default = TYPE_TABBED];
inline bool SessionWindow::has_browser_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionWindow::set_has_browser_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionWindow::clear_has_browser_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionWindow::clear_browser_type() {
  browser_type_ = 1;
  clear_has_browser_type();
}
inline ::sync_pb::SessionWindow_BrowserType SessionWindow::browser_type() const {
  return static_cast< ::sync_pb::SessionWindow_BrowserType >(browser_type_);
}
inline void SessionWindow::set_browser_type(::sync_pb::SessionWindow_BrowserType value) {
  assert(::sync_pb::SessionWindow_BrowserType_IsValid(value));
  set_has_browser_type();
  browser_type_ = value;
}

// repeated int32 tab = 4;
inline int SessionWindow::tab_size() const {
  return tab_.size();
}
inline void SessionWindow::clear_tab() {
  tab_.Clear();
}
inline ::google::protobuf::int32 SessionWindow::tab(int index) const {
  return tab_.Get(index);
}
inline void SessionWindow::set_tab(int index, ::google::protobuf::int32 value) {
  tab_.Set(index, value);
}
inline void SessionWindow::add_tab(::google::protobuf::int32 value) {
  tab_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
SessionWindow::tab() const {
  return tab_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
SessionWindow::mutable_tab() {
  return &tab_;
}

// -------------------------------------------------------------------

// SessionTab

// optional int32 tab_id = 1;
inline bool SessionTab::has_tab_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionTab::set_has_tab_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionTab::clear_has_tab_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionTab::clear_tab_id() {
  tab_id_ = 0;
  clear_has_tab_id();
}
inline ::google::protobuf::int32 SessionTab::tab_id() const {
  return tab_id_;
}
inline void SessionTab::set_tab_id(::google::protobuf::int32 value) {
  set_has_tab_id();
  tab_id_ = value;
}

// optional int32 window_id = 2;
inline bool SessionTab::has_window_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SessionTab::set_has_window_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SessionTab::clear_has_window_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SessionTab::clear_window_id() {
  window_id_ = 0;
  clear_has_window_id();
}
inline ::google::protobuf::int32 SessionTab::window_id() const {
  return window_id_;
}
inline void SessionTab::set_window_id(::google::protobuf::int32 value) {
  set_has_window_id();
  window_id_ = value;
}

// optional int32 tab_visual_index = 3 [default = -1];
inline bool SessionTab::has_tab_visual_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SessionTab::set_has_tab_visual_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SessionTab::clear_has_tab_visual_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SessionTab::clear_tab_visual_index() {
  tab_visual_index_ = -1;
  clear_has_tab_visual_index();
}
inline ::google::protobuf::int32 SessionTab::tab_visual_index() const {
  return tab_visual_index_;
}
inline void SessionTab::set_tab_visual_index(::google::protobuf::int32 value) {
  set_has_tab_visual_index();
  tab_visual_index_ = value;
}

// optional int32 current_navigation_index = 4 [default = -1];
inline bool SessionTab::has_current_navigation_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SessionTab::set_has_current_navigation_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SessionTab::clear_has_current_navigation_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SessionTab::clear_current_navigation_index() {
  current_navigation_index_ = -1;
  clear_has_current_navigation_index();
}
inline ::google::protobuf::int32 SessionTab::current_navigation_index() const {
  return current_navigation_index_;
}
inline void SessionTab::set_current_navigation_index(::google::protobuf::int32 value) {
  set_has_current_navigation_index();
  current_navigation_index_ = value;
}

// optional bool pinned = 5 [default = false];
inline bool SessionTab::has_pinned() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SessionTab::set_has_pinned() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SessionTab::clear_has_pinned() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SessionTab::clear_pinned() {
  pinned_ = false;
  clear_has_pinned();
}
inline bool SessionTab::pinned() const {
  return pinned_;
}
inline void SessionTab::set_pinned(bool value) {
  set_has_pinned();
  pinned_ = value;
}

// optional string extension_app_id = 6;
inline bool SessionTab::has_extension_app_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SessionTab::set_has_extension_app_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SessionTab::clear_has_extension_app_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SessionTab::clear_extension_app_id() {
  if (extension_app_id_ != &::google::protobuf::internal::GetEmptyString()) {
    extension_app_id_->clear();
  }
  clear_has_extension_app_id();
}
inline const ::std::string& SessionTab::extension_app_id() const {
  return *extension_app_id_;
}
inline void SessionTab::set_extension_app_id(const ::std::string& value) {
  set_has_extension_app_id();
  if (extension_app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_app_id_ = new ::std::string;
  }
  extension_app_id_->assign(value);
}
inline void SessionTab::set_extension_app_id(const char* value) {
  set_has_extension_app_id();
  if (extension_app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_app_id_ = new ::std::string;
  }
  extension_app_id_->assign(value);
}
inline void SessionTab::set_extension_app_id(const char* value, size_t size) {
  set_has_extension_app_id();
  if (extension_app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_app_id_ = new ::std::string;
  }
  extension_app_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionTab::mutable_extension_app_id() {
  set_has_extension_app_id();
  if (extension_app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_app_id_ = new ::std::string;
  }
  return extension_app_id_;
}
inline ::std::string* SessionTab::release_extension_app_id() {
  clear_has_extension_app_id();
  if (extension_app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = extension_app_id_;
    extension_app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SessionTab::set_allocated_extension_app_id(::std::string* extension_app_id) {
  if (extension_app_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete extension_app_id_;
  }
  if (extension_app_id) {
    set_has_extension_app_id();
    extension_app_id_ = extension_app_id;
  } else {
    clear_has_extension_app_id();
    extension_app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .sync_pb.TabNavigation navigation = 7;
inline int SessionTab::navigation_size() const {
  return navigation_.size();
}
inline void SessionTab::clear_navigation() {
  navigation_.Clear();
}
inline const ::sync_pb::TabNavigation& SessionTab::navigation(int index) const {
  return navigation_.Get(index);
}
inline ::sync_pb::TabNavigation* SessionTab::mutable_navigation(int index) {
  return navigation_.Mutable(index);
}
inline ::sync_pb::TabNavigation* SessionTab::add_navigation() {
  return navigation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::TabNavigation >&
SessionTab::navigation() const {
  return navigation_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::TabNavigation >*
SessionTab::mutable_navigation() {
  return &navigation_;
}

// optional bytes favicon = 8;
inline bool SessionTab::has_favicon() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SessionTab::set_has_favicon() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SessionTab::clear_has_favicon() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SessionTab::clear_favicon() {
  if (favicon_ != &::google::protobuf::internal::GetEmptyString()) {
    favicon_->clear();
  }
  clear_has_favicon();
}
inline const ::std::string& SessionTab::favicon() const {
  return *favicon_;
}
inline void SessionTab::set_favicon(const ::std::string& value) {
  set_has_favicon();
  if (favicon_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_ = new ::std::string;
  }
  favicon_->assign(value);
}
inline void SessionTab::set_favicon(const char* value) {
  set_has_favicon();
  if (favicon_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_ = new ::std::string;
  }
  favicon_->assign(value);
}
inline void SessionTab::set_favicon(const void* value, size_t size) {
  set_has_favicon();
  if (favicon_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_ = new ::std::string;
  }
  favicon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionTab::mutable_favicon() {
  set_has_favicon();
  if (favicon_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_ = new ::std::string;
  }
  return favicon_;
}
inline ::std::string* SessionTab::release_favicon() {
  clear_has_favicon();
  if (favicon_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = favicon_;
    favicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SessionTab::set_allocated_favicon(::std::string* favicon) {
  if (favicon_ != &::google::protobuf::internal::GetEmptyString()) {
    delete favicon_;
  }
  if (favicon) {
    set_has_favicon();
    favicon_ = favicon;
  } else {
    clear_has_favicon();
    favicon_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.SessionTab.FaviconType favicon_type = 9;
inline bool SessionTab::has_favicon_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SessionTab::set_has_favicon_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SessionTab::clear_has_favicon_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SessionTab::clear_favicon_type() {
  favicon_type_ = 1;
  clear_has_favicon_type();
}
inline ::sync_pb::SessionTab_FaviconType SessionTab::favicon_type() const {
  return static_cast< ::sync_pb::SessionTab_FaviconType >(favicon_type_);
}
inline void SessionTab::set_favicon_type(::sync_pb::SessionTab_FaviconType value) {
  assert(::sync_pb::SessionTab_FaviconType_IsValid(value));
  set_has_favicon_type();
  favicon_type_ = value;
}

// optional string favicon_source = 11;
inline bool SessionTab::has_favicon_source() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SessionTab::set_has_favicon_source() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SessionTab::clear_has_favicon_source() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SessionTab::clear_favicon_source() {
  if (favicon_source_ != &::google::protobuf::internal::GetEmptyString()) {
    favicon_source_->clear();
  }
  clear_has_favicon_source();
}
inline const ::std::string& SessionTab::favicon_source() const {
  return *favicon_source_;
}
inline void SessionTab::set_favicon_source(const ::std::string& value) {
  set_has_favicon_source();
  if (favicon_source_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_source_ = new ::std::string;
  }
  favicon_source_->assign(value);
}
inline void SessionTab::set_favicon_source(const char* value) {
  set_has_favicon_source();
  if (favicon_source_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_source_ = new ::std::string;
  }
  favicon_source_->assign(value);
}
inline void SessionTab::set_favicon_source(const char* value, size_t size) {
  set_has_favicon_source();
  if (favicon_source_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_source_ = new ::std::string;
  }
  favicon_source_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionTab::mutable_favicon_source() {
  set_has_favicon_source();
  if (favicon_source_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_source_ = new ::std::string;
  }
  return favicon_source_;
}
inline ::std::string* SessionTab::release_favicon_source() {
  clear_has_favicon_source();
  if (favicon_source_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = favicon_source_;
    favicon_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SessionTab::set_allocated_favicon_source(::std::string* favicon_source) {
  if (favicon_source_ != &::google::protobuf::internal::GetEmptyString()) {
    delete favicon_source_;
  }
  if (favicon_source) {
    set_has_favicon_source();
    favicon_source_ = favicon_source;
  } else {
    clear_has_favicon_source();
    favicon_source_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// TabNavigation

// optional string virtual_url = 2;
inline bool TabNavigation::has_virtual_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TabNavigation::set_has_virtual_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TabNavigation::clear_has_virtual_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TabNavigation::clear_virtual_url() {
  if (virtual_url_ != &::google::protobuf::internal::GetEmptyString()) {
    virtual_url_->clear();
  }
  clear_has_virtual_url();
}
inline const ::std::string& TabNavigation::virtual_url() const {
  return *virtual_url_;
}
inline void TabNavigation::set_virtual_url(const ::std::string& value) {
  set_has_virtual_url();
  if (virtual_url_ == &::google::protobuf::internal::GetEmptyString()) {
    virtual_url_ = new ::std::string;
  }
  virtual_url_->assign(value);
}
inline void TabNavigation::set_virtual_url(const char* value) {
  set_has_virtual_url();
  if (virtual_url_ == &::google::protobuf::internal::GetEmptyString()) {
    virtual_url_ = new ::std::string;
  }
  virtual_url_->assign(value);
}
inline void TabNavigation::set_virtual_url(const char* value, size_t size) {
  set_has_virtual_url();
  if (virtual_url_ == &::google::protobuf::internal::GetEmptyString()) {
    virtual_url_ = new ::std::string;
  }
  virtual_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TabNavigation::mutable_virtual_url() {
  set_has_virtual_url();
  if (virtual_url_ == &::google::protobuf::internal::GetEmptyString()) {
    virtual_url_ = new ::std::string;
  }
  return virtual_url_;
}
inline ::std::string* TabNavigation::release_virtual_url() {
  clear_has_virtual_url();
  if (virtual_url_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = virtual_url_;
    virtual_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TabNavigation::set_allocated_virtual_url(::std::string* virtual_url) {
  if (virtual_url_ != &::google::protobuf::internal::GetEmptyString()) {
    delete virtual_url_;
  }
  if (virtual_url) {
    set_has_virtual_url();
    virtual_url_ = virtual_url;
  } else {
    clear_has_virtual_url();
    virtual_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string referrer = 3;
inline bool TabNavigation::has_referrer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TabNavigation::set_has_referrer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TabNavigation::clear_has_referrer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TabNavigation::clear_referrer() {
  if (referrer_ != &::google::protobuf::internal::GetEmptyString()) {
    referrer_->clear();
  }
  clear_has_referrer();
}
inline const ::std::string& TabNavigation::referrer() const {
  return *referrer_;
}
inline void TabNavigation::set_referrer(const ::std::string& value) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::GetEmptyString()) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(value);
}
inline void TabNavigation::set_referrer(const char* value) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::GetEmptyString()) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(value);
}
inline void TabNavigation::set_referrer(const char* value, size_t size) {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::GetEmptyString()) {
    referrer_ = new ::std::string;
  }
  referrer_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TabNavigation::mutable_referrer() {
  set_has_referrer();
  if (referrer_ == &::google::protobuf::internal::GetEmptyString()) {
    referrer_ = new ::std::string;
  }
  return referrer_;
}
inline ::std::string* TabNavigation::release_referrer() {
  clear_has_referrer();
  if (referrer_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = referrer_;
    referrer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TabNavigation::set_allocated_referrer(::std::string* referrer) {
  if (referrer_ != &::google::protobuf::internal::GetEmptyString()) {
    delete referrer_;
  }
  if (referrer) {
    set_has_referrer();
    referrer_ = referrer;
  } else {
    clear_has_referrer();
    referrer_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string title = 4;
inline bool TabNavigation::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TabNavigation::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TabNavigation::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TabNavigation::clear_title() {
  if (title_ != &::google::protobuf::internal::GetEmptyString()) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& TabNavigation::title() const {
  return *title_;
}
inline void TabNavigation::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void TabNavigation::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void TabNavigation::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TabNavigation::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* TabNavigation::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TabNavigation::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::GetEmptyString()) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string state = 5;
inline bool TabNavigation::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TabNavigation::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TabNavigation::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TabNavigation::clear_state() {
  if (state_ != &::google::protobuf::internal::GetEmptyString()) {
    state_->clear();
  }
  clear_has_state();
}
inline const ::std::string& TabNavigation::state() const {
  return *state_;
}
inline void TabNavigation::set_state(const ::std::string& value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyString()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void TabNavigation::set_state(const char* value) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyString()) {
    state_ = new ::std::string;
  }
  state_->assign(value);
}
inline void TabNavigation::set_state(const char* value, size_t size) {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyString()) {
    state_ = new ::std::string;
  }
  state_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TabNavigation::mutable_state() {
  set_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyString()) {
    state_ = new ::std::string;
  }
  return state_;
}
inline ::std::string* TabNavigation::release_state() {
  clear_has_state();
  if (state_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = state_;
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TabNavigation::set_allocated_state(::std::string* state) {
  if (state_ != &::google::protobuf::internal::GetEmptyString()) {
    delete state_;
  }
  if (state) {
    set_has_state();
    state_ = state;
  } else {
    clear_has_state();
    state_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.SyncEnums.PageTransition page_transition = 6 [default = TYPED];
inline bool TabNavigation::has_page_transition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TabNavigation::set_has_page_transition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TabNavigation::clear_has_page_transition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TabNavigation::clear_page_transition() {
  page_transition_ = 1;
  clear_has_page_transition();
}
inline ::sync_pb::SyncEnums_PageTransition TabNavigation::page_transition() const {
  return static_cast< ::sync_pb::SyncEnums_PageTransition >(page_transition_);
}
inline void TabNavigation::set_page_transition(::sync_pb::SyncEnums_PageTransition value) {
  assert(::sync_pb::SyncEnums_PageTransition_IsValid(value));
  set_has_page_transition();
  page_transition_ = value;
}

// optional .sync_pb.SyncEnums.PageTransitionRedirectType redirect_type = 7;
inline bool TabNavigation::has_redirect_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TabNavigation::set_has_redirect_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TabNavigation::clear_has_redirect_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TabNavigation::clear_redirect_type() {
  redirect_type_ = 1;
  clear_has_redirect_type();
}
inline ::sync_pb::SyncEnums_PageTransitionRedirectType TabNavigation::redirect_type() const {
  return static_cast< ::sync_pb::SyncEnums_PageTransitionRedirectType >(redirect_type_);
}
inline void TabNavigation::set_redirect_type(::sync_pb::SyncEnums_PageTransitionRedirectType value) {
  assert(::sync_pb::SyncEnums_PageTransitionRedirectType_IsValid(value));
  set_has_redirect_type();
  redirect_type_ = value;
}

// optional int32 unique_id = 8;
inline bool TabNavigation::has_unique_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TabNavigation::set_has_unique_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TabNavigation::clear_has_unique_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TabNavigation::clear_unique_id() {
  unique_id_ = 0;
  clear_has_unique_id();
}
inline ::google::protobuf::int32 TabNavigation::unique_id() const {
  return unique_id_;
}
inline void TabNavigation::set_unique_id(::google::protobuf::int32 value) {
  set_has_unique_id();
  unique_id_ = value;
}

// optional int64 timestamp_msec = 9;
inline bool TabNavigation::has_timestamp_msec() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TabNavigation::set_has_timestamp_msec() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TabNavigation::clear_has_timestamp_msec() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TabNavigation::clear_timestamp_msec() {
  timestamp_msec_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp_msec();
}
inline ::google::protobuf::int64 TabNavigation::timestamp_msec() const {
  return timestamp_msec_;
}
inline void TabNavigation::set_timestamp_msec(::google::protobuf::int64 value) {
  set_has_timestamp_msec();
  timestamp_msec_ = value;
}

// optional bool navigation_forward_back = 10;
inline bool TabNavigation::has_navigation_forward_back() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TabNavigation::set_has_navigation_forward_back() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TabNavigation::clear_has_navigation_forward_back() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TabNavigation::clear_navigation_forward_back() {
  navigation_forward_back_ = false;
  clear_has_navigation_forward_back();
}
inline bool TabNavigation::navigation_forward_back() const {
  return navigation_forward_back_;
}
inline void TabNavigation::set_navigation_forward_back(bool value) {
  set_has_navigation_forward_back();
  navigation_forward_back_ = value;
}

// optional bool navigation_from_address_bar = 11;
inline bool TabNavigation::has_navigation_from_address_bar() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TabNavigation::set_has_navigation_from_address_bar() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TabNavigation::clear_has_navigation_from_address_bar() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TabNavigation::clear_navigation_from_address_bar() {
  navigation_from_address_bar_ = false;
  clear_has_navigation_from_address_bar();
}
inline bool TabNavigation::navigation_from_address_bar() const {
  return navigation_from_address_bar_;
}
inline void TabNavigation::set_navigation_from_address_bar(bool value) {
  set_has_navigation_from_address_bar();
  navigation_from_address_bar_ = value;
}

// optional bool navigation_home_page = 12;
inline bool TabNavigation::has_navigation_home_page() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TabNavigation::set_has_navigation_home_page() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TabNavigation::clear_has_navigation_home_page() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TabNavigation::clear_navigation_home_page() {
  navigation_home_page_ = false;
  clear_has_navigation_home_page();
}
inline bool TabNavigation::navigation_home_page() const {
  return navigation_home_page_;
}
inline void TabNavigation::set_navigation_home_page(bool value) {
  set_has_navigation_home_page();
  navigation_home_page_ = value;
}

// optional bool navigation_chain_start = 13;
inline bool TabNavigation::has_navigation_chain_start() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TabNavigation::set_has_navigation_chain_start() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TabNavigation::clear_has_navigation_chain_start() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TabNavigation::clear_navigation_chain_start() {
  navigation_chain_start_ = false;
  clear_has_navigation_chain_start();
}
inline bool TabNavigation::navigation_chain_start() const {
  return navigation_chain_start_;
}
inline void TabNavigation::set_navigation_chain_start(bool value) {
  set_has_navigation_chain_start();
  navigation_chain_start_ = value;
}

// optional bool navigation_chain_end = 14;
inline bool TabNavigation::has_navigation_chain_end() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TabNavigation::set_has_navigation_chain_end() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TabNavigation::clear_has_navigation_chain_end() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TabNavigation::clear_navigation_chain_end() {
  navigation_chain_end_ = false;
  clear_has_navigation_chain_end();
}
inline bool TabNavigation::navigation_chain_end() const {
  return navigation_chain_end_;
}
inline void TabNavigation::set_navigation_chain_end(bool value) {
  set_has_navigation_chain_end();
  navigation_chain_end_ = value;
}

// optional int64 global_id = 15;
inline bool TabNavigation::has_global_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TabNavigation::set_has_global_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TabNavigation::clear_has_global_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TabNavigation::clear_global_id() {
  global_id_ = GOOGLE_LONGLONG(0);
  clear_has_global_id();
}
inline ::google::protobuf::int64 TabNavigation::global_id() const {
  return global_id_;
}
inline void TabNavigation::set_global_id(::google::protobuf::int64 value) {
  set_has_global_id();
  global_id_ = value;
}

// optional string search_terms = 16;
inline bool TabNavigation::has_search_terms() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TabNavigation::set_has_search_terms() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TabNavigation::clear_has_search_terms() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TabNavigation::clear_search_terms() {
  if (search_terms_ != &::google::protobuf::internal::GetEmptyString()) {
    search_terms_->clear();
  }
  clear_has_search_terms();
}
inline const ::std::string& TabNavigation::search_terms() const {
  return *search_terms_;
}
inline void TabNavigation::set_search_terms(const ::std::string& value) {
  set_has_search_terms();
  if (search_terms_ == &::google::protobuf::internal::GetEmptyString()) {
    search_terms_ = new ::std::string;
  }
  search_terms_->assign(value);
}
inline void TabNavigation::set_search_terms(const char* value) {
  set_has_search_terms();
  if (search_terms_ == &::google::protobuf::internal::GetEmptyString()) {
    search_terms_ = new ::std::string;
  }
  search_terms_->assign(value);
}
inline void TabNavigation::set_search_terms(const char* value, size_t size) {
  set_has_search_terms();
  if (search_terms_ == &::google::protobuf::internal::GetEmptyString()) {
    search_terms_ = new ::std::string;
  }
  search_terms_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TabNavigation::mutable_search_terms() {
  set_has_search_terms();
  if (search_terms_ == &::google::protobuf::internal::GetEmptyString()) {
    search_terms_ = new ::std::string;
  }
  return search_terms_;
}
inline ::std::string* TabNavigation::release_search_terms() {
  clear_has_search_terms();
  if (search_terms_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = search_terms_;
    search_terms_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TabNavigation::set_allocated_search_terms(::std::string* search_terms) {
  if (search_terms_ != &::google::protobuf::internal::GetEmptyString()) {
    delete search_terms_;
  }
  if (search_terms) {
    set_has_search_terms();
    search_terms_ = search_terms;
  } else {
    clear_has_search_terms();
    search_terms_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string favicon_url = 17;
inline bool TabNavigation::has_favicon_url() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TabNavigation::set_has_favicon_url() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TabNavigation::clear_has_favicon_url() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TabNavigation::clear_favicon_url() {
  if (favicon_url_ != &::google::protobuf::internal::GetEmptyString()) {
    favicon_url_->clear();
  }
  clear_has_favicon_url();
}
inline const ::std::string& TabNavigation::favicon_url() const {
  return *favicon_url_;
}
inline void TabNavigation::set_favicon_url(const ::std::string& value) {
  set_has_favicon_url();
  if (favicon_url_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_url_ = new ::std::string;
  }
  favicon_url_->assign(value);
}
inline void TabNavigation::set_favicon_url(const char* value) {
  set_has_favicon_url();
  if (favicon_url_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_url_ = new ::std::string;
  }
  favicon_url_->assign(value);
}
inline void TabNavigation::set_favicon_url(const char* value, size_t size) {
  set_has_favicon_url();
  if (favicon_url_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_url_ = new ::std::string;
  }
  favicon_url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TabNavigation::mutable_favicon_url() {
  set_has_favicon_url();
  if (favicon_url_ == &::google::protobuf::internal::GetEmptyString()) {
    favicon_url_ = new ::std::string;
  }
  return favicon_url_;
}
inline ::std::string* TabNavigation::release_favicon_url() {
  clear_has_favicon_url();
  if (favicon_url_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = favicon_url_;
    favicon_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void TabNavigation::set_allocated_favicon_url(::std::string* favicon_url) {
  if (favicon_url_ != &::google::protobuf::internal::GetEmptyString()) {
    delete favicon_url_;
  }
  if (favicon_url) {
    set_has_favicon_url();
    favicon_url_ = favicon_url;
  } else {
    clear_has_favicon_url();
    favicon_url_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.TabNavigation.BlockedState blocked_state = 18 [default = STATE_ALLOWED];
inline bool TabNavigation::has_blocked_state() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TabNavigation::set_has_blocked_state() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TabNavigation::clear_has_blocked_state() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TabNavigation::clear_blocked_state() {
  blocked_state_ = 1;
  clear_has_blocked_state();
}
inline ::sync_pb::TabNavigation_BlockedState TabNavigation::blocked_state() const {
  return static_cast< ::sync_pb::TabNavigation_BlockedState >(blocked_state_);
}
inline void TabNavigation::set_blocked_state(::sync_pb::TabNavigation_BlockedState value) {
  assert(::sync_pb::TabNavigation_BlockedState_IsValid(value));
  set_has_blocked_state();
  blocked_state_ = value;
}

// repeated string content_pack_categories = 19;
inline int TabNavigation::content_pack_categories_size() const {
  return content_pack_categories_.size();
}
inline void TabNavigation::clear_content_pack_categories() {
  content_pack_categories_.Clear();
}
inline const ::std::string& TabNavigation::content_pack_categories(int index) const {
  return content_pack_categories_.Get(index);
}
inline ::std::string* TabNavigation::mutable_content_pack_categories(int index) {
  return content_pack_categories_.Mutable(index);
}
inline void TabNavigation::set_content_pack_categories(int index, const ::std::string& value) {
  content_pack_categories_.Mutable(index)->assign(value);
}
inline void TabNavigation::set_content_pack_categories(int index, const char* value) {
  content_pack_categories_.Mutable(index)->assign(value);
}
inline void TabNavigation::set_content_pack_categories(int index, const char* value, size_t size) {
  content_pack_categories_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TabNavigation::add_content_pack_categories() {
  return content_pack_categories_.Add();
}
inline void TabNavigation::add_content_pack_categories(const ::std::string& value) {
  content_pack_categories_.Add()->assign(value);
}
inline void TabNavigation::add_content_pack_categories(const char* value) {
  content_pack_categories_.Add()->assign(value);
}
inline void TabNavigation::add_content_pack_categories(const char* value, size_t size) {
  content_pack_categories_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TabNavigation::content_pack_categories() const {
  return content_pack_categories_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TabNavigation::mutable_content_pack_categories() {
  return &content_pack_categories_;
}

// optional int32 http_status_code = 20;
inline bool TabNavigation::has_http_status_code() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void TabNavigation::set_has_http_status_code() {
  _has_bits_[0] |= 0x00040000u;
}
inline void TabNavigation::clear_has_http_status_code() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void TabNavigation::clear_http_status_code() {
  http_status_code_ = 0;
  clear_has_http_status_code();
}
inline ::google::protobuf::int32 TabNavigation::http_status_code() const {
  return http_status_code_;
}
inline void TabNavigation::set_http_status_code(::google::protobuf::int32 value) {
  set_has_http_status_code();
  http_status_code_ = value;
}

// optional int32 referrer_policy = 21 [default = 1];
inline bool TabNavigation::has_referrer_policy() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void TabNavigation::set_has_referrer_policy() {
  _has_bits_[0] |= 0x00080000u;
}
inline void TabNavigation::clear_has_referrer_policy() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void TabNavigation::clear_referrer_policy() {
  referrer_policy_ = 1;
  clear_has_referrer_policy();
}
inline ::google::protobuf::int32 TabNavigation::referrer_policy() const {
  return referrer_policy_;
}
inline void TabNavigation::set_referrer_policy(::google::protobuf::int32 value) {
  set_has_referrer_policy();
  referrer_policy_ = value;
}

// optional bool is_restored = 22;
inline bool TabNavigation::has_is_restored() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void TabNavigation::set_has_is_restored() {
  _has_bits_[0] |= 0x00100000u;
}
inline void TabNavigation::clear_has_is_restored() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void TabNavigation::clear_is_restored() {
  is_restored_ = false;
  clear_has_is_restored();
}
inline bool TabNavigation::is_restored() const {
  return is_restored_;
}
inline void TabNavigation::set_is_restored(bool value) {
  set_has_is_restored();
  is_restored_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sync_pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_session_5fspecifics_2eproto__INCLUDED
