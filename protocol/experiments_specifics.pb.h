// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: experiments_specifics.proto

#ifndef PROTOBUF_experiments_5fspecifics_2eproto__INCLUDED
#define PROTOBUF_experiments_5fspecifics_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include "sync/base/sync_export.h"

namespace sync_pb {

// Internal implementation detail -- do not call these.
void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto();
void protobuf_AssignDesc_experiments_5fspecifics_2eproto();
void protobuf_ShutdownFile_experiments_5fspecifics_2eproto();

class KeystoreEncryptionFlags;
class HistoryDeleteDirectives;
class AutofillCullingFlags;
class FaviconSyncFlags;
class PreCommitUpdateAvoidanceFlags;
class GcmChannelFlags;
class EnhancedBookmarksFlags;
class GcmInvalidationsFlags;
class ExperimentsSpecifics;

// ===================================================================

class SYNC_EXPORT KeystoreEncryptionFlags : public ::google::protobuf::MessageLite {
 public:
  KeystoreEncryptionFlags();
  virtual ~KeystoreEncryptionFlags();

  KeystoreEncryptionFlags(const KeystoreEncryptionFlags& from);

  inline KeystoreEncryptionFlags& operator=(const KeystoreEncryptionFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const KeystoreEncryptionFlags& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const KeystoreEncryptionFlags* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(KeystoreEncryptionFlags* other);

  // implements Message ----------------------------------------------

  KeystoreEncryptionFlags* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const KeystoreEncryptionFlags& from);
  void MergeFrom(const KeystoreEncryptionFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.KeystoreEncryptionFlags)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_experiments_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_experiments_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static KeystoreEncryptionFlags* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT HistoryDeleteDirectives : public ::google::protobuf::MessageLite {
 public:
  HistoryDeleteDirectives();
  virtual ~HistoryDeleteDirectives();

  HistoryDeleteDirectives(const HistoryDeleteDirectives& from);

  inline HistoryDeleteDirectives& operator=(const HistoryDeleteDirectives& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const HistoryDeleteDirectives& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const HistoryDeleteDirectives* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(HistoryDeleteDirectives* other);

  // implements Message ----------------------------------------------

  HistoryDeleteDirectives* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const HistoryDeleteDirectives& from);
  void MergeFrom(const HistoryDeleteDirectives& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.HistoryDeleteDirectives)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_experiments_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_experiments_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static HistoryDeleteDirectives* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT AutofillCullingFlags : public ::google::protobuf::MessageLite {
 public:
  AutofillCullingFlags();
  virtual ~AutofillCullingFlags();

  AutofillCullingFlags(const AutofillCullingFlags& from);

  inline AutofillCullingFlags& operator=(const AutofillCullingFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const AutofillCullingFlags& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AutofillCullingFlags* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AutofillCullingFlags* other);

  // implements Message ----------------------------------------------

  AutofillCullingFlags* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AutofillCullingFlags& from);
  void MergeFrom(const AutofillCullingFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.AutofillCullingFlags)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_experiments_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_experiments_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static AutofillCullingFlags* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT FaviconSyncFlags : public ::google::protobuf::MessageLite {
 public:
  FaviconSyncFlags();
  virtual ~FaviconSyncFlags();

  FaviconSyncFlags(const FaviconSyncFlags& from);

  inline FaviconSyncFlags& operator=(const FaviconSyncFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const FaviconSyncFlags& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FaviconSyncFlags* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FaviconSyncFlags* other);

  // implements Message ----------------------------------------------

  FaviconSyncFlags* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FaviconSyncFlags& from);
  void MergeFrom(const FaviconSyncFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional int32 favicon_sync_limit = 2 [default = 200];
  inline bool has_favicon_sync_limit() const;
  inline void clear_favicon_sync_limit();
  static const int kFaviconSyncLimitFieldNumber = 2;
  inline ::google::protobuf::int32 favicon_sync_limit() const;
  inline void set_favicon_sync_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sync_pb.FaviconSyncFlags)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_favicon_sync_limit();
  inline void clear_has_favicon_sync_limit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enabled_;
  ::google::protobuf::int32 favicon_sync_limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_experiments_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_experiments_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static FaviconSyncFlags* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT PreCommitUpdateAvoidanceFlags : public ::google::protobuf::MessageLite {
 public:
  PreCommitUpdateAvoidanceFlags();
  virtual ~PreCommitUpdateAvoidanceFlags();

  PreCommitUpdateAvoidanceFlags(const PreCommitUpdateAvoidanceFlags& from);

  inline PreCommitUpdateAvoidanceFlags& operator=(const PreCommitUpdateAvoidanceFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const PreCommitUpdateAvoidanceFlags& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PreCommitUpdateAvoidanceFlags* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PreCommitUpdateAvoidanceFlags* other);

  // implements Message ----------------------------------------------

  PreCommitUpdateAvoidanceFlags* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PreCommitUpdateAvoidanceFlags& from);
  void MergeFrom(const PreCommitUpdateAvoidanceFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.PreCommitUpdateAvoidanceFlags)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_experiments_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_experiments_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static PreCommitUpdateAvoidanceFlags* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT GcmChannelFlags : public ::google::protobuf::MessageLite {
 public:
  GcmChannelFlags();
  virtual ~GcmChannelFlags();

  GcmChannelFlags(const GcmChannelFlags& from);

  inline GcmChannelFlags& operator=(const GcmChannelFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GcmChannelFlags& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GcmChannelFlags* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GcmChannelFlags* other);

  // implements Message ----------------------------------------------

  GcmChannelFlags* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GcmChannelFlags& from);
  void MergeFrom(const GcmChannelFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.GcmChannelFlags)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_experiments_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_experiments_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static GcmChannelFlags* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT EnhancedBookmarksFlags : public ::google::protobuf::MessageLite {
 public:
  EnhancedBookmarksFlags();
  virtual ~EnhancedBookmarksFlags();

  EnhancedBookmarksFlags(const EnhancedBookmarksFlags& from);

  inline EnhancedBookmarksFlags& operator=(const EnhancedBookmarksFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const EnhancedBookmarksFlags& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const EnhancedBookmarksFlags* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(EnhancedBookmarksFlags* other);

  // implements Message ----------------------------------------------

  EnhancedBookmarksFlags* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const EnhancedBookmarksFlags& from);
  void MergeFrom(const EnhancedBookmarksFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional string extension_id = 2;
  inline bool has_extension_id() const;
  inline void clear_extension_id();
  static const int kExtensionIdFieldNumber = 2;
  inline const ::std::string& extension_id() const;
  inline void set_extension_id(const ::std::string& value);
  inline void set_extension_id(const char* value);
  inline void set_extension_id(const char* value, size_t size);
  inline ::std::string* mutable_extension_id();
  inline ::std::string* release_extension_id();
  inline void set_allocated_extension_id(::std::string* extension_id);

  // @@protoc_insertion_point(class_scope:sync_pb.EnhancedBookmarksFlags)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_extension_id();
  inline void clear_has_extension_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* extension_id_;
  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_experiments_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_experiments_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static EnhancedBookmarksFlags* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT GcmInvalidationsFlags : public ::google::protobuf::MessageLite {
 public:
  GcmInvalidationsFlags();
  virtual ~GcmInvalidationsFlags();

  GcmInvalidationsFlags(const GcmInvalidationsFlags& from);

  inline GcmInvalidationsFlags& operator=(const GcmInvalidationsFlags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const GcmInvalidationsFlags& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GcmInvalidationsFlags* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GcmInvalidationsFlags* other);

  // implements Message ----------------------------------------------

  GcmInvalidationsFlags* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GcmInvalidationsFlags& from);
  void MergeFrom(const GcmInvalidationsFlags& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool enabled = 1;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 1;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.GcmInvalidationsFlags)
 private:
  inline void set_has_enabled();
  inline void clear_has_enabled();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool enabled_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_experiments_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_experiments_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static GcmInvalidationsFlags* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ExperimentsSpecifics : public ::google::protobuf::MessageLite {
 public:
  ExperimentsSpecifics();
  virtual ~ExperimentsSpecifics();

  ExperimentsSpecifics(const ExperimentsSpecifics& from);

  inline ExperimentsSpecifics& operator=(const ExperimentsSpecifics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ExperimentsSpecifics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ExperimentsSpecifics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ExperimentsSpecifics* other);

  // implements Message ----------------------------------------------

  ExperimentsSpecifics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ExperimentsSpecifics& from);
  void MergeFrom(const ExperimentsSpecifics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .sync_pb.KeystoreEncryptionFlags keystore_encryption = 1;
  inline bool has_keystore_encryption() const;
  inline void clear_keystore_encryption();
  static const int kKeystoreEncryptionFieldNumber = 1;
  inline const ::sync_pb::KeystoreEncryptionFlags& keystore_encryption() const;
  inline ::sync_pb::KeystoreEncryptionFlags* mutable_keystore_encryption();
  inline ::sync_pb::KeystoreEncryptionFlags* release_keystore_encryption();
  inline void set_allocated_keystore_encryption(::sync_pb::KeystoreEncryptionFlags* keystore_encryption);

  // optional .sync_pb.HistoryDeleteDirectives history_delete_directives = 2;
  inline bool has_history_delete_directives() const;
  inline void clear_history_delete_directives();
  static const int kHistoryDeleteDirectivesFieldNumber = 2;
  inline const ::sync_pb::HistoryDeleteDirectives& history_delete_directives() const;
  inline ::sync_pb::HistoryDeleteDirectives* mutable_history_delete_directives();
  inline ::sync_pb::HistoryDeleteDirectives* release_history_delete_directives();
  inline void set_allocated_history_delete_directives(::sync_pb::HistoryDeleteDirectives* history_delete_directives);

  // optional .sync_pb.AutofillCullingFlags autofill_culling = 3;
  inline bool has_autofill_culling() const;
  inline void clear_autofill_culling();
  static const int kAutofillCullingFieldNumber = 3;
  inline const ::sync_pb::AutofillCullingFlags& autofill_culling() const;
  inline ::sync_pb::AutofillCullingFlags* mutable_autofill_culling();
  inline ::sync_pb::AutofillCullingFlags* release_autofill_culling();
  inline void set_allocated_autofill_culling(::sync_pb::AutofillCullingFlags* autofill_culling);

  // optional .sync_pb.FaviconSyncFlags favicon_sync = 4;
  inline bool has_favicon_sync() const;
  inline void clear_favicon_sync();
  static const int kFaviconSyncFieldNumber = 4;
  inline const ::sync_pb::FaviconSyncFlags& favicon_sync() const;
  inline ::sync_pb::FaviconSyncFlags* mutable_favicon_sync();
  inline ::sync_pb::FaviconSyncFlags* release_favicon_sync();
  inline void set_allocated_favicon_sync(::sync_pb::FaviconSyncFlags* favicon_sync);

  // optional .sync_pb.PreCommitUpdateAvoidanceFlags pre_commit_update_avoidance = 5;
  inline bool has_pre_commit_update_avoidance() const;
  inline void clear_pre_commit_update_avoidance();
  static const int kPreCommitUpdateAvoidanceFieldNumber = 5;
  inline const ::sync_pb::PreCommitUpdateAvoidanceFlags& pre_commit_update_avoidance() const;
  inline ::sync_pb::PreCommitUpdateAvoidanceFlags* mutable_pre_commit_update_avoidance();
  inline ::sync_pb::PreCommitUpdateAvoidanceFlags* release_pre_commit_update_avoidance();
  inline void set_allocated_pre_commit_update_avoidance(::sync_pb::PreCommitUpdateAvoidanceFlags* pre_commit_update_avoidance);

  // optional .sync_pb.GcmChannelFlags gcm_channel = 6;
  inline bool has_gcm_channel() const;
  inline void clear_gcm_channel();
  static const int kGcmChannelFieldNumber = 6;
  inline const ::sync_pb::GcmChannelFlags& gcm_channel() const;
  inline ::sync_pb::GcmChannelFlags* mutable_gcm_channel();
  inline ::sync_pb::GcmChannelFlags* release_gcm_channel();
  inline void set_allocated_gcm_channel(::sync_pb::GcmChannelFlags* gcm_channel);

  // optional .sync_pb.EnhancedBookmarksFlags enhanced_bookmarks = 7;
  inline bool has_enhanced_bookmarks() const;
  inline void clear_enhanced_bookmarks();
  static const int kEnhancedBookmarksFieldNumber = 7;
  inline const ::sync_pb::EnhancedBookmarksFlags& enhanced_bookmarks() const;
  inline ::sync_pb::EnhancedBookmarksFlags* mutable_enhanced_bookmarks();
  inline ::sync_pb::EnhancedBookmarksFlags* release_enhanced_bookmarks();
  inline void set_allocated_enhanced_bookmarks(::sync_pb::EnhancedBookmarksFlags* enhanced_bookmarks);

  // optional .sync_pb.GcmInvalidationsFlags gcm_invalidations = 8;
  inline bool has_gcm_invalidations() const;
  inline void clear_gcm_invalidations();
  static const int kGcmInvalidationsFieldNumber = 8;
  inline const ::sync_pb::GcmInvalidationsFlags& gcm_invalidations() const;
  inline ::sync_pb::GcmInvalidationsFlags* mutable_gcm_invalidations();
  inline ::sync_pb::GcmInvalidationsFlags* release_gcm_invalidations();
  inline void set_allocated_gcm_invalidations(::sync_pb::GcmInvalidationsFlags* gcm_invalidations);

  // @@protoc_insertion_point(class_scope:sync_pb.ExperimentsSpecifics)
 private:
  inline void set_has_keystore_encryption();
  inline void clear_has_keystore_encryption();
  inline void set_has_history_delete_directives();
  inline void clear_has_history_delete_directives();
  inline void set_has_autofill_culling();
  inline void clear_has_autofill_culling();
  inline void set_has_favicon_sync();
  inline void clear_has_favicon_sync();
  inline void set_has_pre_commit_update_avoidance();
  inline void clear_has_pre_commit_update_avoidance();
  inline void set_has_gcm_channel();
  inline void clear_has_gcm_channel();
  inline void set_has_enhanced_bookmarks();
  inline void clear_has_enhanced_bookmarks();
  inline void set_has_gcm_invalidations();
  inline void clear_has_gcm_invalidations();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::KeystoreEncryptionFlags* keystore_encryption_;
  ::sync_pb::HistoryDeleteDirectives* history_delete_directives_;
  ::sync_pb::AutofillCullingFlags* autofill_culling_;
  ::sync_pb::FaviconSyncFlags* favicon_sync_;
  ::sync_pb::PreCommitUpdateAvoidanceFlags* pre_commit_update_avoidance_;
  ::sync_pb::GcmChannelFlags* gcm_channel_;
  ::sync_pb::EnhancedBookmarksFlags* enhanced_bookmarks_;
  ::sync_pb::GcmInvalidationsFlags* gcm_invalidations_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_experiments_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_experiments_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_experiments_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static ExperimentsSpecifics* default_instance_;
};
// ===================================================================


// ===================================================================

// KeystoreEncryptionFlags

// optional bool enabled = 1;
inline bool KeystoreEncryptionFlags::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeystoreEncryptionFlags::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeystoreEncryptionFlags::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeystoreEncryptionFlags::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool KeystoreEncryptionFlags::enabled() const {
  return enabled_;
}
inline void KeystoreEncryptionFlags::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// HistoryDeleteDirectives

// optional bool enabled = 1;
inline bool HistoryDeleteDirectives::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HistoryDeleteDirectives::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HistoryDeleteDirectives::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HistoryDeleteDirectives::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool HistoryDeleteDirectives::enabled() const {
  return enabled_;
}
inline void HistoryDeleteDirectives::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// AutofillCullingFlags

// optional bool enabled = 1;
inline bool AutofillCullingFlags::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AutofillCullingFlags::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AutofillCullingFlags::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AutofillCullingFlags::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool AutofillCullingFlags::enabled() const {
  return enabled_;
}
inline void AutofillCullingFlags::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// FaviconSyncFlags

// optional bool enabled = 1;
inline bool FaviconSyncFlags::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FaviconSyncFlags::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FaviconSyncFlags::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FaviconSyncFlags::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool FaviconSyncFlags::enabled() const {
  return enabled_;
}
inline void FaviconSyncFlags::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional int32 favicon_sync_limit = 2 [default = 200];
inline bool FaviconSyncFlags::has_favicon_sync_limit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FaviconSyncFlags::set_has_favicon_sync_limit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FaviconSyncFlags::clear_has_favicon_sync_limit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FaviconSyncFlags::clear_favicon_sync_limit() {
  favicon_sync_limit_ = 200;
  clear_has_favicon_sync_limit();
}
inline ::google::protobuf::int32 FaviconSyncFlags::favicon_sync_limit() const {
  return favicon_sync_limit_;
}
inline void FaviconSyncFlags::set_favicon_sync_limit(::google::protobuf::int32 value) {
  set_has_favicon_sync_limit();
  favicon_sync_limit_ = value;
}

// -------------------------------------------------------------------

// PreCommitUpdateAvoidanceFlags

// optional bool enabled = 1;
inline bool PreCommitUpdateAvoidanceFlags::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PreCommitUpdateAvoidanceFlags::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PreCommitUpdateAvoidanceFlags::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PreCommitUpdateAvoidanceFlags::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool PreCommitUpdateAvoidanceFlags::enabled() const {
  return enabled_;
}
inline void PreCommitUpdateAvoidanceFlags::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// GcmChannelFlags

// optional bool enabled = 1;
inline bool GcmChannelFlags::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GcmChannelFlags::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GcmChannelFlags::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GcmChannelFlags::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool GcmChannelFlags::enabled() const {
  return enabled_;
}
inline void GcmChannelFlags::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// EnhancedBookmarksFlags

// optional bool enabled = 1;
inline bool EnhancedBookmarksFlags::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnhancedBookmarksFlags::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnhancedBookmarksFlags::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnhancedBookmarksFlags::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool EnhancedBookmarksFlags::enabled() const {
  return enabled_;
}
inline void EnhancedBookmarksFlags::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional string extension_id = 2;
inline bool EnhancedBookmarksFlags::has_extension_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnhancedBookmarksFlags::set_has_extension_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnhancedBookmarksFlags::clear_has_extension_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnhancedBookmarksFlags::clear_extension_id() {
  if (extension_id_ != &::google::protobuf::internal::GetEmptyString()) {
    extension_id_->clear();
  }
  clear_has_extension_id();
}
inline const ::std::string& EnhancedBookmarksFlags::extension_id() const {
  return *extension_id_;
}
inline void EnhancedBookmarksFlags::set_extension_id(const ::std::string& value) {
  set_has_extension_id();
  if (extension_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_id_ = new ::std::string;
  }
  extension_id_->assign(value);
}
inline void EnhancedBookmarksFlags::set_extension_id(const char* value) {
  set_has_extension_id();
  if (extension_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_id_ = new ::std::string;
  }
  extension_id_->assign(value);
}
inline void EnhancedBookmarksFlags::set_extension_id(const char* value, size_t size) {
  set_has_extension_id();
  if (extension_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_id_ = new ::std::string;
  }
  extension_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnhancedBookmarksFlags::mutable_extension_id() {
  set_has_extension_id();
  if (extension_id_ == &::google::protobuf::internal::GetEmptyString()) {
    extension_id_ = new ::std::string;
  }
  return extension_id_;
}
inline ::std::string* EnhancedBookmarksFlags::release_extension_id() {
  clear_has_extension_id();
  if (extension_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = extension_id_;
    extension_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void EnhancedBookmarksFlags::set_allocated_extension_id(::std::string* extension_id) {
  if (extension_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete extension_id_;
  }
  if (extension_id) {
    set_has_extension_id();
    extension_id_ = extension_id;
  } else {
    clear_has_extension_id();
    extension_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// GcmInvalidationsFlags

// optional bool enabled = 1;
inline bool GcmInvalidationsFlags::has_enabled() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GcmInvalidationsFlags::set_has_enabled() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GcmInvalidationsFlags::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GcmInvalidationsFlags::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool GcmInvalidationsFlags::enabled() const {
  return enabled_;
}
inline void GcmInvalidationsFlags::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// -------------------------------------------------------------------

// ExperimentsSpecifics

// optional .sync_pb.KeystoreEncryptionFlags keystore_encryption = 1;
inline bool ExperimentsSpecifics::has_keystore_encryption() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExperimentsSpecifics::set_has_keystore_encryption() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExperimentsSpecifics::clear_has_keystore_encryption() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExperimentsSpecifics::clear_keystore_encryption() {
  if (keystore_encryption_ != NULL) keystore_encryption_->::sync_pb::KeystoreEncryptionFlags::Clear();
  clear_has_keystore_encryption();
}
inline const ::sync_pb::KeystoreEncryptionFlags& ExperimentsSpecifics::keystore_encryption() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return keystore_encryption_ != NULL ? *keystore_encryption_ : *default_instance().keystore_encryption_;
#else
  return keystore_encryption_ != NULL ? *keystore_encryption_ : *default_instance_->keystore_encryption_;
#endif
}
inline ::sync_pb::KeystoreEncryptionFlags* ExperimentsSpecifics::mutable_keystore_encryption() {
  set_has_keystore_encryption();
  if (keystore_encryption_ == NULL) keystore_encryption_ = new ::sync_pb::KeystoreEncryptionFlags;
  return keystore_encryption_;
}
inline ::sync_pb::KeystoreEncryptionFlags* ExperimentsSpecifics::release_keystore_encryption() {
  clear_has_keystore_encryption();
  ::sync_pb::KeystoreEncryptionFlags* temp = keystore_encryption_;
  keystore_encryption_ = NULL;
  return temp;
}
inline void ExperimentsSpecifics::set_allocated_keystore_encryption(::sync_pb::KeystoreEncryptionFlags* keystore_encryption) {
  delete keystore_encryption_;
  keystore_encryption_ = keystore_encryption;
  if (keystore_encryption) {
    set_has_keystore_encryption();
  } else {
    clear_has_keystore_encryption();
  }
}

// optional .sync_pb.HistoryDeleteDirectives history_delete_directives = 2;
inline bool ExperimentsSpecifics::has_history_delete_directives() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExperimentsSpecifics::set_has_history_delete_directives() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExperimentsSpecifics::clear_has_history_delete_directives() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExperimentsSpecifics::clear_history_delete_directives() {
  if (history_delete_directives_ != NULL) history_delete_directives_->::sync_pb::HistoryDeleteDirectives::Clear();
  clear_has_history_delete_directives();
}
inline const ::sync_pb::HistoryDeleteDirectives& ExperimentsSpecifics::history_delete_directives() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return history_delete_directives_ != NULL ? *history_delete_directives_ : *default_instance().history_delete_directives_;
#else
  return history_delete_directives_ != NULL ? *history_delete_directives_ : *default_instance_->history_delete_directives_;
#endif
}
inline ::sync_pb::HistoryDeleteDirectives* ExperimentsSpecifics::mutable_history_delete_directives() {
  set_has_history_delete_directives();
  if (history_delete_directives_ == NULL) history_delete_directives_ = new ::sync_pb::HistoryDeleteDirectives;
  return history_delete_directives_;
}
inline ::sync_pb::HistoryDeleteDirectives* ExperimentsSpecifics::release_history_delete_directives() {
  clear_has_history_delete_directives();
  ::sync_pb::HistoryDeleteDirectives* temp = history_delete_directives_;
  history_delete_directives_ = NULL;
  return temp;
}
inline void ExperimentsSpecifics::set_allocated_history_delete_directives(::sync_pb::HistoryDeleteDirectives* history_delete_directives) {
  delete history_delete_directives_;
  history_delete_directives_ = history_delete_directives;
  if (history_delete_directives) {
    set_has_history_delete_directives();
  } else {
    clear_has_history_delete_directives();
  }
}

// optional .sync_pb.AutofillCullingFlags autofill_culling = 3;
inline bool ExperimentsSpecifics::has_autofill_culling() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExperimentsSpecifics::set_has_autofill_culling() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExperimentsSpecifics::clear_has_autofill_culling() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExperimentsSpecifics::clear_autofill_culling() {
  if (autofill_culling_ != NULL) autofill_culling_->::sync_pb::AutofillCullingFlags::Clear();
  clear_has_autofill_culling();
}
inline const ::sync_pb::AutofillCullingFlags& ExperimentsSpecifics::autofill_culling() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return autofill_culling_ != NULL ? *autofill_culling_ : *default_instance().autofill_culling_;
#else
  return autofill_culling_ != NULL ? *autofill_culling_ : *default_instance_->autofill_culling_;
#endif
}
inline ::sync_pb::AutofillCullingFlags* ExperimentsSpecifics::mutable_autofill_culling() {
  set_has_autofill_culling();
  if (autofill_culling_ == NULL) autofill_culling_ = new ::sync_pb::AutofillCullingFlags;
  return autofill_culling_;
}
inline ::sync_pb::AutofillCullingFlags* ExperimentsSpecifics::release_autofill_culling() {
  clear_has_autofill_culling();
  ::sync_pb::AutofillCullingFlags* temp = autofill_culling_;
  autofill_culling_ = NULL;
  return temp;
}
inline void ExperimentsSpecifics::set_allocated_autofill_culling(::sync_pb::AutofillCullingFlags* autofill_culling) {
  delete autofill_culling_;
  autofill_culling_ = autofill_culling;
  if (autofill_culling) {
    set_has_autofill_culling();
  } else {
    clear_has_autofill_culling();
  }
}

// optional .sync_pb.FaviconSyncFlags favicon_sync = 4;
inline bool ExperimentsSpecifics::has_favicon_sync() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExperimentsSpecifics::set_has_favicon_sync() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExperimentsSpecifics::clear_has_favicon_sync() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExperimentsSpecifics::clear_favicon_sync() {
  if (favicon_sync_ != NULL) favicon_sync_->::sync_pb::FaviconSyncFlags::Clear();
  clear_has_favicon_sync();
}
inline const ::sync_pb::FaviconSyncFlags& ExperimentsSpecifics::favicon_sync() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return favicon_sync_ != NULL ? *favicon_sync_ : *default_instance().favicon_sync_;
#else
  return favicon_sync_ != NULL ? *favicon_sync_ : *default_instance_->favicon_sync_;
#endif
}
inline ::sync_pb::FaviconSyncFlags* ExperimentsSpecifics::mutable_favicon_sync() {
  set_has_favicon_sync();
  if (favicon_sync_ == NULL) favicon_sync_ = new ::sync_pb::FaviconSyncFlags;
  return favicon_sync_;
}
inline ::sync_pb::FaviconSyncFlags* ExperimentsSpecifics::release_favicon_sync() {
  clear_has_favicon_sync();
  ::sync_pb::FaviconSyncFlags* temp = favicon_sync_;
  favicon_sync_ = NULL;
  return temp;
}
inline void ExperimentsSpecifics::set_allocated_favicon_sync(::sync_pb::FaviconSyncFlags* favicon_sync) {
  delete favicon_sync_;
  favicon_sync_ = favicon_sync;
  if (favicon_sync) {
    set_has_favicon_sync();
  } else {
    clear_has_favicon_sync();
  }
}

// optional .sync_pb.PreCommitUpdateAvoidanceFlags pre_commit_update_avoidance = 5;
inline bool ExperimentsSpecifics::has_pre_commit_update_avoidance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExperimentsSpecifics::set_has_pre_commit_update_avoidance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExperimentsSpecifics::clear_has_pre_commit_update_avoidance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExperimentsSpecifics::clear_pre_commit_update_avoidance() {
  if (pre_commit_update_avoidance_ != NULL) pre_commit_update_avoidance_->::sync_pb::PreCommitUpdateAvoidanceFlags::Clear();
  clear_has_pre_commit_update_avoidance();
}
inline const ::sync_pb::PreCommitUpdateAvoidanceFlags& ExperimentsSpecifics::pre_commit_update_avoidance() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pre_commit_update_avoidance_ != NULL ? *pre_commit_update_avoidance_ : *default_instance().pre_commit_update_avoidance_;
#else
  return pre_commit_update_avoidance_ != NULL ? *pre_commit_update_avoidance_ : *default_instance_->pre_commit_update_avoidance_;
#endif
}
inline ::sync_pb::PreCommitUpdateAvoidanceFlags* ExperimentsSpecifics::mutable_pre_commit_update_avoidance() {
  set_has_pre_commit_update_avoidance();
  if (pre_commit_update_avoidance_ == NULL) pre_commit_update_avoidance_ = new ::sync_pb::PreCommitUpdateAvoidanceFlags;
  return pre_commit_update_avoidance_;
}
inline ::sync_pb::PreCommitUpdateAvoidanceFlags* ExperimentsSpecifics::release_pre_commit_update_avoidance() {
  clear_has_pre_commit_update_avoidance();
  ::sync_pb::PreCommitUpdateAvoidanceFlags* temp = pre_commit_update_avoidance_;
  pre_commit_update_avoidance_ = NULL;
  return temp;
}
inline void ExperimentsSpecifics::set_allocated_pre_commit_update_avoidance(::sync_pb::PreCommitUpdateAvoidanceFlags* pre_commit_update_avoidance) {
  delete pre_commit_update_avoidance_;
  pre_commit_update_avoidance_ = pre_commit_update_avoidance;
  if (pre_commit_update_avoidance) {
    set_has_pre_commit_update_avoidance();
  } else {
    clear_has_pre_commit_update_avoidance();
  }
}

// optional .sync_pb.GcmChannelFlags gcm_channel = 6;
inline bool ExperimentsSpecifics::has_gcm_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExperimentsSpecifics::set_has_gcm_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ExperimentsSpecifics::clear_has_gcm_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ExperimentsSpecifics::clear_gcm_channel() {
  if (gcm_channel_ != NULL) gcm_channel_->::sync_pb::GcmChannelFlags::Clear();
  clear_has_gcm_channel();
}
inline const ::sync_pb::GcmChannelFlags& ExperimentsSpecifics::gcm_channel() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gcm_channel_ != NULL ? *gcm_channel_ : *default_instance().gcm_channel_;
#else
  return gcm_channel_ != NULL ? *gcm_channel_ : *default_instance_->gcm_channel_;
#endif
}
inline ::sync_pb::GcmChannelFlags* ExperimentsSpecifics::mutable_gcm_channel() {
  set_has_gcm_channel();
  if (gcm_channel_ == NULL) gcm_channel_ = new ::sync_pb::GcmChannelFlags;
  return gcm_channel_;
}
inline ::sync_pb::GcmChannelFlags* ExperimentsSpecifics::release_gcm_channel() {
  clear_has_gcm_channel();
  ::sync_pb::GcmChannelFlags* temp = gcm_channel_;
  gcm_channel_ = NULL;
  return temp;
}
inline void ExperimentsSpecifics::set_allocated_gcm_channel(::sync_pb::GcmChannelFlags* gcm_channel) {
  delete gcm_channel_;
  gcm_channel_ = gcm_channel;
  if (gcm_channel) {
    set_has_gcm_channel();
  } else {
    clear_has_gcm_channel();
  }
}

// optional .sync_pb.EnhancedBookmarksFlags enhanced_bookmarks = 7;
inline bool ExperimentsSpecifics::has_enhanced_bookmarks() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExperimentsSpecifics::set_has_enhanced_bookmarks() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExperimentsSpecifics::clear_has_enhanced_bookmarks() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExperimentsSpecifics::clear_enhanced_bookmarks() {
  if (enhanced_bookmarks_ != NULL) enhanced_bookmarks_->::sync_pb::EnhancedBookmarksFlags::Clear();
  clear_has_enhanced_bookmarks();
}
inline const ::sync_pb::EnhancedBookmarksFlags& ExperimentsSpecifics::enhanced_bookmarks() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return enhanced_bookmarks_ != NULL ? *enhanced_bookmarks_ : *default_instance().enhanced_bookmarks_;
#else
  return enhanced_bookmarks_ != NULL ? *enhanced_bookmarks_ : *default_instance_->enhanced_bookmarks_;
#endif
}
inline ::sync_pb::EnhancedBookmarksFlags* ExperimentsSpecifics::mutable_enhanced_bookmarks() {
  set_has_enhanced_bookmarks();
  if (enhanced_bookmarks_ == NULL) enhanced_bookmarks_ = new ::sync_pb::EnhancedBookmarksFlags;
  return enhanced_bookmarks_;
}
inline ::sync_pb::EnhancedBookmarksFlags* ExperimentsSpecifics::release_enhanced_bookmarks() {
  clear_has_enhanced_bookmarks();
  ::sync_pb::EnhancedBookmarksFlags* temp = enhanced_bookmarks_;
  enhanced_bookmarks_ = NULL;
  return temp;
}
inline void ExperimentsSpecifics::set_allocated_enhanced_bookmarks(::sync_pb::EnhancedBookmarksFlags* enhanced_bookmarks) {
  delete enhanced_bookmarks_;
  enhanced_bookmarks_ = enhanced_bookmarks;
  if (enhanced_bookmarks) {
    set_has_enhanced_bookmarks();
  } else {
    clear_has_enhanced_bookmarks();
  }
}

// optional .sync_pb.GcmInvalidationsFlags gcm_invalidations = 8;
inline bool ExperimentsSpecifics::has_gcm_invalidations() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ExperimentsSpecifics::set_has_gcm_invalidations() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ExperimentsSpecifics::clear_has_gcm_invalidations() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ExperimentsSpecifics::clear_gcm_invalidations() {
  if (gcm_invalidations_ != NULL) gcm_invalidations_->::sync_pb::GcmInvalidationsFlags::Clear();
  clear_has_gcm_invalidations();
}
inline const ::sync_pb::GcmInvalidationsFlags& ExperimentsSpecifics::gcm_invalidations() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gcm_invalidations_ != NULL ? *gcm_invalidations_ : *default_instance().gcm_invalidations_;
#else
  return gcm_invalidations_ != NULL ? *gcm_invalidations_ : *default_instance_->gcm_invalidations_;
#endif
}
inline ::sync_pb::GcmInvalidationsFlags* ExperimentsSpecifics::mutable_gcm_invalidations() {
  set_has_gcm_invalidations();
  if (gcm_invalidations_ == NULL) gcm_invalidations_ = new ::sync_pb::GcmInvalidationsFlags;
  return gcm_invalidations_;
}
inline ::sync_pb::GcmInvalidationsFlags* ExperimentsSpecifics::release_gcm_invalidations() {
  clear_has_gcm_invalidations();
  ::sync_pb::GcmInvalidationsFlags* temp = gcm_invalidations_;
  gcm_invalidations_ = NULL;
  return temp;
}
inline void ExperimentsSpecifics::set_allocated_gcm_invalidations(::sync_pb::GcmInvalidationsFlags* gcm_invalidations) {
  delete gcm_invalidations_;
  gcm_invalidations_ = gcm_invalidations;
  if (gcm_invalidations) {
    set_has_gcm_invalidations();
  } else {
    clear_has_gcm_invalidations();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sync_pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_experiments_5fspecifics_2eproto__INCLUDED
