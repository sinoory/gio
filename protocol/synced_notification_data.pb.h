// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: synced_notification_data.proto

#ifndef PROTOBUF_synced_5fnotification_5fdata_2eproto__INCLUDED
#define PROTOBUF_synced_5fnotification_5fdata_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "synced_notification_render.pb.h"
// @@protoc_insertion_point(includes)
#include "sync/base/sync_export.h"

namespace sync_pb {

// Internal implementation detail -- do not call these.
void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

class SyncedNotificationIdentifier;
class SyncedNotificationCreator;
class SyncedNotificationRecipients;
class SyncedNotification;
class CoalescedSyncedNotification;
class SyncedNotificationList;
class MapData;
class MapData_Entry;
class Data;
class ListData;

enum CoalescedSyncedNotification_ReadState {
  CoalescedSyncedNotification_ReadState_UNREAD = 1,
  CoalescedSyncedNotification_ReadState_READ = 2,
  CoalescedSyncedNotification_ReadState_DISMISSED = 3
};
SYNC_EXPORT bool CoalescedSyncedNotification_ReadState_IsValid(int value);
const CoalescedSyncedNotification_ReadState CoalescedSyncedNotification_ReadState_ReadState_MIN = CoalescedSyncedNotification_ReadState_UNREAD;
const CoalescedSyncedNotification_ReadState CoalescedSyncedNotification_ReadState_ReadState_MAX = CoalescedSyncedNotification_ReadState_DISMISSED;
const int CoalescedSyncedNotification_ReadState_ReadState_ARRAYSIZE = CoalescedSyncedNotification_ReadState_ReadState_MAX + 1;

enum CoalescedSyncedNotification_Priority {
  CoalescedSyncedNotification_Priority_LOW = 1,
  CoalescedSyncedNotification_Priority_STANDARD = 2,
  CoalescedSyncedNotification_Priority_HIGH = 3
};
SYNC_EXPORT bool CoalescedSyncedNotification_Priority_IsValid(int value);
const CoalescedSyncedNotification_Priority CoalescedSyncedNotification_Priority_Priority_MIN = CoalescedSyncedNotification_Priority_LOW;
const CoalescedSyncedNotification_Priority CoalescedSyncedNotification_Priority_Priority_MAX = CoalescedSyncedNotification_Priority_HIGH;
const int CoalescedSyncedNotification_Priority_Priority_ARRAYSIZE = CoalescedSyncedNotification_Priority_Priority_MAX + 1;

// ===================================================================

class SYNC_EXPORT SyncedNotificationIdentifier : public ::google::protobuf::MessageLite {
 public:
  SyncedNotificationIdentifier();
  virtual ~SyncedNotificationIdentifier();

  SyncedNotificationIdentifier(const SyncedNotificationIdentifier& from);

  inline SyncedNotificationIdentifier& operator=(const SyncedNotificationIdentifier& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncedNotificationIdentifier& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncedNotificationIdentifier* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncedNotificationIdentifier* other);

  // implements Message ----------------------------------------------

  SyncedNotificationIdentifier* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncedNotificationIdentifier& from);
  void MergeFrom(const SyncedNotificationIdentifier& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string app_id = 1;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  inline const ::std::string& app_id() const;
  inline void set_app_id(const ::std::string& value);
  inline void set_app_id(const char* value);
  inline void set_app_id(const char* value, size_t size);
  inline ::std::string* mutable_app_id();
  inline ::std::string* release_app_id();
  inline void set_allocated_app_id(::std::string* app_id);

  // optional string coalescing_key = 2;
  inline bool has_coalescing_key() const;
  inline void clear_coalescing_key();
  static const int kCoalescingKeyFieldNumber = 2;
  inline const ::std::string& coalescing_key() const;
  inline void set_coalescing_key(const ::std::string& value);
  inline void set_coalescing_key(const char* value);
  inline void set_coalescing_key(const char* value, size_t size);
  inline ::std::string* mutable_coalescing_key();
  inline ::std::string* release_coalescing_key();
  inline void set_allocated_coalescing_key(::std::string* coalescing_key);

  // @@protoc_insertion_point(class_scope:sync_pb.SyncedNotificationIdentifier)
 private:
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_coalescing_key();
  inline void clear_has_coalescing_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* app_id_;
  ::std::string* coalescing_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

  void InitAsDefaultInstance();
  static SyncedNotificationIdentifier* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SyncedNotificationCreator : public ::google::protobuf::MessageLite {
 public:
  SyncedNotificationCreator();
  virtual ~SyncedNotificationCreator();

  SyncedNotificationCreator(const SyncedNotificationCreator& from);

  inline SyncedNotificationCreator& operator=(const SyncedNotificationCreator& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncedNotificationCreator& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncedNotificationCreator* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncedNotificationCreator* other);

  // implements Message ----------------------------------------------

  SyncedNotificationCreator* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncedNotificationCreator& from);
  void MergeFrom(const SyncedNotificationCreator& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 gaia_id = 1;
  inline bool has_gaia_id() const;
  inline void clear_gaia_id();
  static const int kGaiaIdFieldNumber = 1;
  inline ::google::protobuf::int64 gaia_id() const;
  inline void set_gaia_id(::google::protobuf::int64 value);

  // optional bool is_system = 2;
  inline bool has_is_system() const;
  inline void clear_is_system();
  static const int kIsSystemFieldNumber = 2;
  inline bool is_system() const;
  inline void set_is_system(bool value);

  // optional string app_id = 3;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 3;
  inline const ::std::string& app_id() const;
  inline void set_app_id(const ::std::string& value);
  inline void set_app_id(const char* value);
  inline void set_app_id(const char* value, size_t size);
  inline ::std::string* mutable_app_id();
  inline ::std::string* release_app_id();
  inline void set_allocated_app_id(::std::string* app_id);

  // @@protoc_insertion_point(class_scope:sync_pb.SyncedNotificationCreator)
 private:
  inline void set_has_gaia_id();
  inline void clear_has_gaia_id();
  inline void set_has_is_system();
  inline void clear_has_is_system();
  inline void set_has_app_id();
  inline void clear_has_app_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 gaia_id_;
  ::std::string* app_id_;
  bool is_system_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

  void InitAsDefaultInstance();
  static SyncedNotificationCreator* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SyncedNotificationRecipients : public ::google::protobuf::MessageLite {
 public:
  SyncedNotificationRecipients();
  virtual ~SyncedNotificationRecipients();

  SyncedNotificationRecipients(const SyncedNotificationRecipients& from);

  inline SyncedNotificationRecipients& operator=(const SyncedNotificationRecipients& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncedNotificationRecipients& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncedNotificationRecipients* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncedNotificationRecipients* other);

  // implements Message ----------------------------------------------

  SyncedNotificationRecipients* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncedNotificationRecipients& from);
  void MergeFrom(const SyncedNotificationRecipients& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 gaia_id = 1;
  inline int gaia_id_size() const;
  inline void clear_gaia_id();
  static const int kGaiaIdFieldNumber = 1;
  inline ::google::protobuf::int64 gaia_id(int index) const;
  inline void set_gaia_id(int index, ::google::protobuf::int64 value);
  inline void add_gaia_id(::google::protobuf::int64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      gaia_id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_gaia_id();

  // @@protoc_insertion_point(class_scope:sync_pb.SyncedNotificationRecipients)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > gaia_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

  void InitAsDefaultInstance();
  static SyncedNotificationRecipients* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SyncedNotification : public ::google::protobuf::MessageLite {
 public:
  SyncedNotification();
  virtual ~SyncedNotification();

  SyncedNotification(const SyncedNotification& from);

  inline SyncedNotification& operator=(const SyncedNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncedNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncedNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncedNotification* other);

  // implements Message ----------------------------------------------

  SyncedNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncedNotification& from);
  void MergeFrom(const SyncedNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional string external_id = 2;
  inline bool has_external_id() const;
  inline void clear_external_id();
  static const int kExternalIdFieldNumber = 2;
  inline const ::std::string& external_id() const;
  inline void set_external_id(const ::std::string& value);
  inline void set_external_id(const char* value);
  inline void set_external_id(const char* value, size_t size);
  inline ::std::string* mutable_external_id();
  inline ::std::string* release_external_id();
  inline void set_allocated_external_id(::std::string* external_id);

  // optional .sync_pb.SyncedNotificationCreator creator = 3;
  inline bool has_creator() const;
  inline void clear_creator();
  static const int kCreatorFieldNumber = 3;
  inline const ::sync_pb::SyncedNotificationCreator& creator() const;
  inline ::sync_pb::SyncedNotificationCreator* mutable_creator();
  inline ::sync_pb::SyncedNotificationCreator* release_creator();
  inline void set_allocated_creator(::sync_pb::SyncedNotificationCreator* creator);

  // optional .sync_pb.MapData client_data = 4;
  inline bool has_client_data() const;
  inline void clear_client_data();
  static const int kClientDataFieldNumber = 4;
  inline const ::sync_pb::MapData& client_data() const;
  inline ::sync_pb::MapData* mutable_client_data();
  inline ::sync_pb::MapData* release_client_data();
  inline void set_allocated_client_data(::sync_pb::MapData* client_data);

  // @@protoc_insertion_point(class_scope:sync_pb.SyncedNotification)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_external_id();
  inline void clear_has_external_id();
  inline void set_has_creator();
  inline void clear_has_creator();
  inline void set_has_client_data();
  inline void clear_has_client_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  ::std::string* external_id_;
  ::sync_pb::SyncedNotificationCreator* creator_;
  ::sync_pb::MapData* client_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

  void InitAsDefaultInstance();
  static SyncedNotification* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT CoalescedSyncedNotification : public ::google::protobuf::MessageLite {
 public:
  CoalescedSyncedNotification();
  virtual ~CoalescedSyncedNotification();

  CoalescedSyncedNotification(const CoalescedSyncedNotification& from);

  inline CoalescedSyncedNotification& operator=(const CoalescedSyncedNotification& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const CoalescedSyncedNotification& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CoalescedSyncedNotification* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CoalescedSyncedNotification* other);

  // implements Message ----------------------------------------------

  CoalescedSyncedNotification* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CoalescedSyncedNotification& from);
  void MergeFrom(const CoalescedSyncedNotification& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef CoalescedSyncedNotification_ReadState ReadState;
  static const ReadState UNREAD = CoalescedSyncedNotification_ReadState_UNREAD;
  static const ReadState READ = CoalescedSyncedNotification_ReadState_READ;
  static const ReadState DISMISSED = CoalescedSyncedNotification_ReadState_DISMISSED;
  static inline bool ReadState_IsValid(int value) {
    return CoalescedSyncedNotification_ReadState_IsValid(value);
  }
  static const ReadState ReadState_MIN =
    CoalescedSyncedNotification_ReadState_ReadState_MIN;
  static const ReadState ReadState_MAX =
    CoalescedSyncedNotification_ReadState_ReadState_MAX;
  static const int ReadState_ARRAYSIZE =
    CoalescedSyncedNotification_ReadState_ReadState_ARRAYSIZE;

  typedef CoalescedSyncedNotification_Priority Priority;
  static const Priority LOW = CoalescedSyncedNotification_Priority_LOW;
  static const Priority STANDARD = CoalescedSyncedNotification_Priority_STANDARD;
  static const Priority HIGH = CoalescedSyncedNotification_Priority_HIGH;
  static inline bool Priority_IsValid(int value) {
    return CoalescedSyncedNotification_Priority_IsValid(value);
  }
  static const Priority Priority_MIN =
    CoalescedSyncedNotification_Priority_Priority_MIN;
  static const Priority Priority_MAX =
    CoalescedSyncedNotification_Priority_Priority_MAX;
  static const int Priority_ARRAYSIZE =
    CoalescedSyncedNotification_Priority_Priority_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional string app_id = 2;
  inline bool has_app_id() const;
  inline void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  inline const ::std::string& app_id() const;
  inline void set_app_id(const ::std::string& value);
  inline void set_app_id(const char* value);
  inline void set_app_id(const char* value, size_t size);
  inline ::std::string* mutable_app_id();
  inline ::std::string* release_app_id();
  inline void set_allocated_app_id(::std::string* app_id);

  // repeated .sync_pb.SyncedNotification notification = 3;
  inline int notification_size() const;
  inline void clear_notification();
  static const int kNotificationFieldNumber = 3;
  inline const ::sync_pb::SyncedNotification& notification(int index) const;
  inline ::sync_pb::SyncedNotification* mutable_notification(int index);
  inline ::sync_pb::SyncedNotification* add_notification();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncedNotification >&
      notification() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncedNotification >*
      mutable_notification();

  // optional .sync_pb.SyncedNotificationRenderInfo render_info = 4;
  inline bool has_render_info() const;
  inline void clear_render_info();
  static const int kRenderInfoFieldNumber = 4;
  inline const ::sync_pb::SyncedNotificationRenderInfo& render_info() const;
  inline ::sync_pb::SyncedNotificationRenderInfo* mutable_render_info();
  inline ::sync_pb::SyncedNotificationRenderInfo* release_render_info();
  inline void set_allocated_render_info(::sync_pb::SyncedNotificationRenderInfo* render_info);

  // optional .sync_pb.CoalescedSyncedNotification.ReadState read_state = 5;
  inline bool has_read_state() const;
  inline void clear_read_state();
  static const int kReadStateFieldNumber = 5;
  inline ::sync_pb::CoalescedSyncedNotification_ReadState read_state() const;
  inline void set_read_state(::sync_pb::CoalescedSyncedNotification_ReadState value);

  // optional uint64 creation_time_msec = 6;
  inline bool has_creation_time_msec() const;
  inline void clear_creation_time_msec();
  static const int kCreationTimeMsecFieldNumber = 6;
  inline ::google::protobuf::uint64 creation_time_msec() const;
  inline void set_creation_time_msec(::google::protobuf::uint64 value);

  // optional .sync_pb.CoalescedSyncedNotification.Priority priority = 7;
  inline bool has_priority() const;
  inline void clear_priority();
  static const int kPriorityFieldNumber = 7;
  inline ::sync_pb::CoalescedSyncedNotification_Priority priority() const;
  inline void set_priority(::sync_pb::CoalescedSyncedNotification_Priority value);

  // @@protoc_insertion_point(class_scope:sync_pb.CoalescedSyncedNotification)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_app_id();
  inline void clear_has_app_id();
  inline void set_has_render_info();
  inline void clear_has_render_info();
  inline void set_has_read_state();
  inline void clear_has_read_state();
  inline void set_has_creation_time_msec();
  inline void clear_has_creation_time_msec();
  inline void set_has_priority();
  inline void clear_has_priority();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* app_id_;
  ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncedNotification > notification_;
  ::sync_pb::SyncedNotificationRenderInfo* render_info_;
  ::google::protobuf::uint64 creation_time_msec_;
  int read_state_;
  int priority_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

  void InitAsDefaultInstance();
  static CoalescedSyncedNotification* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT SyncedNotificationList : public ::google::protobuf::MessageLite {
 public:
  SyncedNotificationList();
  virtual ~SyncedNotificationList();

  SyncedNotificationList(const SyncedNotificationList& from);

  inline SyncedNotificationList& operator=(const SyncedNotificationList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const SyncedNotificationList& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SyncedNotificationList* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SyncedNotificationList* other);

  // implements Message ----------------------------------------------

  SyncedNotificationList* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SyncedNotificationList& from);
  void MergeFrom(const SyncedNotificationList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sync_pb.CoalescedSyncedNotification coalesced_notification = 1;
  inline int coalesced_notification_size() const;
  inline void clear_coalesced_notification();
  static const int kCoalescedNotificationFieldNumber = 1;
  inline const ::sync_pb::CoalescedSyncedNotification& coalesced_notification(int index) const;
  inline ::sync_pb::CoalescedSyncedNotification* mutable_coalesced_notification(int index);
  inline ::sync_pb::CoalescedSyncedNotification* add_coalesced_notification();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::CoalescedSyncedNotification >&
      coalesced_notification() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::CoalescedSyncedNotification >*
      mutable_coalesced_notification();

  // @@protoc_insertion_point(class_scope:sync_pb.SyncedNotificationList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sync_pb::CoalescedSyncedNotification > coalesced_notification_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

  void InitAsDefaultInstance();
  static SyncedNotificationList* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT MapData_Entry : public ::google::protobuf::MessageLite {
 public:
  MapData_Entry();
  virtual ~MapData_Entry();

  MapData_Entry(const MapData_Entry& from);

  inline MapData_Entry& operator=(const MapData_Entry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MapData_Entry& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapData_Entry* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapData_Entry* other);

  // implements Message ----------------------------------------------

  MapData_Entry* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapData_Entry& from);
  void MergeFrom(const MapData_Entry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // optional .sync_pb.Data value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::sync_pb::Data& value() const;
  inline ::sync_pb::Data* mutable_value();
  inline ::sync_pb::Data* release_value();
  inline void set_allocated_value(::sync_pb::Data* value);

  // @@protoc_insertion_point(class_scope:sync_pb.MapData.Entry)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::sync_pb::Data* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

  void InitAsDefaultInstance();
  static MapData_Entry* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT MapData : public ::google::protobuf::MessageLite {
 public:
  MapData();
  virtual ~MapData();

  MapData(const MapData& from);

  inline MapData& operator=(const MapData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const MapData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MapData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MapData* other);

  // implements Message ----------------------------------------------

  MapData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MapData& from);
  void MergeFrom(const MapData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef MapData_Entry Entry;

  // accessors -------------------------------------------------------

  // repeated .sync_pb.MapData.Entry entry = 1;
  inline int entry_size() const;
  inline void clear_entry();
  static const int kEntryFieldNumber = 1;
  inline const ::sync_pb::MapData_Entry& entry(int index) const;
  inline ::sync_pb::MapData_Entry* mutable_entry(int index);
  inline ::sync_pb::MapData_Entry* add_entry();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::MapData_Entry >&
      entry() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::MapData_Entry >*
      mutable_entry();

  // @@protoc_insertion_point(class_scope:sync_pb.MapData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sync_pb::MapData_Entry > entry_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

  void InitAsDefaultInstance();
  static MapData* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT Data : public ::google::protobuf::MessageLite {
 public:
  Data();
  virtual ~Data();

  Data(const Data& from);

  inline Data& operator=(const Data& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const Data& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Data* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Data* other);

  // implements Message ----------------------------------------------

  Data* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Data& from);
  void MergeFrom(const Data& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool boolean_value = 1;
  inline bool has_boolean_value() const;
  inline void clear_boolean_value();
  static const int kBooleanValueFieldNumber = 1;
  inline bool boolean_value() const;
  inline void set_boolean_value(bool value);

  // optional int32 int_value = 2;
  inline bool has_int_value() const;
  inline void clear_int_value();
  static const int kIntValueFieldNumber = 2;
  inline ::google::protobuf::int32 int_value() const;
  inline void set_int_value(::google::protobuf::int32 value);

  // optional double float_value = 3;
  inline bool has_float_value() const;
  inline void clear_float_value();
  static const int kFloatValueFieldNumber = 3;
  inline double float_value() const;
  inline void set_float_value(double value);

  // optional string string_value = 4;
  inline bool has_string_value() const;
  inline void clear_string_value();
  static const int kStringValueFieldNumber = 4;
  inline const ::std::string& string_value() const;
  inline void set_string_value(const ::std::string& value);
  inline void set_string_value(const char* value);
  inline void set_string_value(const char* value, size_t size);
  inline ::std::string* mutable_string_value();
  inline ::std::string* release_string_value();
  inline void set_allocated_string_value(::std::string* string_value);

  // optional .sync_pb.ListData list_value = 5;
  inline bool has_list_value() const;
  inline void clear_list_value();
  static const int kListValueFieldNumber = 5;
  inline const ::sync_pb::ListData& list_value() const;
  inline ::sync_pb::ListData* mutable_list_value();
  inline ::sync_pb::ListData* release_list_value();
  inline void set_allocated_list_value(::sync_pb::ListData* list_value);

  // optional .sync_pb.MapData map_value = 6;
  inline bool has_map_value() const;
  inline void clear_map_value();
  static const int kMapValueFieldNumber = 6;
  inline const ::sync_pb::MapData& map_value() const;
  inline ::sync_pb::MapData* mutable_map_value();
  inline ::sync_pb::MapData* release_map_value();
  inline void set_allocated_map_value(::sync_pb::MapData* map_value);

  // @@protoc_insertion_point(class_scope:sync_pb.Data)
 private:
  inline void set_has_boolean_value();
  inline void clear_has_boolean_value();
  inline void set_has_int_value();
  inline void clear_has_int_value();
  inline void set_has_float_value();
  inline void clear_has_float_value();
  inline void set_has_string_value();
  inline void clear_has_string_value();
  inline void set_has_list_value();
  inline void clear_has_list_value();
  inline void set_has_map_value();
  inline void clear_has_map_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool boolean_value_;
  ::google::protobuf::int32 int_value_;
  double float_value_;
  ::std::string* string_value_;
  ::sync_pb::ListData* list_value_;
  ::sync_pb::MapData* map_value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

  void InitAsDefaultInstance();
  static Data* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT ListData : public ::google::protobuf::MessageLite {
 public:
  ListData();
  virtual ~ListData();

  ListData(const ListData& from);

  inline ListData& operator=(const ListData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ListData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ListData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ListData* other);

  // implements Message ----------------------------------------------

  ListData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ListData& from);
  void MergeFrom(const ListData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sync_pb.Data value = 1;
  inline int value_size() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::sync_pb::Data& value(int index) const;
  inline ::sync_pb::Data* mutable_value(int index);
  inline ::sync_pb::Data* add_value();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Data >&
      value() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Data >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:sync_pb.ListData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sync_pb::Data > value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_synced_5fnotification_5fdata_2eproto();
  #endif
  friend void protobuf_AssignDesc_synced_5fnotification_5fdata_2eproto();
  friend void protobuf_ShutdownFile_synced_5fnotification_5fdata_2eproto();

  void InitAsDefaultInstance();
  static ListData* default_instance_;
};
// ===================================================================


// ===================================================================

// SyncedNotificationIdentifier

// optional string app_id = 1;
inline bool SyncedNotificationIdentifier::has_app_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncedNotificationIdentifier::set_has_app_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncedNotificationIdentifier::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncedNotificationIdentifier::clear_app_id() {
  if (app_id_ != &::google::protobuf::internal::GetEmptyString()) {
    app_id_->clear();
  }
  clear_has_app_id();
}
inline const ::std::string& SyncedNotificationIdentifier::app_id() const {
  return *app_id_;
}
inline void SyncedNotificationIdentifier::set_app_id(const ::std::string& value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void SyncedNotificationIdentifier::set_app_id(const char* value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void SyncedNotificationIdentifier::set_app_id(const char* value, size_t size) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationIdentifier::mutable_app_id() {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  return app_id_;
}
inline ::std::string* SyncedNotificationIdentifier::release_app_id() {
  clear_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = app_id_;
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationIdentifier::set_allocated_app_id(::std::string* app_id) {
  if (app_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete app_id_;
  }
  if (app_id) {
    set_has_app_id();
    app_id_ = app_id;
  } else {
    clear_has_app_id();
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string coalescing_key = 2;
inline bool SyncedNotificationIdentifier::has_coalescing_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncedNotificationIdentifier::set_has_coalescing_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncedNotificationIdentifier::clear_has_coalescing_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncedNotificationIdentifier::clear_coalescing_key() {
  if (coalescing_key_ != &::google::protobuf::internal::GetEmptyString()) {
    coalescing_key_->clear();
  }
  clear_has_coalescing_key();
}
inline const ::std::string& SyncedNotificationIdentifier::coalescing_key() const {
  return *coalescing_key_;
}
inline void SyncedNotificationIdentifier::set_coalescing_key(const ::std::string& value) {
  set_has_coalescing_key();
  if (coalescing_key_ == &::google::protobuf::internal::GetEmptyString()) {
    coalescing_key_ = new ::std::string;
  }
  coalescing_key_->assign(value);
}
inline void SyncedNotificationIdentifier::set_coalescing_key(const char* value) {
  set_has_coalescing_key();
  if (coalescing_key_ == &::google::protobuf::internal::GetEmptyString()) {
    coalescing_key_ = new ::std::string;
  }
  coalescing_key_->assign(value);
}
inline void SyncedNotificationIdentifier::set_coalescing_key(const char* value, size_t size) {
  set_has_coalescing_key();
  if (coalescing_key_ == &::google::protobuf::internal::GetEmptyString()) {
    coalescing_key_ = new ::std::string;
  }
  coalescing_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationIdentifier::mutable_coalescing_key() {
  set_has_coalescing_key();
  if (coalescing_key_ == &::google::protobuf::internal::GetEmptyString()) {
    coalescing_key_ = new ::std::string;
  }
  return coalescing_key_;
}
inline ::std::string* SyncedNotificationIdentifier::release_coalescing_key() {
  clear_has_coalescing_key();
  if (coalescing_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = coalescing_key_;
    coalescing_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationIdentifier::set_allocated_coalescing_key(::std::string* coalescing_key) {
  if (coalescing_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete coalescing_key_;
  }
  if (coalescing_key) {
    set_has_coalescing_key();
    coalescing_key_ = coalescing_key;
  } else {
    clear_has_coalescing_key();
    coalescing_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// SyncedNotificationCreator

// optional int64 gaia_id = 1;
inline bool SyncedNotificationCreator::has_gaia_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncedNotificationCreator::set_has_gaia_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncedNotificationCreator::clear_has_gaia_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncedNotificationCreator::clear_gaia_id() {
  gaia_id_ = GOOGLE_LONGLONG(0);
  clear_has_gaia_id();
}
inline ::google::protobuf::int64 SyncedNotificationCreator::gaia_id() const {
  return gaia_id_;
}
inline void SyncedNotificationCreator::set_gaia_id(::google::protobuf::int64 value) {
  set_has_gaia_id();
  gaia_id_ = value;
}

// optional bool is_system = 2;
inline bool SyncedNotificationCreator::has_is_system() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncedNotificationCreator::set_has_is_system() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncedNotificationCreator::clear_has_is_system() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncedNotificationCreator::clear_is_system() {
  is_system_ = false;
  clear_has_is_system();
}
inline bool SyncedNotificationCreator::is_system() const {
  return is_system_;
}
inline void SyncedNotificationCreator::set_is_system(bool value) {
  set_has_is_system();
  is_system_ = value;
}

// optional string app_id = 3;
inline bool SyncedNotificationCreator::has_app_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncedNotificationCreator::set_has_app_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncedNotificationCreator::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncedNotificationCreator::clear_app_id() {
  if (app_id_ != &::google::protobuf::internal::GetEmptyString()) {
    app_id_->clear();
  }
  clear_has_app_id();
}
inline const ::std::string& SyncedNotificationCreator::app_id() const {
  return *app_id_;
}
inline void SyncedNotificationCreator::set_app_id(const ::std::string& value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void SyncedNotificationCreator::set_app_id(const char* value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void SyncedNotificationCreator::set_app_id(const char* value, size_t size) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotificationCreator::mutable_app_id() {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  return app_id_;
}
inline ::std::string* SyncedNotificationCreator::release_app_id() {
  clear_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = app_id_;
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotificationCreator::set_allocated_app_id(::std::string* app_id) {
  if (app_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete app_id_;
  }
  if (app_id) {
    set_has_app_id();
    app_id_ = app_id;
  } else {
    clear_has_app_id();
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// SyncedNotificationRecipients

// repeated int64 gaia_id = 1;
inline int SyncedNotificationRecipients::gaia_id_size() const {
  return gaia_id_.size();
}
inline void SyncedNotificationRecipients::clear_gaia_id() {
  gaia_id_.Clear();
}
inline ::google::protobuf::int64 SyncedNotificationRecipients::gaia_id(int index) const {
  return gaia_id_.Get(index);
}
inline void SyncedNotificationRecipients::set_gaia_id(int index, ::google::protobuf::int64 value) {
  gaia_id_.Set(index, value);
}
inline void SyncedNotificationRecipients::add_gaia_id(::google::protobuf::int64 value) {
  gaia_id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SyncedNotificationRecipients::gaia_id() const {
  return gaia_id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SyncedNotificationRecipients::mutable_gaia_id() {
  return &gaia_id_;
}

// -------------------------------------------------------------------

// SyncedNotification

// optional string type = 1;
inline bool SyncedNotification::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SyncedNotification::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SyncedNotification::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SyncedNotification::clear_type() {
  if (type_ != &::google::protobuf::internal::GetEmptyString()) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& SyncedNotification::type() const {
  return *type_;
}
inline void SyncedNotification::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyString()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SyncedNotification::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyString()) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void SyncedNotification::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyString()) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotification::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyString()) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* SyncedNotification::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotification::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::GetEmptyString()) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string external_id = 2;
inline bool SyncedNotification::has_external_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SyncedNotification::set_has_external_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SyncedNotification::clear_has_external_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SyncedNotification::clear_external_id() {
  if (external_id_ != &::google::protobuf::internal::GetEmptyString()) {
    external_id_->clear();
  }
  clear_has_external_id();
}
inline const ::std::string& SyncedNotification::external_id() const {
  return *external_id_;
}
inline void SyncedNotification::set_external_id(const ::std::string& value) {
  set_has_external_id();
  if (external_id_ == &::google::protobuf::internal::GetEmptyString()) {
    external_id_ = new ::std::string;
  }
  external_id_->assign(value);
}
inline void SyncedNotification::set_external_id(const char* value) {
  set_has_external_id();
  if (external_id_ == &::google::protobuf::internal::GetEmptyString()) {
    external_id_ = new ::std::string;
  }
  external_id_->assign(value);
}
inline void SyncedNotification::set_external_id(const char* value, size_t size) {
  set_has_external_id();
  if (external_id_ == &::google::protobuf::internal::GetEmptyString()) {
    external_id_ = new ::std::string;
  }
  external_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SyncedNotification::mutable_external_id() {
  set_has_external_id();
  if (external_id_ == &::google::protobuf::internal::GetEmptyString()) {
    external_id_ = new ::std::string;
  }
  return external_id_;
}
inline ::std::string* SyncedNotification::release_external_id() {
  clear_has_external_id();
  if (external_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = external_id_;
    external_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void SyncedNotification::set_allocated_external_id(::std::string* external_id) {
  if (external_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete external_id_;
  }
  if (external_id) {
    set_has_external_id();
    external_id_ = external_id;
  } else {
    clear_has_external_id();
    external_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.SyncedNotificationCreator creator = 3;
inline bool SyncedNotification::has_creator() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SyncedNotification::set_has_creator() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SyncedNotification::clear_has_creator() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SyncedNotification::clear_creator() {
  if (creator_ != NULL) creator_->::sync_pb::SyncedNotificationCreator::Clear();
  clear_has_creator();
}
inline const ::sync_pb::SyncedNotificationCreator& SyncedNotification::creator() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return creator_ != NULL ? *creator_ : *default_instance().creator_;
#else
  return creator_ != NULL ? *creator_ : *default_instance_->creator_;
#endif
}
inline ::sync_pb::SyncedNotificationCreator* SyncedNotification::mutable_creator() {
  set_has_creator();
  if (creator_ == NULL) creator_ = new ::sync_pb::SyncedNotificationCreator;
  return creator_;
}
inline ::sync_pb::SyncedNotificationCreator* SyncedNotification::release_creator() {
  clear_has_creator();
  ::sync_pb::SyncedNotificationCreator* temp = creator_;
  creator_ = NULL;
  return temp;
}
inline void SyncedNotification::set_allocated_creator(::sync_pb::SyncedNotificationCreator* creator) {
  delete creator_;
  creator_ = creator;
  if (creator) {
    set_has_creator();
  } else {
    clear_has_creator();
  }
}

// optional .sync_pb.MapData client_data = 4;
inline bool SyncedNotification::has_client_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SyncedNotification::set_has_client_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SyncedNotification::clear_has_client_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SyncedNotification::clear_client_data() {
  if (client_data_ != NULL) client_data_->::sync_pb::MapData::Clear();
  clear_has_client_data();
}
inline const ::sync_pb::MapData& SyncedNotification::client_data() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return client_data_ != NULL ? *client_data_ : *default_instance().client_data_;
#else
  return client_data_ != NULL ? *client_data_ : *default_instance_->client_data_;
#endif
}
inline ::sync_pb::MapData* SyncedNotification::mutable_client_data() {
  set_has_client_data();
  if (client_data_ == NULL) client_data_ = new ::sync_pb::MapData;
  return client_data_;
}
inline ::sync_pb::MapData* SyncedNotification::release_client_data() {
  clear_has_client_data();
  ::sync_pb::MapData* temp = client_data_;
  client_data_ = NULL;
  return temp;
}
inline void SyncedNotification::set_allocated_client_data(::sync_pb::MapData* client_data) {
  delete client_data_;
  client_data_ = client_data;
  if (client_data) {
    set_has_client_data();
  } else {
    clear_has_client_data();
  }
}

// -------------------------------------------------------------------

// CoalescedSyncedNotification

// optional string key = 1;
inline bool CoalescedSyncedNotification::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoalescedSyncedNotification::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoalescedSyncedNotification::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoalescedSyncedNotification::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyString()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CoalescedSyncedNotification::key() const {
  return *key_;
}
inline void CoalescedSyncedNotification::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyString()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CoalescedSyncedNotification::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyString()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CoalescedSyncedNotification::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyString()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoalescedSyncedNotification::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyString()) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* CoalescedSyncedNotification::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CoalescedSyncedNotification::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional string app_id = 2;
inline bool CoalescedSyncedNotification::has_app_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoalescedSyncedNotification::set_has_app_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoalescedSyncedNotification::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoalescedSyncedNotification::clear_app_id() {
  if (app_id_ != &::google::protobuf::internal::GetEmptyString()) {
    app_id_->clear();
  }
  clear_has_app_id();
}
inline const ::std::string& CoalescedSyncedNotification::app_id() const {
  return *app_id_;
}
inline void CoalescedSyncedNotification::set_app_id(const ::std::string& value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void CoalescedSyncedNotification::set_app_id(const char* value) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(value);
}
inline void CoalescedSyncedNotification::set_app_id(const char* value, size_t size) {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  app_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoalescedSyncedNotification::mutable_app_id() {
  set_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    app_id_ = new ::std::string;
  }
  return app_id_;
}
inline ::std::string* CoalescedSyncedNotification::release_app_id() {
  clear_has_app_id();
  if (app_id_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = app_id_;
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void CoalescedSyncedNotification::set_allocated_app_id(::std::string* app_id) {
  if (app_id_ != &::google::protobuf::internal::GetEmptyString()) {
    delete app_id_;
  }
  if (app_id) {
    set_has_app_id();
    app_id_ = app_id;
  } else {
    clear_has_app_id();
    app_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// repeated .sync_pb.SyncedNotification notification = 3;
inline int CoalescedSyncedNotification::notification_size() const {
  return notification_.size();
}
inline void CoalescedSyncedNotification::clear_notification() {
  notification_.Clear();
}
inline const ::sync_pb::SyncedNotification& CoalescedSyncedNotification::notification(int index) const {
  return notification_.Get(index);
}
inline ::sync_pb::SyncedNotification* CoalescedSyncedNotification::mutable_notification(int index) {
  return notification_.Mutable(index);
}
inline ::sync_pb::SyncedNotification* CoalescedSyncedNotification::add_notification() {
  return notification_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncedNotification >&
CoalescedSyncedNotification::notification() const {
  return notification_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::SyncedNotification >*
CoalescedSyncedNotification::mutable_notification() {
  return &notification_;
}

// optional .sync_pb.SyncedNotificationRenderInfo render_info = 4;
inline bool CoalescedSyncedNotification::has_render_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoalescedSyncedNotification::set_has_render_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CoalescedSyncedNotification::clear_has_render_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CoalescedSyncedNotification::clear_render_info() {
  if (render_info_ != NULL) render_info_->::sync_pb::SyncedNotificationRenderInfo::Clear();
  clear_has_render_info();
}
inline const ::sync_pb::SyncedNotificationRenderInfo& CoalescedSyncedNotification::render_info() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return render_info_ != NULL ? *render_info_ : *default_instance().render_info_;
#else
  return render_info_ != NULL ? *render_info_ : *default_instance_->render_info_;
#endif
}
inline ::sync_pb::SyncedNotificationRenderInfo* CoalescedSyncedNotification::mutable_render_info() {
  set_has_render_info();
  if (render_info_ == NULL) render_info_ = new ::sync_pb::SyncedNotificationRenderInfo;
  return render_info_;
}
inline ::sync_pb::SyncedNotificationRenderInfo* CoalescedSyncedNotification::release_render_info() {
  clear_has_render_info();
  ::sync_pb::SyncedNotificationRenderInfo* temp = render_info_;
  render_info_ = NULL;
  return temp;
}
inline void CoalescedSyncedNotification::set_allocated_render_info(::sync_pb::SyncedNotificationRenderInfo* render_info) {
  delete render_info_;
  render_info_ = render_info;
  if (render_info) {
    set_has_render_info();
  } else {
    clear_has_render_info();
  }
}

// optional .sync_pb.CoalescedSyncedNotification.ReadState read_state = 5;
inline bool CoalescedSyncedNotification::has_read_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CoalescedSyncedNotification::set_has_read_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CoalescedSyncedNotification::clear_has_read_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CoalescedSyncedNotification::clear_read_state() {
  read_state_ = 1;
  clear_has_read_state();
}
inline ::sync_pb::CoalescedSyncedNotification_ReadState CoalescedSyncedNotification::read_state() const {
  return static_cast< ::sync_pb::CoalescedSyncedNotification_ReadState >(read_state_);
}
inline void CoalescedSyncedNotification::set_read_state(::sync_pb::CoalescedSyncedNotification_ReadState value) {
  assert(::sync_pb::CoalescedSyncedNotification_ReadState_IsValid(value));
  set_has_read_state();
  read_state_ = value;
}

// optional uint64 creation_time_msec = 6;
inline bool CoalescedSyncedNotification::has_creation_time_msec() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CoalescedSyncedNotification::set_has_creation_time_msec() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CoalescedSyncedNotification::clear_has_creation_time_msec() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CoalescedSyncedNotification::clear_creation_time_msec() {
  creation_time_msec_ = GOOGLE_ULONGLONG(0);
  clear_has_creation_time_msec();
}
inline ::google::protobuf::uint64 CoalescedSyncedNotification::creation_time_msec() const {
  return creation_time_msec_;
}
inline void CoalescedSyncedNotification::set_creation_time_msec(::google::protobuf::uint64 value) {
  set_has_creation_time_msec();
  creation_time_msec_ = value;
}

// optional .sync_pb.CoalescedSyncedNotification.Priority priority = 7;
inline bool CoalescedSyncedNotification::has_priority() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CoalescedSyncedNotification::set_has_priority() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CoalescedSyncedNotification::clear_has_priority() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CoalescedSyncedNotification::clear_priority() {
  priority_ = 1;
  clear_has_priority();
}
inline ::sync_pb::CoalescedSyncedNotification_Priority CoalescedSyncedNotification::priority() const {
  return static_cast< ::sync_pb::CoalescedSyncedNotification_Priority >(priority_);
}
inline void CoalescedSyncedNotification::set_priority(::sync_pb::CoalescedSyncedNotification_Priority value) {
  assert(::sync_pb::CoalescedSyncedNotification_Priority_IsValid(value));
  set_has_priority();
  priority_ = value;
}

// -------------------------------------------------------------------

// SyncedNotificationList

// repeated .sync_pb.CoalescedSyncedNotification coalesced_notification = 1;
inline int SyncedNotificationList::coalesced_notification_size() const {
  return coalesced_notification_.size();
}
inline void SyncedNotificationList::clear_coalesced_notification() {
  coalesced_notification_.Clear();
}
inline const ::sync_pb::CoalescedSyncedNotification& SyncedNotificationList::coalesced_notification(int index) const {
  return coalesced_notification_.Get(index);
}
inline ::sync_pb::CoalescedSyncedNotification* SyncedNotificationList::mutable_coalesced_notification(int index) {
  return coalesced_notification_.Mutable(index);
}
inline ::sync_pb::CoalescedSyncedNotification* SyncedNotificationList::add_coalesced_notification() {
  return coalesced_notification_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::CoalescedSyncedNotification >&
SyncedNotificationList::coalesced_notification() const {
  return coalesced_notification_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::CoalescedSyncedNotification >*
SyncedNotificationList::mutable_coalesced_notification() {
  return &coalesced_notification_;
}

// -------------------------------------------------------------------

// MapData_Entry

// optional string key = 1;
inline bool MapData_Entry::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapData_Entry::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapData_Entry::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapData_Entry::clear_key() {
  if (key_ != &::google::protobuf::internal::GetEmptyString()) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& MapData_Entry::key() const {
  return *key_;
}
inline void MapData_Entry::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyString()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MapData_Entry::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyString()) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void MapData_Entry::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyString()) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapData_Entry::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyString()) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* MapData_Entry::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void MapData_Entry::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.Data value = 2;
inline bool MapData_Entry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapData_Entry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapData_Entry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapData_Entry::clear_value() {
  if (value_ != NULL) value_->::sync_pb::Data::Clear();
  clear_has_value();
}
inline const ::sync_pb::Data& MapData_Entry::value() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return value_ != NULL ? *value_ : *default_instance().value_;
#else
  return value_ != NULL ? *value_ : *default_instance_->value_;
#endif
}
inline ::sync_pb::Data* MapData_Entry::mutable_value() {
  set_has_value();
  if (value_ == NULL) value_ = new ::sync_pb::Data;
  return value_;
}
inline ::sync_pb::Data* MapData_Entry::release_value() {
  clear_has_value();
  ::sync_pb::Data* temp = value_;
  value_ = NULL;
  return temp;
}
inline void MapData_Entry::set_allocated_value(::sync_pb::Data* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
}

// -------------------------------------------------------------------

// MapData

// repeated .sync_pb.MapData.Entry entry = 1;
inline int MapData::entry_size() const {
  return entry_.size();
}
inline void MapData::clear_entry() {
  entry_.Clear();
}
inline const ::sync_pb::MapData_Entry& MapData::entry(int index) const {
  return entry_.Get(index);
}
inline ::sync_pb::MapData_Entry* MapData::mutable_entry(int index) {
  return entry_.Mutable(index);
}
inline ::sync_pb::MapData_Entry* MapData::add_entry() {
  return entry_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::MapData_Entry >&
MapData::entry() const {
  return entry_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::MapData_Entry >*
MapData::mutable_entry() {
  return &entry_;
}

// -------------------------------------------------------------------

// Data

// optional bool boolean_value = 1;
inline bool Data::has_boolean_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Data::set_has_boolean_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Data::clear_has_boolean_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Data::clear_boolean_value() {
  boolean_value_ = false;
  clear_has_boolean_value();
}
inline bool Data::boolean_value() const {
  return boolean_value_;
}
inline void Data::set_boolean_value(bool value) {
  set_has_boolean_value();
  boolean_value_ = value;
}

// optional int32 int_value = 2;
inline bool Data::has_int_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Data::set_has_int_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Data::clear_has_int_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Data::clear_int_value() {
  int_value_ = 0;
  clear_has_int_value();
}
inline ::google::protobuf::int32 Data::int_value() const {
  return int_value_;
}
inline void Data::set_int_value(::google::protobuf::int32 value) {
  set_has_int_value();
  int_value_ = value;
}

// optional double float_value = 3;
inline bool Data::has_float_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Data::set_has_float_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Data::clear_has_float_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Data::clear_float_value() {
  float_value_ = 0;
  clear_has_float_value();
}
inline double Data::float_value() const {
  return float_value_;
}
inline void Data::set_float_value(double value) {
  set_has_float_value();
  float_value_ = value;
}

// optional string string_value = 4;
inline bool Data::has_string_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Data::set_has_string_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Data::clear_has_string_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Data::clear_string_value() {
  if (string_value_ != &::google::protobuf::internal::GetEmptyString()) {
    string_value_->clear();
  }
  clear_has_string_value();
}
inline const ::std::string& Data::string_value() const {
  return *string_value_;
}
inline void Data::set_string_value(const ::std::string& value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyString()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void Data::set_string_value(const char* value) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyString()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(value);
}
inline void Data::set_string_value(const char* value, size_t size) {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyString()) {
    string_value_ = new ::std::string;
  }
  string_value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Data::mutable_string_value() {
  set_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyString()) {
    string_value_ = new ::std::string;
  }
  return string_value_;
}
inline ::std::string* Data::release_string_value() {
  clear_has_string_value();
  if (string_value_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = string_value_;
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void Data::set_allocated_string_value(::std::string* string_value) {
  if (string_value_ != &::google::protobuf::internal::GetEmptyString()) {
    delete string_value_;
  }
  if (string_value) {
    set_has_string_value();
    string_value_ = string_value;
  } else {
    clear_has_string_value();
    string_value_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional .sync_pb.ListData list_value = 5;
inline bool Data::has_list_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Data::set_has_list_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Data::clear_has_list_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Data::clear_list_value() {
  if (list_value_ != NULL) list_value_->::sync_pb::ListData::Clear();
  clear_has_list_value();
}
inline const ::sync_pb::ListData& Data::list_value() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return list_value_ != NULL ? *list_value_ : *default_instance().list_value_;
#else
  return list_value_ != NULL ? *list_value_ : *default_instance_->list_value_;
#endif
}
inline ::sync_pb::ListData* Data::mutable_list_value() {
  set_has_list_value();
  if (list_value_ == NULL) list_value_ = new ::sync_pb::ListData;
  return list_value_;
}
inline ::sync_pb::ListData* Data::release_list_value() {
  clear_has_list_value();
  ::sync_pb::ListData* temp = list_value_;
  list_value_ = NULL;
  return temp;
}
inline void Data::set_allocated_list_value(::sync_pb::ListData* list_value) {
  delete list_value_;
  list_value_ = list_value;
  if (list_value) {
    set_has_list_value();
  } else {
    clear_has_list_value();
  }
}

// optional .sync_pb.MapData map_value = 6;
inline bool Data::has_map_value() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Data::set_has_map_value() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Data::clear_has_map_value() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Data::clear_map_value() {
  if (map_value_ != NULL) map_value_->::sync_pb::MapData::Clear();
  clear_has_map_value();
}
inline const ::sync_pb::MapData& Data::map_value() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return map_value_ != NULL ? *map_value_ : *default_instance().map_value_;
#else
  return map_value_ != NULL ? *map_value_ : *default_instance_->map_value_;
#endif
}
inline ::sync_pb::MapData* Data::mutable_map_value() {
  set_has_map_value();
  if (map_value_ == NULL) map_value_ = new ::sync_pb::MapData;
  return map_value_;
}
inline ::sync_pb::MapData* Data::release_map_value() {
  clear_has_map_value();
  ::sync_pb::MapData* temp = map_value_;
  map_value_ = NULL;
  return temp;
}
inline void Data::set_allocated_map_value(::sync_pb::MapData* map_value) {
  delete map_value_;
  map_value_ = map_value;
  if (map_value) {
    set_has_map_value();
  } else {
    clear_has_map_value();
  }
}

// -------------------------------------------------------------------

// ListData

// repeated .sync_pb.Data value = 1;
inline int ListData::value_size() const {
  return value_.size();
}
inline void ListData::clear_value() {
  value_.Clear();
}
inline const ::sync_pb::Data& ListData::value(int index) const {
  return value_.Get(index);
}
inline ::sync_pb::Data* ListData::mutable_value(int index) {
  return value_.Mutable(index);
}
inline ::sync_pb::Data* ListData::add_value() {
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::Data >&
ListData::value() const {
  return value_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::Data >*
ListData::mutable_value() {
  return &value_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sync_pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_synced_5fnotification_5fdata_2eproto__INCLUDED
