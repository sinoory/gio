// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: nigori_specifics.proto

#ifndef PROTOBUF_nigori_5fspecifics_2eproto__INCLUDED
#define PROTOBUF_nigori_5fspecifics_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "encryption.pb.h"
// @@protoc_insertion_point(includes)
#include "sync/base/sync_export.h"

namespace sync_pb {

// Internal implementation detail -- do not call these.
void SYNC_EXPORT protobuf_AddDesc_nigori_5fspecifics_2eproto();
void protobuf_AssignDesc_nigori_5fspecifics_2eproto();
void protobuf_ShutdownFile_nigori_5fspecifics_2eproto();

class NigoriKey;
class NigoriKeyBag;
class NigoriSpecifics;

enum NigoriSpecifics_PassphraseType {
  NigoriSpecifics_PassphraseType_IMPLICIT_PASSPHRASE = 1,
  NigoriSpecifics_PassphraseType_KEYSTORE_PASSPHRASE = 2,
  NigoriSpecifics_PassphraseType_FROZEN_IMPLICIT_PASSPHRASE = 3,
  NigoriSpecifics_PassphraseType_CUSTOM_PASSPHRASE = 4
};
SYNC_EXPORT bool NigoriSpecifics_PassphraseType_IsValid(int value);
const NigoriSpecifics_PassphraseType NigoriSpecifics_PassphraseType_PassphraseType_MIN = NigoriSpecifics_PassphraseType_IMPLICIT_PASSPHRASE;
const NigoriSpecifics_PassphraseType NigoriSpecifics_PassphraseType_PassphraseType_MAX = NigoriSpecifics_PassphraseType_CUSTOM_PASSPHRASE;
const int NigoriSpecifics_PassphraseType_PassphraseType_ARRAYSIZE = NigoriSpecifics_PassphraseType_PassphraseType_MAX + 1;

// ===================================================================

class SYNC_EXPORT NigoriKey : public ::google::protobuf::MessageLite {
 public:
  NigoriKey();
  virtual ~NigoriKey();

  NigoriKey(const NigoriKey& from);

  inline NigoriKey& operator=(const NigoriKey& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NigoriKey& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NigoriKey* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NigoriKey* other);

  // implements Message ----------------------------------------------

  NigoriKey* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NigoriKey& from);
  void MergeFrom(const NigoriKey& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes user_key = 2;
  inline bool has_user_key() const;
  inline void clear_user_key();
  static const int kUserKeyFieldNumber = 2;
  inline const ::std::string& user_key() const;
  inline void set_user_key(const ::std::string& value);
  inline void set_user_key(const char* value);
  inline void set_user_key(const void* value, size_t size);
  inline ::std::string* mutable_user_key();
  inline ::std::string* release_user_key();
  inline void set_allocated_user_key(::std::string* user_key);

  // optional bytes encryption_key = 3;
  inline bool has_encryption_key() const;
  inline void clear_encryption_key();
  static const int kEncryptionKeyFieldNumber = 3;
  inline const ::std::string& encryption_key() const;
  inline void set_encryption_key(const ::std::string& value);
  inline void set_encryption_key(const char* value);
  inline void set_encryption_key(const void* value, size_t size);
  inline ::std::string* mutable_encryption_key();
  inline ::std::string* release_encryption_key();
  inline void set_allocated_encryption_key(::std::string* encryption_key);

  // optional bytes mac_key = 4;
  inline bool has_mac_key() const;
  inline void clear_mac_key();
  static const int kMacKeyFieldNumber = 4;
  inline const ::std::string& mac_key() const;
  inline void set_mac_key(const ::std::string& value);
  inline void set_mac_key(const char* value);
  inline void set_mac_key(const void* value, size_t size);
  inline ::std::string* mutable_mac_key();
  inline ::std::string* release_mac_key();
  inline void set_allocated_mac_key(::std::string* mac_key);

  // @@protoc_insertion_point(class_scope:sync_pb.NigoriKey)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_user_key();
  inline void clear_has_user_key();
  inline void set_has_encryption_key();
  inline void clear_has_encryption_key();
  inline void set_has_mac_key();
  inline void clear_has_mac_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* user_key_;
  ::std::string* encryption_key_;
  ::std::string* mac_key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_nigori_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_nigori_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_nigori_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_nigori_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static NigoriKey* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT NigoriKeyBag : public ::google::protobuf::MessageLite {
 public:
  NigoriKeyBag();
  virtual ~NigoriKeyBag();

  NigoriKeyBag(const NigoriKeyBag& from);

  inline NigoriKeyBag& operator=(const NigoriKeyBag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NigoriKeyBag& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NigoriKeyBag* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NigoriKeyBag* other);

  // implements Message ----------------------------------------------

  NigoriKeyBag* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NigoriKeyBag& from);
  void MergeFrom(const NigoriKeyBag& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sync_pb.NigoriKey key = 2;
  inline int key_size() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::sync_pb::NigoriKey& key(int index) const;
  inline ::sync_pb::NigoriKey* mutable_key(int index);
  inline ::sync_pb::NigoriKey* add_key();
  inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::NigoriKey >&
      key() const;
  inline ::google::protobuf::RepeatedPtrField< ::sync_pb::NigoriKey >*
      mutable_key();

  // @@protoc_insertion_point(class_scope:sync_pb.NigoriKeyBag)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::sync_pb::NigoriKey > key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_nigori_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_nigori_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_nigori_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_nigori_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static NigoriKeyBag* default_instance_;
};
// -------------------------------------------------------------------

class SYNC_EXPORT NigoriSpecifics : public ::google::protobuf::MessageLite {
 public:
  NigoriSpecifics();
  virtual ~NigoriSpecifics();

  NigoriSpecifics(const NigoriSpecifics& from);

  inline NigoriSpecifics& operator=(const NigoriSpecifics& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const NigoriSpecifics& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NigoriSpecifics* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NigoriSpecifics* other);

  // implements Message ----------------------------------------------

  NigoriSpecifics* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NigoriSpecifics& from);
  void MergeFrom(const NigoriSpecifics& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  typedef NigoriSpecifics_PassphraseType PassphraseType;
  static const PassphraseType IMPLICIT_PASSPHRASE = NigoriSpecifics_PassphraseType_IMPLICIT_PASSPHRASE;
  static const PassphraseType KEYSTORE_PASSPHRASE = NigoriSpecifics_PassphraseType_KEYSTORE_PASSPHRASE;
  static const PassphraseType FROZEN_IMPLICIT_PASSPHRASE = NigoriSpecifics_PassphraseType_FROZEN_IMPLICIT_PASSPHRASE;
  static const PassphraseType CUSTOM_PASSPHRASE = NigoriSpecifics_PassphraseType_CUSTOM_PASSPHRASE;
  static inline bool PassphraseType_IsValid(int value) {
    return NigoriSpecifics_PassphraseType_IsValid(value);
  }
  static const PassphraseType PassphraseType_MIN =
    NigoriSpecifics_PassphraseType_PassphraseType_MIN;
  static const PassphraseType PassphraseType_MAX =
    NigoriSpecifics_PassphraseType_PassphraseType_MAX;
  static const int PassphraseType_ARRAYSIZE =
    NigoriSpecifics_PassphraseType_PassphraseType_ARRAYSIZE;

  // accessors -------------------------------------------------------

  // optional .sync_pb.EncryptedData encryption_keybag = 1;
  inline bool has_encryption_keybag() const;
  inline void clear_encryption_keybag();
  static const int kEncryptionKeybagFieldNumber = 1;
  inline const ::sync_pb::EncryptedData& encryption_keybag() const;
  inline ::sync_pb::EncryptedData* mutable_encryption_keybag();
  inline ::sync_pb::EncryptedData* release_encryption_keybag();
  inline void set_allocated_encryption_keybag(::sync_pb::EncryptedData* encryption_keybag);

  // optional bool keybag_is_frozen = 2;
  inline bool has_keybag_is_frozen() const;
  inline void clear_keybag_is_frozen();
  static const int kKeybagIsFrozenFieldNumber = 2;
  inline bool keybag_is_frozen() const;
  inline void set_keybag_is_frozen(bool value);

  // optional bool encrypt_bookmarks = 13;
  inline bool has_encrypt_bookmarks() const;
  inline void clear_encrypt_bookmarks();
  static const int kEncryptBookmarksFieldNumber = 13;
  inline bool encrypt_bookmarks() const;
  inline void set_encrypt_bookmarks(bool value);

  // optional bool encrypt_preferences = 14;
  inline bool has_encrypt_preferences() const;
  inline void clear_encrypt_preferences();
  static const int kEncryptPreferencesFieldNumber = 14;
  inline bool encrypt_preferences() const;
  inline void set_encrypt_preferences(bool value);

  // optional bool encrypt_autofill_profile = 15;
  inline bool has_encrypt_autofill_profile() const;
  inline void clear_encrypt_autofill_profile();
  static const int kEncryptAutofillProfileFieldNumber = 15;
  inline bool encrypt_autofill_profile() const;
  inline void set_encrypt_autofill_profile(bool value);

  // optional bool encrypt_autofill = 16;
  inline bool has_encrypt_autofill() const;
  inline void clear_encrypt_autofill();
  static const int kEncryptAutofillFieldNumber = 16;
  inline bool encrypt_autofill() const;
  inline void set_encrypt_autofill(bool value);

  // optional bool encrypt_themes = 17;
  inline bool has_encrypt_themes() const;
  inline void clear_encrypt_themes();
  static const int kEncryptThemesFieldNumber = 17;
  inline bool encrypt_themes() const;
  inline void set_encrypt_themes(bool value);

  // optional bool encrypt_typed_urls = 18;
  inline bool has_encrypt_typed_urls() const;
  inline void clear_encrypt_typed_urls();
  static const int kEncryptTypedUrlsFieldNumber = 18;
  inline bool encrypt_typed_urls() const;
  inline void set_encrypt_typed_urls(bool value);

  // optional bool encrypt_extensions = 19;
  inline bool has_encrypt_extensions() const;
  inline void clear_encrypt_extensions();
  static const int kEncryptExtensionsFieldNumber = 19;
  inline bool encrypt_extensions() const;
  inline void set_encrypt_extensions(bool value);

  // optional bool encrypt_sessions = 20;
  inline bool has_encrypt_sessions() const;
  inline void clear_encrypt_sessions();
  static const int kEncryptSessionsFieldNumber = 20;
  inline bool encrypt_sessions() const;
  inline void set_encrypt_sessions(bool value);

  // optional bool encrypt_apps = 21;
  inline bool has_encrypt_apps() const;
  inline void clear_encrypt_apps();
  static const int kEncryptAppsFieldNumber = 21;
  inline bool encrypt_apps() const;
  inline void set_encrypt_apps(bool value);

  // optional bool encrypt_search_engines = 22;
  inline bool has_encrypt_search_engines() const;
  inline void clear_encrypt_search_engines();
  static const int kEncryptSearchEnginesFieldNumber = 22;
  inline bool encrypt_search_engines() const;
  inline void set_encrypt_search_engines(bool value);

  // optional bool encrypt_everything = 24;
  inline bool has_encrypt_everything() const;
  inline void clear_encrypt_everything();
  static const int kEncryptEverythingFieldNumber = 24;
  inline bool encrypt_everything() const;
  inline void set_encrypt_everything(bool value);

  // optional bool encrypt_extension_settings = 25;
  inline bool has_encrypt_extension_settings() const;
  inline void clear_encrypt_extension_settings();
  static const int kEncryptExtensionSettingsFieldNumber = 25;
  inline bool encrypt_extension_settings() const;
  inline void set_encrypt_extension_settings(bool value);

  // optional bool encrypt_app_notifications = 26;
  inline bool has_encrypt_app_notifications() const;
  inline void clear_encrypt_app_notifications();
  static const int kEncryptAppNotificationsFieldNumber = 26;
  inline bool encrypt_app_notifications() const;
  inline void set_encrypt_app_notifications(bool value);

  // optional bool encrypt_app_settings = 27;
  inline bool has_encrypt_app_settings() const;
  inline void clear_encrypt_app_settings();
  static const int kEncryptAppSettingsFieldNumber = 27;
  inline bool encrypt_app_settings() const;
  inline void set_encrypt_app_settings(bool value);

  // optional bool sync_tab_favicons = 29;
  inline bool has_sync_tab_favicons() const;
  inline void clear_sync_tab_favicons();
  static const int kSyncTabFaviconsFieldNumber = 29;
  inline bool sync_tab_favicons() const;
  inline void set_sync_tab_favicons(bool value);

  // optional .sync_pb.NigoriSpecifics.PassphraseType passphrase_type = 30 [default = IMPLICIT_PASSPHRASE];
  inline bool has_passphrase_type() const;
  inline void clear_passphrase_type();
  static const int kPassphraseTypeFieldNumber = 30;
  inline ::sync_pb::NigoriSpecifics_PassphraseType passphrase_type() const;
  inline void set_passphrase_type(::sync_pb::NigoriSpecifics_PassphraseType value);

  // optional .sync_pb.EncryptedData keystore_decryptor_token = 31;
  inline bool has_keystore_decryptor_token() const;
  inline void clear_keystore_decryptor_token();
  static const int kKeystoreDecryptorTokenFieldNumber = 31;
  inline const ::sync_pb::EncryptedData& keystore_decryptor_token() const;
  inline ::sync_pb::EncryptedData* mutable_keystore_decryptor_token();
  inline ::sync_pb::EncryptedData* release_keystore_decryptor_token();
  inline void set_allocated_keystore_decryptor_token(::sync_pb::EncryptedData* keystore_decryptor_token);

  // optional int64 keystore_migration_time = 32;
  inline bool has_keystore_migration_time() const;
  inline void clear_keystore_migration_time();
  static const int kKeystoreMigrationTimeFieldNumber = 32;
  inline ::google::protobuf::int64 keystore_migration_time() const;
  inline void set_keystore_migration_time(::google::protobuf::int64 value);

  // optional int64 custom_passphrase_time = 33;
  inline bool has_custom_passphrase_time() const;
  inline void clear_custom_passphrase_time();
  static const int kCustomPassphraseTimeFieldNumber = 33;
  inline ::google::protobuf::int64 custom_passphrase_time() const;
  inline void set_custom_passphrase_time(::google::protobuf::int64 value);

  // optional bool encrypt_dictionary = 34;
  inline bool has_encrypt_dictionary() const;
  inline void clear_encrypt_dictionary();
  static const int kEncryptDictionaryFieldNumber = 34;
  inline bool encrypt_dictionary() const;
  inline void set_encrypt_dictionary(bool value);

  // optional bool encrypt_favicon_images = 35;
  inline bool has_encrypt_favicon_images() const;
  inline void clear_encrypt_favicon_images();
  static const int kEncryptFaviconImagesFieldNumber = 35;
  inline bool encrypt_favicon_images() const;
  inline void set_encrypt_favicon_images(bool value);

  // optional bool encrypt_favicon_tracking = 36;
  inline bool has_encrypt_favicon_tracking() const;
  inline void clear_encrypt_favicon_tracking();
  static const int kEncryptFaviconTrackingFieldNumber = 36;
  inline bool encrypt_favicon_tracking() const;
  inline void set_encrypt_favicon_tracking(bool value);

  // optional bool encrypt_articles = 37;
  inline bool has_encrypt_articles() const;
  inline void clear_encrypt_articles();
  static const int kEncryptArticlesFieldNumber = 37;
  inline bool encrypt_articles() const;
  inline void set_encrypt_articles(bool value);

  // optional bool encrypt_app_list = 38;
  inline bool has_encrypt_app_list() const;
  inline void clear_encrypt_app_list();
  static const int kEncryptAppListFieldNumber = 38;
  inline bool encrypt_app_list() const;
  inline void set_encrypt_app_list(bool value);

  // @@protoc_insertion_point(class_scope:sync_pb.NigoriSpecifics)
 private:
  inline void set_has_encryption_keybag();
  inline void clear_has_encryption_keybag();
  inline void set_has_keybag_is_frozen();
  inline void clear_has_keybag_is_frozen();
  inline void set_has_encrypt_bookmarks();
  inline void clear_has_encrypt_bookmarks();
  inline void set_has_encrypt_preferences();
  inline void clear_has_encrypt_preferences();
  inline void set_has_encrypt_autofill_profile();
  inline void clear_has_encrypt_autofill_profile();
  inline void set_has_encrypt_autofill();
  inline void clear_has_encrypt_autofill();
  inline void set_has_encrypt_themes();
  inline void clear_has_encrypt_themes();
  inline void set_has_encrypt_typed_urls();
  inline void clear_has_encrypt_typed_urls();
  inline void set_has_encrypt_extensions();
  inline void clear_has_encrypt_extensions();
  inline void set_has_encrypt_sessions();
  inline void clear_has_encrypt_sessions();
  inline void set_has_encrypt_apps();
  inline void clear_has_encrypt_apps();
  inline void set_has_encrypt_search_engines();
  inline void clear_has_encrypt_search_engines();
  inline void set_has_encrypt_everything();
  inline void clear_has_encrypt_everything();
  inline void set_has_encrypt_extension_settings();
  inline void clear_has_encrypt_extension_settings();
  inline void set_has_encrypt_app_notifications();
  inline void clear_has_encrypt_app_notifications();
  inline void set_has_encrypt_app_settings();
  inline void clear_has_encrypt_app_settings();
  inline void set_has_sync_tab_favicons();
  inline void clear_has_sync_tab_favicons();
  inline void set_has_passphrase_type();
  inline void clear_has_passphrase_type();
  inline void set_has_keystore_decryptor_token();
  inline void clear_has_keystore_decryptor_token();
  inline void set_has_keystore_migration_time();
  inline void clear_has_keystore_migration_time();
  inline void set_has_custom_passphrase_time();
  inline void clear_has_custom_passphrase_time();
  inline void set_has_encrypt_dictionary();
  inline void clear_has_encrypt_dictionary();
  inline void set_has_encrypt_favicon_images();
  inline void clear_has_encrypt_favicon_images();
  inline void set_has_encrypt_favicon_tracking();
  inline void clear_has_encrypt_favicon_tracking();
  inline void set_has_encrypt_articles();
  inline void clear_has_encrypt_articles();
  inline void set_has_encrypt_app_list();
  inline void clear_has_encrypt_app_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::sync_pb::EncryptedData* encryption_keybag_;
  bool keybag_is_frozen_;
  bool encrypt_bookmarks_;
  bool encrypt_preferences_;
  bool encrypt_autofill_profile_;
  bool encrypt_autofill_;
  bool encrypt_themes_;
  bool encrypt_typed_urls_;
  bool encrypt_extensions_;
  bool encrypt_sessions_;
  bool encrypt_apps_;
  bool encrypt_search_engines_;
  bool encrypt_everything_;
  bool encrypt_extension_settings_;
  bool encrypt_app_notifications_;
  bool encrypt_app_settings_;
  bool sync_tab_favicons_;
  ::sync_pb::EncryptedData* keystore_decryptor_token_;
  ::google::protobuf::int64 keystore_migration_time_;
  ::google::protobuf::int64 custom_passphrase_time_;
  int passphrase_type_;
  bool encrypt_dictionary_;
  bool encrypt_favicon_images_;
  bool encrypt_favicon_tracking_;
  bool encrypt_articles_;
  bool encrypt_app_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void SYNC_EXPORT protobuf_AddDesc_nigori_5fspecifics_2eproto_impl();
  #else
  friend void SYNC_EXPORT protobuf_AddDesc_nigori_5fspecifics_2eproto();
  #endif
  friend void protobuf_AssignDesc_nigori_5fspecifics_2eproto();
  friend void protobuf_ShutdownFile_nigori_5fspecifics_2eproto();

  void InitAsDefaultInstance();
  static NigoriSpecifics* default_instance_;
};
// ===================================================================


// ===================================================================

// NigoriKey

// optional string name = 1;
inline bool NigoriKey::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NigoriKey::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NigoriKey::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NigoriKey::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NigoriKey::name() const {
  return *name_;
}
inline void NigoriKey::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NigoriKey::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NigoriKey::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NigoriKey::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NigoriKey::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void NigoriKey::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyString()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes user_key = 2;
inline bool NigoriKey::has_user_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NigoriKey::set_has_user_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NigoriKey::clear_has_user_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NigoriKey::clear_user_key() {
  if (user_key_ != &::google::protobuf::internal::GetEmptyString()) {
    user_key_->clear();
  }
  clear_has_user_key();
}
inline const ::std::string& NigoriKey::user_key() const {
  return *user_key_;
}
inline void NigoriKey::set_user_key(const ::std::string& value) {
  set_has_user_key();
  if (user_key_ == &::google::protobuf::internal::GetEmptyString()) {
    user_key_ = new ::std::string;
  }
  user_key_->assign(value);
}
inline void NigoriKey::set_user_key(const char* value) {
  set_has_user_key();
  if (user_key_ == &::google::protobuf::internal::GetEmptyString()) {
    user_key_ = new ::std::string;
  }
  user_key_->assign(value);
}
inline void NigoriKey::set_user_key(const void* value, size_t size) {
  set_has_user_key();
  if (user_key_ == &::google::protobuf::internal::GetEmptyString()) {
    user_key_ = new ::std::string;
  }
  user_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NigoriKey::mutable_user_key() {
  set_has_user_key();
  if (user_key_ == &::google::protobuf::internal::GetEmptyString()) {
    user_key_ = new ::std::string;
  }
  return user_key_;
}
inline ::std::string* NigoriKey::release_user_key() {
  clear_has_user_key();
  if (user_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = user_key_;
    user_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void NigoriKey::set_allocated_user_key(::std::string* user_key) {
  if (user_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete user_key_;
  }
  if (user_key) {
    set_has_user_key();
    user_key_ = user_key;
  } else {
    clear_has_user_key();
    user_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes encryption_key = 3;
inline bool NigoriKey::has_encryption_key() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NigoriKey::set_has_encryption_key() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NigoriKey::clear_has_encryption_key() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NigoriKey::clear_encryption_key() {
  if (encryption_key_ != &::google::protobuf::internal::GetEmptyString()) {
    encryption_key_->clear();
  }
  clear_has_encryption_key();
}
inline const ::std::string& NigoriKey::encryption_key() const {
  return *encryption_key_;
}
inline void NigoriKey::set_encryption_key(const ::std::string& value) {
  set_has_encryption_key();
  if (encryption_key_ == &::google::protobuf::internal::GetEmptyString()) {
    encryption_key_ = new ::std::string;
  }
  encryption_key_->assign(value);
}
inline void NigoriKey::set_encryption_key(const char* value) {
  set_has_encryption_key();
  if (encryption_key_ == &::google::protobuf::internal::GetEmptyString()) {
    encryption_key_ = new ::std::string;
  }
  encryption_key_->assign(value);
}
inline void NigoriKey::set_encryption_key(const void* value, size_t size) {
  set_has_encryption_key();
  if (encryption_key_ == &::google::protobuf::internal::GetEmptyString()) {
    encryption_key_ = new ::std::string;
  }
  encryption_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NigoriKey::mutable_encryption_key() {
  set_has_encryption_key();
  if (encryption_key_ == &::google::protobuf::internal::GetEmptyString()) {
    encryption_key_ = new ::std::string;
  }
  return encryption_key_;
}
inline ::std::string* NigoriKey::release_encryption_key() {
  clear_has_encryption_key();
  if (encryption_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = encryption_key_;
    encryption_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void NigoriKey::set_allocated_encryption_key(::std::string* encryption_key) {
  if (encryption_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete encryption_key_;
  }
  if (encryption_key) {
    set_has_encryption_key();
    encryption_key_ = encryption_key;
  } else {
    clear_has_encryption_key();
    encryption_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// optional bytes mac_key = 4;
inline bool NigoriKey::has_mac_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NigoriKey::set_has_mac_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NigoriKey::clear_has_mac_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NigoriKey::clear_mac_key() {
  if (mac_key_ != &::google::protobuf::internal::GetEmptyString()) {
    mac_key_->clear();
  }
  clear_has_mac_key();
}
inline const ::std::string& NigoriKey::mac_key() const {
  return *mac_key_;
}
inline void NigoriKey::set_mac_key(const ::std::string& value) {
  set_has_mac_key();
  if (mac_key_ == &::google::protobuf::internal::GetEmptyString()) {
    mac_key_ = new ::std::string;
  }
  mac_key_->assign(value);
}
inline void NigoriKey::set_mac_key(const char* value) {
  set_has_mac_key();
  if (mac_key_ == &::google::protobuf::internal::GetEmptyString()) {
    mac_key_ = new ::std::string;
  }
  mac_key_->assign(value);
}
inline void NigoriKey::set_mac_key(const void* value, size_t size) {
  set_has_mac_key();
  if (mac_key_ == &::google::protobuf::internal::GetEmptyString()) {
    mac_key_ = new ::std::string;
  }
  mac_key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NigoriKey::mutable_mac_key() {
  set_has_mac_key();
  if (mac_key_ == &::google::protobuf::internal::GetEmptyString()) {
    mac_key_ = new ::std::string;
  }
  return mac_key_;
}
inline ::std::string* NigoriKey::release_mac_key() {
  clear_has_mac_key();
  if (mac_key_ == &::google::protobuf::internal::GetEmptyString()) {
    return NULL;
  } else {
    ::std::string* temp = mac_key_;
    mac_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
    return temp;
  }
}
inline void NigoriKey::set_allocated_mac_key(::std::string* mac_key) {
  if (mac_key_ != &::google::protobuf::internal::GetEmptyString()) {
    delete mac_key_;
  }
  if (mac_key) {
    set_has_mac_key();
    mac_key_ = mac_key;
  } else {
    clear_has_mac_key();
    mac_key_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyString());
  }
}

// -------------------------------------------------------------------

// NigoriKeyBag

// repeated .sync_pb.NigoriKey key = 2;
inline int NigoriKeyBag::key_size() const {
  return key_.size();
}
inline void NigoriKeyBag::clear_key() {
  key_.Clear();
}
inline const ::sync_pb::NigoriKey& NigoriKeyBag::key(int index) const {
  return key_.Get(index);
}
inline ::sync_pb::NigoriKey* NigoriKeyBag::mutable_key(int index) {
  return key_.Mutable(index);
}
inline ::sync_pb::NigoriKey* NigoriKeyBag::add_key() {
  return key_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sync_pb::NigoriKey >&
NigoriKeyBag::key() const {
  return key_;
}
inline ::google::protobuf::RepeatedPtrField< ::sync_pb::NigoriKey >*
NigoriKeyBag::mutable_key() {
  return &key_;
}

// -------------------------------------------------------------------

// NigoriSpecifics

// optional .sync_pb.EncryptedData encryption_keybag = 1;
inline bool NigoriSpecifics::has_encryption_keybag() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NigoriSpecifics::set_has_encryption_keybag() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NigoriSpecifics::clear_has_encryption_keybag() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NigoriSpecifics::clear_encryption_keybag() {
  if (encryption_keybag_ != NULL) encryption_keybag_->::sync_pb::EncryptedData::Clear();
  clear_has_encryption_keybag();
}
inline const ::sync_pb::EncryptedData& NigoriSpecifics::encryption_keybag() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return encryption_keybag_ != NULL ? *encryption_keybag_ : *default_instance().encryption_keybag_;
#else
  return encryption_keybag_ != NULL ? *encryption_keybag_ : *default_instance_->encryption_keybag_;
#endif
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::mutable_encryption_keybag() {
  set_has_encryption_keybag();
  if (encryption_keybag_ == NULL) encryption_keybag_ = new ::sync_pb::EncryptedData;
  return encryption_keybag_;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::release_encryption_keybag() {
  clear_has_encryption_keybag();
  ::sync_pb::EncryptedData* temp = encryption_keybag_;
  encryption_keybag_ = NULL;
  return temp;
}
inline void NigoriSpecifics::set_allocated_encryption_keybag(::sync_pb::EncryptedData* encryption_keybag) {
  delete encryption_keybag_;
  encryption_keybag_ = encryption_keybag;
  if (encryption_keybag) {
    set_has_encryption_keybag();
  } else {
    clear_has_encryption_keybag();
  }
}

// optional bool keybag_is_frozen = 2;
inline bool NigoriSpecifics::has_keybag_is_frozen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NigoriSpecifics::set_has_keybag_is_frozen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NigoriSpecifics::clear_has_keybag_is_frozen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NigoriSpecifics::clear_keybag_is_frozen() {
  keybag_is_frozen_ = false;
  clear_has_keybag_is_frozen();
}
inline bool NigoriSpecifics::keybag_is_frozen() const {
  return keybag_is_frozen_;
}
inline void NigoriSpecifics::set_keybag_is_frozen(bool value) {
  set_has_keybag_is_frozen();
  keybag_is_frozen_ = value;
}

// optional bool encrypt_bookmarks = 13;
inline bool NigoriSpecifics::has_encrypt_bookmarks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_bookmarks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NigoriSpecifics::clear_has_encrypt_bookmarks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NigoriSpecifics::clear_encrypt_bookmarks() {
  encrypt_bookmarks_ = false;
  clear_has_encrypt_bookmarks();
}
inline bool NigoriSpecifics::encrypt_bookmarks() const {
  return encrypt_bookmarks_;
}
inline void NigoriSpecifics::set_encrypt_bookmarks(bool value) {
  set_has_encrypt_bookmarks();
  encrypt_bookmarks_ = value;
}

// optional bool encrypt_preferences = 14;
inline bool NigoriSpecifics::has_encrypt_preferences() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_preferences() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NigoriSpecifics::clear_has_encrypt_preferences() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NigoriSpecifics::clear_encrypt_preferences() {
  encrypt_preferences_ = false;
  clear_has_encrypt_preferences();
}
inline bool NigoriSpecifics::encrypt_preferences() const {
  return encrypt_preferences_;
}
inline void NigoriSpecifics::set_encrypt_preferences(bool value) {
  set_has_encrypt_preferences();
  encrypt_preferences_ = value;
}

// optional bool encrypt_autofill_profile = 15;
inline bool NigoriSpecifics::has_encrypt_autofill_profile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_autofill_profile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NigoriSpecifics::clear_has_encrypt_autofill_profile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NigoriSpecifics::clear_encrypt_autofill_profile() {
  encrypt_autofill_profile_ = false;
  clear_has_encrypt_autofill_profile();
}
inline bool NigoriSpecifics::encrypt_autofill_profile() const {
  return encrypt_autofill_profile_;
}
inline void NigoriSpecifics::set_encrypt_autofill_profile(bool value) {
  set_has_encrypt_autofill_profile();
  encrypt_autofill_profile_ = value;
}

// optional bool encrypt_autofill = 16;
inline bool NigoriSpecifics::has_encrypt_autofill() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_autofill() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NigoriSpecifics::clear_has_encrypt_autofill() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NigoriSpecifics::clear_encrypt_autofill() {
  encrypt_autofill_ = false;
  clear_has_encrypt_autofill();
}
inline bool NigoriSpecifics::encrypt_autofill() const {
  return encrypt_autofill_;
}
inline void NigoriSpecifics::set_encrypt_autofill(bool value) {
  set_has_encrypt_autofill();
  encrypt_autofill_ = value;
}

// optional bool encrypt_themes = 17;
inline bool NigoriSpecifics::has_encrypt_themes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_themes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NigoriSpecifics::clear_has_encrypt_themes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NigoriSpecifics::clear_encrypt_themes() {
  encrypt_themes_ = false;
  clear_has_encrypt_themes();
}
inline bool NigoriSpecifics::encrypt_themes() const {
  return encrypt_themes_;
}
inline void NigoriSpecifics::set_encrypt_themes(bool value) {
  set_has_encrypt_themes();
  encrypt_themes_ = value;
}

// optional bool encrypt_typed_urls = 18;
inline bool NigoriSpecifics::has_encrypt_typed_urls() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_typed_urls() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NigoriSpecifics::clear_has_encrypt_typed_urls() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NigoriSpecifics::clear_encrypt_typed_urls() {
  encrypt_typed_urls_ = false;
  clear_has_encrypt_typed_urls();
}
inline bool NigoriSpecifics::encrypt_typed_urls() const {
  return encrypt_typed_urls_;
}
inline void NigoriSpecifics::set_encrypt_typed_urls(bool value) {
  set_has_encrypt_typed_urls();
  encrypt_typed_urls_ = value;
}

// optional bool encrypt_extensions = 19;
inline bool NigoriSpecifics::has_encrypt_extensions() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_extensions() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NigoriSpecifics::clear_has_encrypt_extensions() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NigoriSpecifics::clear_encrypt_extensions() {
  encrypt_extensions_ = false;
  clear_has_encrypt_extensions();
}
inline bool NigoriSpecifics::encrypt_extensions() const {
  return encrypt_extensions_;
}
inline void NigoriSpecifics::set_encrypt_extensions(bool value) {
  set_has_encrypt_extensions();
  encrypt_extensions_ = value;
}

// optional bool encrypt_sessions = 20;
inline bool NigoriSpecifics::has_encrypt_sessions() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_sessions() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NigoriSpecifics::clear_has_encrypt_sessions() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NigoriSpecifics::clear_encrypt_sessions() {
  encrypt_sessions_ = false;
  clear_has_encrypt_sessions();
}
inline bool NigoriSpecifics::encrypt_sessions() const {
  return encrypt_sessions_;
}
inline void NigoriSpecifics::set_encrypt_sessions(bool value) {
  set_has_encrypt_sessions();
  encrypt_sessions_ = value;
}

// optional bool encrypt_apps = 21;
inline bool NigoriSpecifics::has_encrypt_apps() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_apps() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NigoriSpecifics::clear_has_encrypt_apps() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NigoriSpecifics::clear_encrypt_apps() {
  encrypt_apps_ = false;
  clear_has_encrypt_apps();
}
inline bool NigoriSpecifics::encrypt_apps() const {
  return encrypt_apps_;
}
inline void NigoriSpecifics::set_encrypt_apps(bool value) {
  set_has_encrypt_apps();
  encrypt_apps_ = value;
}

// optional bool encrypt_search_engines = 22;
inline bool NigoriSpecifics::has_encrypt_search_engines() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_search_engines() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NigoriSpecifics::clear_has_encrypt_search_engines() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NigoriSpecifics::clear_encrypt_search_engines() {
  encrypt_search_engines_ = false;
  clear_has_encrypt_search_engines();
}
inline bool NigoriSpecifics::encrypt_search_engines() const {
  return encrypt_search_engines_;
}
inline void NigoriSpecifics::set_encrypt_search_engines(bool value) {
  set_has_encrypt_search_engines();
  encrypt_search_engines_ = value;
}

// optional bool encrypt_everything = 24;
inline bool NigoriSpecifics::has_encrypt_everything() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_everything() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NigoriSpecifics::clear_has_encrypt_everything() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NigoriSpecifics::clear_encrypt_everything() {
  encrypt_everything_ = false;
  clear_has_encrypt_everything();
}
inline bool NigoriSpecifics::encrypt_everything() const {
  return encrypt_everything_;
}
inline void NigoriSpecifics::set_encrypt_everything(bool value) {
  set_has_encrypt_everything();
  encrypt_everything_ = value;
}

// optional bool encrypt_extension_settings = 25;
inline bool NigoriSpecifics::has_encrypt_extension_settings() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_extension_settings() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NigoriSpecifics::clear_has_encrypt_extension_settings() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NigoriSpecifics::clear_encrypt_extension_settings() {
  encrypt_extension_settings_ = false;
  clear_has_encrypt_extension_settings();
}
inline bool NigoriSpecifics::encrypt_extension_settings() const {
  return encrypt_extension_settings_;
}
inline void NigoriSpecifics::set_encrypt_extension_settings(bool value) {
  set_has_encrypt_extension_settings();
  encrypt_extension_settings_ = value;
}

// optional bool encrypt_app_notifications = 26;
inline bool NigoriSpecifics::has_encrypt_app_notifications() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_app_notifications() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NigoriSpecifics::clear_has_encrypt_app_notifications() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NigoriSpecifics::clear_encrypt_app_notifications() {
  encrypt_app_notifications_ = false;
  clear_has_encrypt_app_notifications();
}
inline bool NigoriSpecifics::encrypt_app_notifications() const {
  return encrypt_app_notifications_;
}
inline void NigoriSpecifics::set_encrypt_app_notifications(bool value) {
  set_has_encrypt_app_notifications();
  encrypt_app_notifications_ = value;
}

// optional bool encrypt_app_settings = 27;
inline bool NigoriSpecifics::has_encrypt_app_settings() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_app_settings() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NigoriSpecifics::clear_has_encrypt_app_settings() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NigoriSpecifics::clear_encrypt_app_settings() {
  encrypt_app_settings_ = false;
  clear_has_encrypt_app_settings();
}
inline bool NigoriSpecifics::encrypt_app_settings() const {
  return encrypt_app_settings_;
}
inline void NigoriSpecifics::set_encrypt_app_settings(bool value) {
  set_has_encrypt_app_settings();
  encrypt_app_settings_ = value;
}

// optional bool sync_tab_favicons = 29;
inline bool NigoriSpecifics::has_sync_tab_favicons() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NigoriSpecifics::set_has_sync_tab_favicons() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NigoriSpecifics::clear_has_sync_tab_favicons() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NigoriSpecifics::clear_sync_tab_favicons() {
  sync_tab_favicons_ = false;
  clear_has_sync_tab_favicons();
}
inline bool NigoriSpecifics::sync_tab_favicons() const {
  return sync_tab_favicons_;
}
inline void NigoriSpecifics::set_sync_tab_favicons(bool value) {
  set_has_sync_tab_favicons();
  sync_tab_favicons_ = value;
}

// optional .sync_pb.NigoriSpecifics.PassphraseType passphrase_type = 30 [default = IMPLICIT_PASSPHRASE];
inline bool NigoriSpecifics::has_passphrase_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NigoriSpecifics::set_has_passphrase_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NigoriSpecifics::clear_has_passphrase_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NigoriSpecifics::clear_passphrase_type() {
  passphrase_type_ = 1;
  clear_has_passphrase_type();
}
inline ::sync_pb::NigoriSpecifics_PassphraseType NigoriSpecifics::passphrase_type() const {
  return static_cast< ::sync_pb::NigoriSpecifics_PassphraseType >(passphrase_type_);
}
inline void NigoriSpecifics::set_passphrase_type(::sync_pb::NigoriSpecifics_PassphraseType value) {
  assert(::sync_pb::NigoriSpecifics_PassphraseType_IsValid(value));
  set_has_passphrase_type();
  passphrase_type_ = value;
}

// optional .sync_pb.EncryptedData keystore_decryptor_token = 31;
inline bool NigoriSpecifics::has_keystore_decryptor_token() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NigoriSpecifics::set_has_keystore_decryptor_token() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NigoriSpecifics::clear_has_keystore_decryptor_token() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NigoriSpecifics::clear_keystore_decryptor_token() {
  if (keystore_decryptor_token_ != NULL) keystore_decryptor_token_->::sync_pb::EncryptedData::Clear();
  clear_has_keystore_decryptor_token();
}
inline const ::sync_pb::EncryptedData& NigoriSpecifics::keystore_decryptor_token() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return keystore_decryptor_token_ != NULL ? *keystore_decryptor_token_ : *default_instance().keystore_decryptor_token_;
#else
  return keystore_decryptor_token_ != NULL ? *keystore_decryptor_token_ : *default_instance_->keystore_decryptor_token_;
#endif
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::mutable_keystore_decryptor_token() {
  set_has_keystore_decryptor_token();
  if (keystore_decryptor_token_ == NULL) keystore_decryptor_token_ = new ::sync_pb::EncryptedData;
  return keystore_decryptor_token_;
}
inline ::sync_pb::EncryptedData* NigoriSpecifics::release_keystore_decryptor_token() {
  clear_has_keystore_decryptor_token();
  ::sync_pb::EncryptedData* temp = keystore_decryptor_token_;
  keystore_decryptor_token_ = NULL;
  return temp;
}
inline void NigoriSpecifics::set_allocated_keystore_decryptor_token(::sync_pb::EncryptedData* keystore_decryptor_token) {
  delete keystore_decryptor_token_;
  keystore_decryptor_token_ = keystore_decryptor_token;
  if (keystore_decryptor_token) {
    set_has_keystore_decryptor_token();
  } else {
    clear_has_keystore_decryptor_token();
  }
}

// optional int64 keystore_migration_time = 32;
inline bool NigoriSpecifics::has_keystore_migration_time() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NigoriSpecifics::set_has_keystore_migration_time() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NigoriSpecifics::clear_has_keystore_migration_time() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NigoriSpecifics::clear_keystore_migration_time() {
  keystore_migration_time_ = GOOGLE_LONGLONG(0);
  clear_has_keystore_migration_time();
}
inline ::google::protobuf::int64 NigoriSpecifics::keystore_migration_time() const {
  return keystore_migration_time_;
}
inline void NigoriSpecifics::set_keystore_migration_time(::google::protobuf::int64 value) {
  set_has_keystore_migration_time();
  keystore_migration_time_ = value;
}

// optional int64 custom_passphrase_time = 33;
inline bool NigoriSpecifics::has_custom_passphrase_time() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NigoriSpecifics::set_has_custom_passphrase_time() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NigoriSpecifics::clear_has_custom_passphrase_time() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NigoriSpecifics::clear_custom_passphrase_time() {
  custom_passphrase_time_ = GOOGLE_LONGLONG(0);
  clear_has_custom_passphrase_time();
}
inline ::google::protobuf::int64 NigoriSpecifics::custom_passphrase_time() const {
  return custom_passphrase_time_;
}
inline void NigoriSpecifics::set_custom_passphrase_time(::google::protobuf::int64 value) {
  set_has_custom_passphrase_time();
  custom_passphrase_time_ = value;
}

// optional bool encrypt_dictionary = 34;
inline bool NigoriSpecifics::has_encrypt_dictionary() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_dictionary() {
  _has_bits_[0] |= 0x00200000u;
}
inline void NigoriSpecifics::clear_has_encrypt_dictionary() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void NigoriSpecifics::clear_encrypt_dictionary() {
  encrypt_dictionary_ = false;
  clear_has_encrypt_dictionary();
}
inline bool NigoriSpecifics::encrypt_dictionary() const {
  return encrypt_dictionary_;
}
inline void NigoriSpecifics::set_encrypt_dictionary(bool value) {
  set_has_encrypt_dictionary();
  encrypt_dictionary_ = value;
}

// optional bool encrypt_favicon_images = 35;
inline bool NigoriSpecifics::has_encrypt_favicon_images() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_favicon_images() {
  _has_bits_[0] |= 0x00400000u;
}
inline void NigoriSpecifics::clear_has_encrypt_favicon_images() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void NigoriSpecifics::clear_encrypt_favicon_images() {
  encrypt_favicon_images_ = false;
  clear_has_encrypt_favicon_images();
}
inline bool NigoriSpecifics::encrypt_favicon_images() const {
  return encrypt_favicon_images_;
}
inline void NigoriSpecifics::set_encrypt_favicon_images(bool value) {
  set_has_encrypt_favicon_images();
  encrypt_favicon_images_ = value;
}

// optional bool encrypt_favicon_tracking = 36;
inline bool NigoriSpecifics::has_encrypt_favicon_tracking() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_favicon_tracking() {
  _has_bits_[0] |= 0x00800000u;
}
inline void NigoriSpecifics::clear_has_encrypt_favicon_tracking() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void NigoriSpecifics::clear_encrypt_favicon_tracking() {
  encrypt_favicon_tracking_ = false;
  clear_has_encrypt_favicon_tracking();
}
inline bool NigoriSpecifics::encrypt_favicon_tracking() const {
  return encrypt_favicon_tracking_;
}
inline void NigoriSpecifics::set_encrypt_favicon_tracking(bool value) {
  set_has_encrypt_favicon_tracking();
  encrypt_favicon_tracking_ = value;
}

// optional bool encrypt_articles = 37;
inline bool NigoriSpecifics::has_encrypt_articles() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_articles() {
  _has_bits_[0] |= 0x01000000u;
}
inline void NigoriSpecifics::clear_has_encrypt_articles() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void NigoriSpecifics::clear_encrypt_articles() {
  encrypt_articles_ = false;
  clear_has_encrypt_articles();
}
inline bool NigoriSpecifics::encrypt_articles() const {
  return encrypt_articles_;
}
inline void NigoriSpecifics::set_encrypt_articles(bool value) {
  set_has_encrypt_articles();
  encrypt_articles_ = value;
}

// optional bool encrypt_app_list = 38;
inline bool NigoriSpecifics::has_encrypt_app_list() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void NigoriSpecifics::set_has_encrypt_app_list() {
  _has_bits_[0] |= 0x02000000u;
}
inline void NigoriSpecifics::clear_has_encrypt_app_list() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void NigoriSpecifics::clear_encrypt_app_list() {
  encrypt_app_list_ = false;
  clear_has_encrypt_app_list();
}
inline bool NigoriSpecifics::encrypt_app_list() const {
  return encrypt_app_list_;
}
inline void NigoriSpecifics::set_encrypt_app_list(bool value) {
  set_has_encrypt_app_list();
  encrypt_app_list_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace sync_pb

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_nigori_5fspecifics_2eproto__INCLUDED
